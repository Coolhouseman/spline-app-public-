{"file_contents":{"navigation/screenOptions.ts":{"content":"import { Platform } from \"react-native\";\nimport { NativeStackNavigationOptions } from \"@react-navigation/native-stack\";\nimport { isLiquidGlassAvailable } from \"expo-glass-effect\";\n\ninterface ScreenOptionsParams {\n  theme: {\n    backgroundRoot: string;\n    text: string;\n  };\n  isDark: boolean;\n  transparent?: boolean;\n}\n\nexport const getCommonScreenOptions = ({\n  theme,\n  isDark,\n  transparent = true,\n}: ScreenOptionsParams): NativeStackNavigationOptions => ({\n  headerTitleAlign: \"center\",\n  headerTransparent: transparent,\n  headerBlurEffect: isDark ? \"dark\" : \"light\",\n  headerTintColor: theme.text,\n  headerStyle: {\n    backgroundColor: Platform.select({\n      ios: undefined,\n      android: theme.backgroundRoot,\n      web: theme.backgroundRoot,\n    }),\n  },\n  gestureEnabled: true,\n  gestureDirection: \"horizontal\",\n  fullScreenGestureEnabled: isLiquidGlassAvailable() ? false : true,\n  contentStyle: {\n    backgroundColor: theme.backgroundRoot,\n  },\n});\n","path":null,"size_bytes":964,"size_tokens":null},"screens/SignupFirstNameScreen.tsx":{"content":"import React, { useState } from 'react';\nimport { View, TextInput, StyleSheet, Pressable } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\n\ntype Props = NativeStackScreenProps<any, 'SignupFirstName'>;\n\nexport default function SignupFirstNameScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const [firstName, setFirstName] = useState('');\n\n  const handleContinue = () => {\n    if (firstName.trim()) {\n      navigation.navigate('SignupLastName', { firstName });\n    }\n  };\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Step 1 of 8\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.xl }]}>\n          What's your first name?\n        </ThemedText>\n\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: theme.border \n          }]}\n          placeholder=\"First name\"\n          placeholderTextColor={theme.textSecondary}\n          value={firstName}\n          onChangeText={setFirstName}\n          autoFocus\n          autoCapitalize=\"words\"\n        />\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed ? 0.7 : (!firstName.trim() ? 0.4 : 1)\n            }\n          ]}\n          onPress={handleContinue}\n          disabled={!firstName.trim()}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            Continue\n          </ThemedText>\n        </Pressable>\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  input: {\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    fontSize: 16,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":2871,"size_tokens":null},"index.js":{"content":"import { registerRootComponent } from \"expo\";\n\nimport App from \"@/App\";\n\nregisterRootComponent(App);\n","path":null,"size_bytes":101,"size_tokens":null},"screens/SignupBioScreen.tsx":{"content":"import React, { useState } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, Alert } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { generateUniqueId } from '@/utils/storage';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\n\ntype Props = NativeStackScreenProps<any, 'SignupBio'>;\n\nexport default function SignupBioScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const { signup } = useAuth();\n  const [bio, setBio] = useState('');\n  const [loading, setLoading] = useState(false);\n  const params = route.params as { \n    firstName: string; \n    lastName: string; \n    email: string; \n    password: string; \n    phone: string; \n    dateOfBirth: string;\n    profilePicture?: string;\n  };\n\n  const MAX_LENGTH = 200;\n\n  const handleComplete = async () => {\n    setLoading(true);\n    try {\n      const uniqueId = generateUniqueId();\n      const fullName = `${params.firstName} ${params.lastName}`.trim();\n      \n      await signup({\n        name: fullName,\n        email: params.email,\n        password: params.password,\n        phone: params.phone,\n        dateOfBirth: params.dateOfBirth,\n        bio: bio.trim(),\n        uniqueId: uniqueId,\n        profilePicture: params.profilePicture,\n      });\n      \n    } catch (error: any) {\n      console.error('Signup error:', error);\n      Alert.alert('Signup Failed', error.message || 'An error occurred during signup');\n      setLoading(false);\n    }\n  };\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Step 8 of 8\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.xl }]}>\n          Tell us about yourself\n        </ThemedText>\n\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: theme.border \n          }]}\n          placeholder=\"Write a short bio...\"\n          placeholderTextColor={theme.textSecondary}\n          value={bio}\n          onChangeText={(text) => text.length <= MAX_LENGTH && setBio(text)}\n          multiline\n          numberOfLines={4}\n          autoFocus\n          textAlignVertical=\"top\"\n        />\n\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginTop: Spacing.sm }]}>\n          {bio.length}/{MAX_LENGTH} characters\n        </ThemedText>\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed ? 0.7 : (loading ? 0.4 : 1)\n            }\n          ]}\n          onPress={handleComplete}\n          disabled={loading}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            {loading ? 'Creating account...' : 'Complete Signup'}\n          </ThemedText>\n        </Pressable>\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  input: {\n    height: 120,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    paddingTop: Spacing.lg,\n    fontSize: 16,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":4118,"size_tokens":null},"screens/SignupLastNameScreen.tsx":{"content":"import React, { useState } from 'react';\nimport { View, TextInput, StyleSheet, Pressable } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\n\ntype Props = NativeStackScreenProps<any, 'SignupLastName'>;\n\nexport default function SignupLastNameScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const [lastName, setLastName] = useState('');\n  const { firstName } = route.params as { firstName: string };\n\n  const handleContinue = () => {\n    if (lastName.trim()) {\n      navigation.navigate('SignupEmail', { firstName, lastName });\n    }\n  };\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Step 2 of 8\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.xl }]}>\n          And your last name?\n        </ThemedText>\n\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: theme.border \n          }]}\n          placeholder=\"Last name\"\n          placeholderTextColor={theme.textSecondary}\n          value={lastName}\n          onChangeText={setLastName}\n          autoFocus\n          autoCapitalize=\"words\"\n        />\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed ? 0.7 : (!lastName.trim() ? 0.4 : 1)\n            }\n          ]}\n          onPress={handleContinue}\n          disabled={!lastName.trim()}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            Continue\n          </ThemedText>\n        </Pressable>\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  input: {\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    fontSize: 16,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":2927,"size_tokens":null},"screens/SignupPhoneScreen.tsx":{"content":"import React, { useState } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, ActivityIndicator } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { TwilioService } from '@/services/twilio.service';\n\ntype Props = NativeStackScreenProps<any, 'SignupPhone'>;\n\nexport default function SignupPhoneScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const [phone, setPhone] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n  const params = route.params as { firstName: string; lastName: string; email: string; password: string };\n\n  const formatPhoneDisplay = (value: string) => {\n    const digits = value.replace(/\\D/g, '');\n    return digits;\n  };\n\n  const handlePhoneChange = (text: string) => {\n    const formatted = formatPhoneDisplay(text);\n    setPhone(formatted);\n    if (error) setError('');\n  };\n\n  const getFullPhoneNumber = () => {\n    const cleaned = phone.replace(/\\D/g, '');\n    if (cleaned.startsWith('0')) {\n      return '+64' + cleaned.substring(1);\n    }\n    return '+64' + cleaned;\n  };\n\n  const isValidPhone = () => {\n    const cleaned = phone.replace(/\\D/g, '');\n    return cleaned.length >= 8 && cleaned.length <= 11;\n  };\n\n  const handleContinue = async () => {\n    if (!isValidPhone()) {\n      setError('Please enter a valid phone number');\n      return;\n    }\n\n    const fullPhone = getFullPhoneNumber();\n    setLoading(true);\n    setError('');\n\n    try {\n      const result = await TwilioService.sendOTP(fullPhone);\n\n      if (result.success) {\n        navigation.navigate('SignupPhoneOTP', { ...params, phone: fullPhone });\n      } else {\n        setError(result.error || 'Failed to send verification code');\n      }\n    } catch (err: any) {\n      setError(err.message || 'Failed to send verification code');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Step 5 of 8\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.md }]}>\n          What's your phone number?\n        </ThemedText>\n\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing.xl }]}>\n          We'll send you a verification code via SMS\n        </ThemedText>\n\n        <View style={styles.phoneInputContainer}>\n          <View style={[styles.prefixContainer, { \n            backgroundColor: theme.surface, \n            borderColor: error ? Colors.light.danger : theme.border \n          }]}>\n            <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n              +64\n            </ThemedText>\n          </View>\n          <TextInput\n            style={[styles.phoneInput, { \n              backgroundColor: theme.surface, \n              color: theme.text, \n              borderColor: error ? Colors.light.danger : theme.border \n            }]}\n            placeholder=\"21 123 4567\"\n            placeholderTextColor={theme.textSecondary}\n            value={phone}\n            onChangeText={handlePhoneChange}\n            keyboardType=\"phone-pad\"\n            autoFocus\n            maxLength={11}\n          />\n        </View>\n\n        {error ? (\n          <ThemedText style={[Typography.caption, { color: Colors.light.danger, marginTop: Spacing.sm }]}>\n            {error}\n          </ThemedText>\n        ) : null}\n\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginTop: Spacing.md }]}>\n          Standard SMS rates may apply\n        </ThemedText>\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed || loading ? 0.7 : (isValidPhone() ? 1 : 0.4)\n            }\n          ]}\n          onPress={handleContinue}\n          disabled={!isValidPhone() || loading}\n        >\n          {loading ? (\n            <ActivityIndicator color={Colors.light.buttonText} />\n          ) : (\n            <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n              Send Verification Code\n            </ThemedText>\n          )}\n        </Pressable>\n\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  phoneInputContainer: {\n    flexDirection: 'row',\n    gap: Spacing.sm,\n  },\n  prefixContainer: {\n    height: Spacing.inputHeight,\n    paddingHorizontal: Spacing.lg,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  phoneInput: {\n    flex: 1,\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    fontSize: 16,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":5745,"size_tokens":null},"screens/SignupEmailScreen.tsx":{"content":"import React, { useState } from 'react';\nimport { View, TextInput, StyleSheet, Pressable } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\n\ntype Props = NativeStackScreenProps<any, 'SignupEmail'>;\n\nexport default function SignupEmailScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const [email, setEmail] = useState('');\n  const params = route.params as { firstName: string; lastName: string };\n\n  const isValidEmail = (email: string) => {\n    return email.includes('@') && email.includes('.');\n  };\n\n  const handleContinue = () => {\n    if (email.trim() && isValidEmail(email)) {\n      navigation.navigate('SignupPassword', { ...params, email });\n    }\n  };\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Step 3 of 8\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.xl }]}>\n          What's your email?\n        </ThemedText>\n\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: theme.border \n          }]}\n          placeholder=\"Email address\"\n          placeholderTextColor={theme.textSecondary}\n          value={email}\n          onChangeText={setEmail}\n          keyboardType=\"email-address\"\n          autoFocus\n          autoCapitalize=\"none\"\n          autoCorrect={false}\n        />\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed ? 0.7 : (!isValidEmail(email) ? 0.4 : 1)\n            }\n          ]}\n          onPress={handleContinue}\n          disabled={!isValidEmail(email)}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            Continue\n          </ThemedText>\n        </Pressable>\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  input: {\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    fontSize: 16,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":3124,"size_tokens":null},"components/ScreenScrollView.tsx":{"content":"import { ScrollView, ScrollViewProps, StyleSheet } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useScreenInsets } from \"@/hooks/useScreenInsets\";\nimport { Spacing } from \"@/constants/theme\";\n\nexport function ScreenScrollView({\n  children,\n  contentContainerStyle,\n  style,\n  ...scrollViewProps\n}: ScrollViewProps) {\n  const { theme } = useTheme();\n  const { paddingTop, paddingBottom, scrollInsetBottom } = useScreenInsets();\n\n  return (\n    <ScrollView\n      style={[\n        styles.container,\n        { backgroundColor: theme.backgroundRoot },\n        style,\n      ]}\n      contentContainerStyle={[\n        {\n          paddingTop,\n          paddingBottom,\n        },\n        styles.contentContainer,\n        contentContainerStyle,\n      ]}\n      scrollIndicatorInsets={{ bottom: scrollInsetBottom }}\n      {...scrollViewProps}\n    >\n      {children}\n    </ScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  contentContainer: {\n    paddingHorizontal: Spacing.xl,\n  },\n});\n","path":null,"size_bytes":1043,"size_tokens":null},"App.tsx":{"content":"import React, { useEffect } from \"react\";\nimport { StyleSheet, View, useColorScheme, Platform } from \"react-native\";\nimport { NavigationContainer, DefaultTheme, DarkTheme } from \"@react-navigation/native\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport { GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport { KeyboardProvider } from \"react-native-keyboard-controller\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\nimport { StatusBar } from \"expo-status-bar\";\nimport * as Linking from \"expo-linking\";\n\nimport MainTabNavigator from \"@/navigation/MainTabNavigator\";\nimport AuthStackNavigator from \"@/navigation/AuthStackNavigator\";\nimport { ErrorBoundary } from \"@/components/ErrorBoundary\";\nimport { StripeWrapper } from \"@/components/StripeWrapper\";\nimport { LoadingOverlay } from \"@/components/LoadingOverlay\";\nimport { AuthProvider, useAuth } from \"@/hooks/useAuth\";\nimport { LevelUpProvider } from \"@/contexts/LevelUpContext\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Colors } from \"@/constants/theme\";\nimport { supabase } from \"@/services/supabase\";\nimport { navigationRef, notifyReady } from \"@/utils/RootNavigation\";\n\nconst Stack = createNativeStackNavigator();\n\nconst SPLASH_COLORS = {\n  light: '#2563EB',\n  dark: '#1e40af',\n};\n\nconst LightNavTheme = {\n  ...DefaultTheme,\n  colors: {\n    ...DefaultTheme.colors,\n    background: Colors.light.backgroundRoot,\n  },\n};\n\nconst DarkNavTheme = {\n  ...DarkTheme,\n  colors: {\n    ...DarkTheme.colors,\n    background: Colors.dark.backgroundRoot,\n  },\n};\n\nfunction RootNavigator() {\n  const { user, isLoading, isSigningUp } = useAuth();\n  const colorScheme = useColorScheme();\n\n  // Debug logging - track user state in RootNavigator\n  React.useEffect(() => {\n    console.log('RootNavigator: user changed to:', user ? user.id : 'null', 'isLoading:', isLoading, 'isSigningUp:', isSigningUp);\n  }, [user, isLoading, isSigningUp]);\n\n  // Show loading during initial load\n  if (isLoading) {\n    const splashBg = colorScheme === 'dark' ? SPLASH_COLORS.dark : SPLASH_COLORS.light;\n    return (\n      <View style={[styles.loading, { backgroundColor: splashBg }]}>\n        <LoadingOverlay visible={true} message=\"Loading...\" />\n      </View>\n    );\n  }\n\n  console.log('RootNavigator rendering: user is', user ? 'authenticated' : 'null');\n\n  return (\n    <View style={{ flex: 1 }}>\n      <Stack.Navigator \n        key={user ? 'authenticated' : 'unauthenticated'}\n        screenOptions={{ headerShown: false }}\n      >\n        {user ? (\n          <Stack.Screen name=\"Main\" component={MainTabNavigator} />\n        ) : (\n          <Stack.Screen name=\"Auth\" component={AuthStackNavigator} />\n        )}\n      </Stack.Navigator>\n      {/* Overlay loading on top of navigator during signup - keeps navigator mounted */}\n      {isSigningUp && (\n        <View style={[styles.loading, styles.overlay, { backgroundColor: colorScheme === 'dark' ? SPLASH_COLORS.dark : SPLASH_COLORS.light }]}>\n          <LoadingOverlay visible={true} message=\"Creating your account...\" />\n        </View>\n      )}\n    </View>\n  );\n}\n\nconst linking = {\n  prefixes: [\n    Linking.createURL('/'),\n    'splitpaymentapp://',\n  ],\n  config: {\n    screens: {\n      Auth: {\n        screens: {\n          ResetPassword: 'reset-password',\n        },\n      },\n    },\n  },\n};\n\nconst parseQueryParams = (url: string): Record<string, string> => {\n  const params: Record<string, string> = {};\n  try {\n    const hashIndex = url.indexOf('#');\n    const queryString = hashIndex !== -1 ? url.substring(hashIndex + 1) : '';\n    \n    if (queryString) {\n      queryString.split('&').forEach(param => {\n        const [key, value] = param.split('=');\n        if (key && value) {\n          params[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n      });\n    }\n    \n    const questionIndex = url.indexOf('?');\n    if (questionIndex !== -1) {\n      const searchParams = url.substring(questionIndex + 1, hashIndex !== -1 ? hashIndex : undefined);\n      searchParams.split('&').forEach(param => {\n        const [key, value] = param.split('=');\n        if (key && value) {\n          params[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n      });\n    }\n  } catch (error) {\n    console.error('Error parsing URL params:', error);\n  }\n  return params;\n};\n\nconst handlePasswordResetDeepLink = async (url: string) => {\n  try {\n    const params = parseQueryParams(url);\n    \n    if (params.access_token && params.refresh_token) {\n      const { error } = await supabase.auth.setSession({\n        access_token: params.access_token,\n        refresh_token: params.refresh_token,\n      });\n      \n      if (error) {\n        console.error('Failed to set session from password reset link:', error);\n      } else {\n        console.log('Session set from password reset link');\n      }\n    }\n  } catch (error) {\n    console.error('Error handling password reset deep link:', error);\n  }\n};\n\nfunction AppContent() {\n  const colorScheme = useColorScheme();\n  const splashBg = colorScheme === 'dark' ? SPLASH_COLORS.dark : SPLASH_COLORS.light;\n  const navTheme = colorScheme === 'dark' ? DarkNavTheme : LightNavTheme;\n\n  useEffect(() => {\n    const handleUrl = async (event: { url: string }) => {\n      const url = event.url;\n      if (url.includes('reset-password') || url.includes('access_token')) {\n        await handlePasswordResetDeepLink(url);\n      }\n    };\n\n    Linking.getInitialURL().then((url) => {\n      if (url) {\n        handleUrl({ url });\n      }\n    });\n\n    const subscription = Linking.addEventListener('url', handleUrl);\n    \n    return () => {\n      subscription.remove();\n    };\n  }, []);\n\n  return (\n    <GestureHandlerRootView style={[styles.root, { backgroundColor: splashBg }]}>\n      <KeyboardProvider>\n        <NavigationContainer \n          ref={navigationRef}\n          theme={navTheme}\n          linking={linking}\n          onReady={notifyReady}\n        >\n          <RootNavigator />\n        </NavigationContainer>\n        <StatusBar style=\"auto\" />\n      </KeyboardProvider>\n    </GestureHandlerRootView>\n  );\n}\n\nexport default function App() {\n  const colorScheme = useColorScheme();\n  const splashBg = colorScheme === 'dark' ? SPLASH_COLORS.dark : SPLASH_COLORS.light;\n\n  return (\n    <ErrorBoundary>\n      <AuthProvider>\n        <LevelUpProvider>\n          <View style={[styles.root, { backgroundColor: splashBg }]}>\n            <StripeWrapper>\n              <SafeAreaProvider>\n                <AppContent />\n              </SafeAreaProvider>\n            </StripeWrapper>\n          </View>\n        </LevelUpProvider>\n      </AuthProvider>\n    </ErrorBoundary>\n  );\n}\n\nconst styles = StyleSheet.create({\n  root: {\n    flex: 1,\n  },\n  loading: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  overlay: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    zIndex: 999,\n  },\n});\n","path":null,"size_bytes":6951,"size_tokens":null},"constants/theme.ts":{"content":"import { Platform } from \"react-native\";\n\nconst primaryColor = \"#2563EB\";\nconst secondaryColor = \"#60A5FA\";\n\nexport const Colors = {\n  light: {\n    primary: primaryColor,\n    secondary: secondaryColor,\n    success: \"#10B981\",\n    warning: \"#F59E0B\",\n    danger: \"#EF4444\",\n    text: \"#0F172A\",\n    textSecondary: \"#64748B\",\n    buttonText: \"#FFFFFF\",\n    tabIconDefault: \"#64748B\",\n    tabIconSelected: primaryColor,\n    link: primaryColor,\n    background: \"#F8FAFC\",\n    surface: \"#FFFFFF\",\n    border: \"#E2E8F0\",\n    backgroundRoot: \"#F8FAFC\",\n    backgroundDefault: \"#FFFFFF\",\n    backgroundSecondary: \"#F1F5F9\",\n    backgroundTertiary: \"#E2E8F0\",\n  },\n  dark: {\n    primary: \"#3B82F6\",\n    secondary: secondaryColor,\n    success: \"#10B981\",\n    warning: \"#F59E0B\",\n    danger: \"#EF4444\",\n    text: \"#F1F5F9\",\n    textSecondary: \"#94A3B8\",\n    buttonText: \"#FFFFFF\",\n    tabIconDefault: \"#94A3B8\",\n    tabIconSelected: \"#3B82F6\",\n    link: \"#3B82F6\",\n    background: \"#0F172A\",\n    surface: \"#1E293B\",\n    border: \"#334155\",\n    backgroundRoot: \"#0F172A\",\n    backgroundDefault: \"#1E293B\",\n    backgroundSecondary: \"#334155\",\n    backgroundTertiary: \"#475569\",\n  },\n};\n\nexport const Spacing = {\n  xs: 4,\n  sm: 8,\n  md: 12,\n  lg: 16,\n  xl: 24,\n  \"2xl\": 32,\n  inputHeight: 48,\n  buttonHeight: 48,\n  avatarSmall: 32,\n  avatarMedium: 48,\n  avatarLarge: 80,\n  avatarXLarge: 120,\n  fabSize: 56,\n};\n\nexport const BorderRadius = {\n  xs: 8,\n  sm: 12,\n  md: 18,\n  lg: 24,\n  xl: 30,\n  \"2xl\": 40,\n  \"3xl\": 50,\n  full: 9999,\n};\n\nexport const Typography = {\n  hero: {\n    fontSize: 32,\n    fontWeight: \"700\" as const,\n  },\n  h1: {\n    fontSize: 24,\n    fontWeight: \"700\" as const,\n  },\n  h2: {\n    fontSize: 18,\n    fontWeight: \"600\" as const,\n  },\n  body: {\n    fontSize: 16,\n    fontWeight: \"400\" as const,\n  },\n  caption: {\n    fontSize: 14,\n    fontWeight: \"400\" as const,\n  },\n  small: {\n    fontSize: 12,\n    fontWeight: \"400\" as const,\n  },\n  link: {\n    fontSize: 16,\n    fontWeight: \"400\" as const,\n  },\n};\n\nexport const Fonts = Platform.select({\n  ios: {\n    /** iOS `UIFontDescriptorSystemDesignDefault` */\n    sans: \"system-ui\",\n    /** iOS `UIFontDescriptorSystemDesignSerif` */\n    serif: \"ui-serif\",\n    /** iOS `UIFontDescriptorSystemDesignRounded` */\n    rounded: \"ui-rounded\",\n    /** iOS `UIFontDescriptorSystemDesignMonospaced` */\n    mono: \"ui-monospace\",\n  },\n  default: {\n    sans: \"normal\",\n    serif: \"serif\",\n    rounded: \"normal\",\n    mono: \"monospace\",\n  },\n  web: {\n    sans: \"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif\",\n    serif: \"Georgia, 'Times New Roman', serif\",\n    rounded:\n      \"'SF Pro Rounded', 'Hiragino Maru Gothic ProN', Meiryo, 'MS PGothic', sans-serif\",\n    mono: \"SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace\",\n  },\n});\n","path":null,"size_bytes":2849,"size_tokens":null},"navigation/HomeStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport RootStackNavigator from \"./RootStackNavigator\";\n\nconst Stack = createNativeStackNavigator();\n\nexport default function HomeStackNavigator() {\n  return <RootStackNavigator />;\n}\n","path":null,"size_bytes":287,"size_tokens":null},"navigation/ProfileStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport ProfileSettingsScreen from \"@/screens/ProfileSettingsScreen\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { getCommonScreenOptions } from \"@/navigation/screenOptions\";\n\nexport type ProfileStackParamList = {\n  ProfileSettings: undefined;\n};\n\nconst Stack = createNativeStackNavigator<ProfileStackParamList>();\n\nexport default function ProfileStackNavigator() {\n  const { theme, isDark } = useTheme();\n\n  return (\n    <Stack.Navigator screenOptions={getCommonScreenOptions({ theme, isDark })}>\n      <Stack.Screen\n        name=\"ProfileSettings\"\n        component={ProfileSettingsScreen}\n        options={{ headerShown: false }}\n      />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":783,"size_tokens":null},"design_guidelines.md":{"content":"# Professional Split Payment App - Design Guidelines\n\n## Authentication Architecture\n\n**Auth Required**: Yes - Multi-user financial app with secure backend sync\n\n**Implementation**:\n- Email/password signup with professional multi-step wizard\n- Collect: first name, last name, email, password (with strength requirements), phone number (SMS verification), date of birth, profile picture\n- Generate secure 6-digit numeric user PIN for friend connections\n- Prominent privacy policy and terms of service links\n- Mock bank connection flow (Plaid-style) for prototype\n- Two-factor authentication option in settings\n- Account settings include logout and delete account with security confirmations\n\n## Navigation Structure\n\n**Root Navigation**: Tab Bar (4 tabs with floating action button)\n\n**Tabs**:\n1. Home - Payment activity dashboard\n2. Friends - Connection management\n3. [FAB] - New Split (positioned center above tab bar)\n4. Wallet - Balance and transfers\n5. Profile - Account and settings\n\n## Screen Specifications\n\n### Onboarding Wizard\n**Layout**: Professional multi-step form\n- Clean header with \"Create Account\" title and step indicator (1/6)\n- Each step in a white card with subtle shadow\n- Blue progress bar at top\n- Primary action button below card\n- Back button in header for steps 2+\n\n**Steps**: Name → Email → Password → Phone (with SMS code) → Date of Birth → Profile Picture\n\n**Completion**: Display user PIN prominently with \"Share this PIN to connect with friends\" explanation\n\n### Home Screen\n**Layout**:\n- Default navigation header with \"Activity\" title\n- Notification bell icon (header-right) with red badge\n- Search bar below header\n- Segmented control: Active | Completed\n- ScrollView with professional payment cards\n\n**Payment Card**:\n- White background, 16px border radius, subtle shadow\n- Event name (18pt semibold)\n- Initiator avatar (40px) with name\n- Amount display (bold, primary blue)\n- Progress indicator (if active)\n- Participant count badge\n- Timestamp (12pt, gray)\n- Tap reveals detail screen\n\n**Safe Area Insets**: Top: headerHeight + Spacing.xl, Bottom: tabBarHeight + Spacing.xl\n\n### Event Detail Screen\n**Layout**:\n- Standard header with event name\n- Summary card: Total amount, your share, initiator badge\n- Receipt image preview (if applicable) - tap to enlarge modal\n- Participant list with status badges\n- Fixed \"Request Payment\" button (if initiator) at bottom\n\n**Status Badges**: Paid (green), Pending (blue), Declined (red) - all with rounded corners and clear typography\n\n**Safe Area Insets**: Top: Spacing.xl, Bottom: tabBarHeight + Spacing.xl\n\n### Friends Screen\n**Layout**:\n- Header with \"Friends\" title and \"Add\" button (header-right)\n- Search bar (search by name or PIN)\n- List of friend cards with avatars, names, PINs\n- Empty state: Professional illustration with \"Connect friends using their 6-digit PIN\"\n\n**Safe Area Insets**: Top: Spacing.xl, Bottom: tabBarHeight + Spacing.xl\n\n### Create Split Flow\n**Select Friends**: Multi-select list with checkboxes, search, selected count, Continue in header\n\n**Split Type**: Two professional option cards with icons:\n- Equal Split: \"Divide evenly among participants\"\n- Custom: \"Specify individual amounts\"\n\n**Equal Split Form**: Event name, total amount (large currency input), auto-calculated per-person display, Create button below\n\n**Custom Split Form**: Event name, receipt upload option, amount inputs per participant, Create button below\n\n**Safe Area Insets**: Top: Spacing.xl, Bottom: insets.bottom + Spacing.xl\n\n### Wallet Screen\n**Layout**:\n- Transparent header with \"Wallet\" title\n- Large balance card (prominent typography, primary blue)\n- Two action buttons: Withdraw | Add Funds\n- Transaction history list below (icons, descriptions, amounts with +/-)\n\n**Withdrawal Flow**: Modal with bank selection, amount input, processing time display, security confirmation\n\n**Safe Area Insets**: Top: headerHeight + Spacing.xl, Bottom: tabBarHeight + Spacing.xl\n\n### Profile Screen\n**Layout**:\n- Profile header: Large avatar (120px), name, PIN with copy button, verification badge\n- Settings sections: Account, Security, Privacy, Support\n- Logout button at bottom (red, destructive style)\n\n**Safe Area Insets**: Top: Spacing.xl, Bottom: tabBarHeight + Spacing.xl\n\n## Design System\n\n### Color Palette (Professional & Trustworthy)\n- **Primary**: #2563EB (Trust Blue)\n- **Primary Dark**: #1E40AF (Dark Blue)\n- **Success**: #10B981 (Green)\n- **Warning**: #F59E0B (Orange)\n- **Danger**: #EF4444 (Red)\n- **Background**: #F8FAFC (Light Blue-Gray)\n- **Surface**: #FFFFFF\n- **Text Primary**: #0F172A (Dark Slate)\n- **Text Secondary**: #64748B (Medium Slate)\n- **Border**: #E2E8F0\n\n### Typography\n- **Headers**: SF Pro Display Semibold (iOS), Roboto Medium (Android)\n- **Body**: SF Pro Text Regular (iOS), Roboto Regular (Android)\n- **Amounts**: SF Pro Display Bold (iOS), Roboto Bold (Android)\n- **Sizes**: Hero 36pt, H1 24pt, H2 18pt, Body 16pt, Caption 14pt, Small 12pt\n\n### Component Specifications\n\n**Buttons**:\n- Primary: Blue background (#2563EB), white text, 10px radius, 52px height\n- Secondary: White background, blue border, blue text\n- Press state: opacity 0.8\n- Disabled: opacity 0.5\n\n**Cards**:\n- White background, 16px border radius, padding 20px\n- Shadow: shadowOffset {width: 0, height: 2}, shadowOpacity: 0.08, shadowRadius: 8\n\n**Floating Action Button**:\n- 60px diameter, primary blue, white plus icon\n- Positioned above tab bar center\n- Shadow: shadowOffset {width: 0, height: 2}, shadowOpacity: 0.10, shadowRadius: 2\n\n**Input Fields**:\n- 52px height, 10px border radius, 1px border (#E2E8F0)\n- Focus: 2px blue border\n- Currency inputs: Large semibold font, right-aligned\n\n**Avatars**: Small 32px, Medium 48px, Large 72px, Profile 120px - all circular with subtle border\n\n### Required Assets\n**Default Avatars** (8 variants): Professional geometric patterns in blue gradient, abstract shapes, minimalist finance icons (dollar sign variations, bank symbols) - all conveying trust and professionalism\n\n**Empty State Illustrations**: Professional line art for no friends, no transactions, no splits - blue color scheme, simple and clean\n\n### Interaction Design\n- All touches: 0.8 opacity feedback\n- Pull-to-refresh on Home and Wallet\n- Haptic feedback on payment confirmations\n- Smooth slide-in modals for sensitive actions\n- Loading states with skeleton screens\n- Success checkmark animations\n- Secure action confirmations with face/fingerprint biometrics where applicable\n\n### Accessibility\n- 44x44px minimum touch targets\n- 4.5:1 color contrast minimum\n- Dynamic type support\n- Complete VoiceOver labels\n- Security announcements for sensitive actions\n- Error states with clear messaging","path":null,"size_bytes":6700,"size_tokens":null},"hooks/useColorScheme.web.ts":{"content":"import { useEffect, useState } from \"react\";\nimport { useColorScheme as useRNColorScheme } from \"react-native\";\n\n/**\n * To support static rendering, this value needs to be re-calculated on the client side for web\n */\nexport function useColorScheme() {\n  const [hasHydrated, setHasHydrated] = useState(false);\n\n  useEffect(() => {\n    setHasHydrated(true);\n  }, []);\n\n  const colorScheme = useRNColorScheme();\n\n  if (hasHydrated) {\n    return colorScheme;\n  }\n\n  return \"light\";\n}\n","path":null,"size_bytes":480,"size_tokens":null},"components/ErrorFallback.tsx":{"content":"import React, { useState } from \"react\";\nimport { reloadAppAsync } from \"expo\";\nimport {\n  StyleSheet,\n  View,\n  Pressable,\n  ScrollView,\n  Text,\n  Modal,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\n\nexport type ErrorFallbackProps = {\n  error: Error;\n  resetError: () => void;\n};\n\nexport function ErrorFallback({ error, resetError }: ErrorFallbackProps) {\n  const { theme } = useTheme();\n  const [isModalVisible, setIsModalVisible] = useState(false);\n\n  const handleRestart = async () => {\n    try {\n      await reloadAppAsync();\n    } catch (restartError) {\n      console.error(\"Failed to restart app:\", restartError);\n      resetError();\n    }\n  };\n\n  const formatErrorDetails = (): string => {\n    let details = `Error: ${error.message}\\n\\n`;\n    if (error.stack) {\n      details += `Stack Trace:\\n${error.stack}`;\n    }\n    return details;\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      {__DEV__ ? (\n        <Pressable\n          onPress={() => setIsModalVisible(true)}\n          style={({ pressed }) => [\n            styles.topButton,\n            {\n              backgroundColor: theme.backgroundDefault,\n              opacity: pressed ? 0.8 : 1,\n            },\n          ]}\n        >\n          <Feather name=\"alert-circle\" size={20} color={theme.text} />\n        </Pressable>\n      ) : null}\n\n      <View style={styles.content}>\n        <ThemedText type=\"h1\" style={styles.title}>\n          Something went wrong\n        </ThemedText>\n\n        <ThemedText type=\"body\" style={styles.message}>\n          Please reload the app to continue.\n        </ThemedText>\n\n        <Pressable\n          onPress={handleRestart}\n          style={({ pressed }) => [\n            styles.button,\n            {\n              backgroundColor: theme.link,\n              opacity: pressed ? 0.9 : 1,\n              transform: [{ scale: pressed ? 0.98 : 1 }],\n            },\n          ]}\n        >\n          <ThemedText\n            type=\"body\"\n            style={[styles.buttonText, { color: theme.buttonText }]}\n          >\n            Try Again\n          </ThemedText>\n        </Pressable>\n      </View>\n\n      {__DEV__ ? (\n        <Modal\n          visible={isModalVisible}\n          animationType=\"slide\"\n          transparent={true}\n          onRequestClose={() => setIsModalVisible(false)}\n        >\n          <View style={styles.modalOverlay}>\n            <ThemedView style={styles.modalContainer}>\n              <View style={styles.modalHeader}>\n                <ThemedText type=\"h2\" style={styles.modalTitle}>\n                  Error Details\n                </ThemedText>\n                <Pressable\n                  onPress={() => setIsModalVisible(false)}\n                  style={({ pressed }) => [\n                    styles.closeButton,\n                    { opacity: pressed ? 0.6 : 1 },\n                  ]}\n                >\n                  <Feather name=\"x\" size={24} color={theme.text} />\n                </Pressable>\n              </View>\n\n              <ScrollView\n                style={styles.modalScrollView}\n                contentContainerStyle={styles.modalScrollContent}\n                showsVerticalScrollIndicator\n              >\n                <View\n                  style={[\n                    styles.errorContainer,\n                    { backgroundColor: theme.backgroundDefault },\n                  ]}\n                >\n                  <Text\n                    style={[\n                      styles.errorText,\n                      {\n                        color: theme.text,\n                        fontFamily: Fonts?.mono || \"monospace\",\n                      },\n                    ]}\n                    selectable\n                  >\n                    {formatErrorDetails()}\n                  </Text>\n                </View>\n              </ScrollView>\n            </ThemedView>\n          </View>\n        </Modal>\n      ) : null}\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    width: \"100%\",\n    height: \"100%\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    padding: Spacing[\"2xl\"],\n  },\n  content: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: Spacing.lg,\n    width: \"100%\",\n    maxWidth: 600,\n  },\n  title: {\n    textAlign: \"center\",\n    lineHeight: 40,\n  },\n  message: {\n    textAlign: \"center\",\n    opacity: 0.7,\n    lineHeight: 24,\n  },\n  topButton: {\n    position: \"absolute\",\n    top: Spacing[\"2xl\"] + Spacing.lg,\n    right: Spacing.lg,\n    width: 44,\n    height: 44,\n    borderRadius: BorderRadius.md,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    zIndex: 10,\n  },\n  button: {\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    paddingHorizontal: Spacing[\"2xl\"],\n    minWidth: 200,\n    shadowColor: \"#000\",\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3,\n  },\n  buttonText: {\n    fontWeight: \"600\",\n    textAlign: \"center\",\n    fontSize: 16,\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    justifyContent: \"flex-end\",\n  },\n  modalContainer: {\n    width: \"100%\",\n    height: \"90%\",\n    borderTopLeftRadius: BorderRadius.lg,\n    borderTopRightRadius: BorderRadius.lg,\n  },\n  modalHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingTop: Spacing.lg,\n    paddingBottom: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: \"rgba(128, 128, 128, 0.2)\",\n  },\n  modalTitle: {\n    fontWeight: \"600\",\n  },\n  closeButton: {\n    padding: Spacing.xs,\n  },\n  modalScrollView: {\n    flex: 1,\n  },\n  modalScrollContent: {\n    padding: Spacing.lg,\n  },\n  errorContainer: {\n    width: \"100%\",\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n    padding: Spacing.lg,\n  },\n  errorText: {\n    fontSize: 12,\n    lineHeight: 18,\n    width: \"100%\",\n  },\n});\n","path":null,"size_bytes":6194,"size_tokens":null},"components/FloatingActionButton.tsx":{"content":"import React from 'react';\nimport { Pressable, StyleSheet, Platform } from 'react-native';\nimport { Feather } from '@expo/vector-icons';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Spacing } from '@/constants/theme';\nimport { useSafeBottomTabBarHeight } from '@/hooks/useSafeBottomTabBarHeight';\n\ninterface FloatingActionButtonProps {\n  navigation: any;\n}\n\nexport function FloatingActionButton({ navigation }: FloatingActionButtonProps) {\n  const { theme } = useTheme();\n  const tabBarHeight = useSafeBottomTabBarHeight();\n\n  const handlePress = () => {\n    navigation.navigate('CreateSplitSelectFriends');\n  };\n\n  return (\n    <Pressable\n      style={({ pressed }) => [\n        styles.fab,\n        { \n          backgroundColor: theme.primary,\n          bottom: tabBarHeight + Spacing.xl,\n          opacity: pressed ? 0.9 : 1,\n          transform: [{ scale: pressed ? 0.95 : 1 }],\n        }\n      ]}\n      onPress={handlePress}\n    >\n      <Feather name=\"plus\" size={28} color=\"#FFFFFF\" />\n    </Pressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  fab: {\n    position: 'absolute',\n    right: Spacing.xl,\n    width: Spacing.fabSize,\n    height: Spacing.fabSize,\n    borderRadius: Spacing.fabSize / 2,\n    justifyContent: 'center',\n    alignItems: 'center',\n    ...Platform.select({\n      ios: {\n        shadowColor: '#000',\n        shadowOffset: { width: 0, height: 4 },\n        shadowOpacity: 0.3,\n        shadowRadius: 8,\n      },\n      android: {\n        elevation: 8,\n      },\n    }),\n  },\n});\n","path":null,"size_bytes":1511,"size_tokens":null},"components/Spacer.tsx":{"content":"import { View } from \"react-native\";\n\ntype Props = {\n  width?: number;\n  height?: number;\n};\n\nexport default function Spacer(props: Props) {\n  const width: number = props.width ?? 1;\n  const height: number = props.height ?? 1;\n\n  return (\n    <View\n      style={{\n        width,\n        height,\n      }}\n    />\n  );\n}\n","path":null,"size_bytes":318,"size_tokens":null},"utils/storage.ts":{"content":"import AsyncStorage from '@react-native-async-storage/async-storage';\n\nconst KEYS = {\n  USER: '@split_user',\n  FRIENDS: '@split_friends',\n  EVENTS: '@split_events',\n  WALLET: '@split_wallet',\n  NOTIFICATIONS: '@split_notifications',\n};\n\nexport interface User {\n  id: string;\n  uniqueId: string;\n  firstName: string;\n  lastName: string;\n  email: string;\n  password: string;\n  phone: string;\n  dateOfBirth: string;\n  profilePicture?: string;\n  bio: string;\n}\n\nexport interface Friend {\n  uniqueId: string;\n  firstName: string;\n  lastName: string;\n  profilePicture?: string;\n}\n\nexport interface Participant {\n  uniqueId: string;\n  firstName: string;\n  lastName: string;\n  profilePicture?: string;\n  status: 'pending' | 'paid' | 'declined';\n  amount: number;\n}\n\nexport interface SplitEvent {\n  id: string;\n  name: string;\n  initiatorId: string;\n  initiatorName: string;\n  initiatorPicture?: string;\n  totalAmount: number;\n  myShare: number;\n  splitType: 'equal' | 'specified';\n  receiptImage?: string;\n  participants: Participant[];\n  createdAt: string;\n  status: 'in_progress' | 'completed';\n}\n\nexport interface WalletTransaction {\n  id: string;\n  type: 'deposit' | 'withdrawal' | 'transfer_in' | 'transfer_out' | 'payment';\n  amount: number;\n  description: string;\n  date: string;\n  eventId?: string;\n}\n\nexport interface Wallet {\n  balance: number;\n  transactions: WalletTransaction[];\n  bankConnected: boolean;\n}\n\nexport interface Notification {\n  id: string;\n  eventId: string;\n  eventName: string;\n  initiatorName: string;\n  amount: number;\n  type: 'split_invite';\n  timestamp: string;\n}\n\nexport const storageService = {\n  async saveUser(user: User): Promise<void> {\n    await AsyncStorage.setItem(KEYS.USER, JSON.stringify(user));\n  },\n\n  async getUser(): Promise<User | null> {\n    const data = await AsyncStorage.getItem(KEYS.USER);\n    return data ? JSON.parse(data) : null;\n  },\n\n  async clearUser(): Promise<void> {\n    await AsyncStorage.removeItem(KEYS.USER);\n  },\n\n  async updateUser(userId: string, updates: Partial<User>): Promise<void> {\n    const user = await this.getUser();\n    if (user && user.id === userId) {\n      const updatedUser = { ...user, ...updates };\n      await this.saveUser(updatedUser);\n    }\n  },\n\n  async saveFriends(friends: Friend[]): Promise<void> {\n    await AsyncStorage.setItem(KEYS.FRIENDS, JSON.stringify(friends));\n  },\n\n  async getFriends(): Promise<Friend[]> {\n    const data = await AsyncStorage.getItem(KEYS.FRIENDS);\n    return data ? JSON.parse(data) : [];\n  },\n\n  async addFriend(friend: Friend): Promise<void> {\n    const friends = await this.getFriends();\n    friends.push(friend);\n    await this.saveFriends(friends);\n  },\n\n  async saveEvents(events: SplitEvent[]): Promise<void> {\n    await AsyncStorage.setItem(KEYS.EVENTS, JSON.stringify(events));\n  },\n\n  async getEvents(): Promise<SplitEvent[]> {\n    const data = await AsyncStorage.getItem(KEYS.EVENTS);\n    return data ? JSON.parse(data) : [];\n  },\n\n  async addEvent(event: SplitEvent): Promise<void> {\n    const events = await this.getEvents();\n    events.push(event);\n    await this.saveEvents(events);\n  },\n\n  async updateEvent(eventId: string, updates: Partial<SplitEvent>): Promise<void> {\n    const events = await this.getEvents();\n    const index = events.findIndex(e => e.id === eventId);\n    if (index !== -1) {\n      events[index] = { ...events[index], ...updates };\n      await this.saveEvents(events);\n    }\n  },\n\n  async saveWallet(wallet: Wallet): Promise<void> {\n    await AsyncStorage.setItem(KEYS.WALLET, JSON.stringify(wallet));\n  },\n\n  async getWallet(): Promise<Wallet> {\n    const data = await AsyncStorage.getItem(KEYS.WALLET);\n    return data ? JSON.parse(data) : { balance: 0, transactions: [], bankConnected: false };\n  },\n\n  async addTransaction(transaction: WalletTransaction): Promise<void> {\n    const wallet = await this.getWallet();\n    wallet.transactions.unshift(transaction);\n    \n    if (transaction.type === 'deposit' || transaction.type === 'transfer_in' || transaction.type === 'payment') {\n      wallet.balance += transaction.amount;\n    } else {\n      wallet.balance -= transaction.amount;\n    }\n    \n    await this.saveWallet(wallet);\n  },\n\n  async saveNotifications(notifications: Notification[]): Promise<void> {\n    await AsyncStorage.setItem(KEYS.NOTIFICATIONS, JSON.stringify(notifications));\n  },\n\n  async getNotifications(): Promise<Notification[]> {\n    const data = await AsyncStorage.getItem(KEYS.NOTIFICATIONS);\n    return data ? JSON.parse(data) : [];\n  },\n\n  async addNotification(notification: Notification): Promise<void> {\n    const notifications = await this.getNotifications();\n    notifications.unshift(notification);\n    await this.saveNotifications(notifications);\n  },\n\n  async removeNotification(notificationId: string): Promise<void> {\n    const notifications = await this.getNotifications();\n    const filtered = notifications.filter(n => n.id !== notificationId);\n    await this.saveNotifications(filtered);\n  },\n\n  async clearAll(): Promise<void> {\n    await AsyncStorage.multiRemove([\n      KEYS.USER,\n      KEYS.FRIENDS,\n      KEYS.EVENTS,\n      KEYS.WALLET,\n      KEYS.NOTIFICATIONS,\n    ]);\n  },\n};\n\nexport function generateUniqueId(): string {\n  return Math.floor(10000 + Math.random() * 90000).toString();\n}\n\nexport function generateId(): string {\n  return Date.now().toString() + Math.random().toString(36).substr(2, 9);\n}\n","path":null,"size_bytes":5408,"size_tokens":null},"components/ThemedText.tsx":{"content":"import { Text, type TextProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Typography } from \"@/constants/theme\";\n\nexport type ThemedTextProps = TextProps & {\n  lightColor?: string;\n  darkColor?: string;\n  type?: \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"body\" | \"small\" | \"link\";\n};\n\nexport function ThemedText({\n  style,\n  lightColor,\n  darkColor,\n  type = \"body\",\n  ...rest\n}: ThemedTextProps) {\n  const { theme, isDark } = useTheme();\n\n  const getColor = () => {\n    if (isDark && darkColor) {\n      return darkColor;\n    }\n\n    if (!isDark && lightColor) {\n      return lightColor;\n    }\n\n    if (type === \"link\") {\n      return theme.link;\n    }\n\n    return theme.text;\n  };\n\n  const getTypeStyle = () => {\n    switch (type) {\n      case \"h1\":\n        return Typography.h1;\n      case \"h2\":\n        return Typography.h2;\n      case \"h3\":\n        return Typography.h3;\n      case \"h4\":\n        return Typography.h4;\n      case \"body\":\n        return Typography.body;\n      case \"small\":\n        return Typography.small;\n      case \"link\":\n        return Typography.link;\n      default:\n        return Typography.body;\n    }\n  };\n\n  return (\n    <Text style={[{ color: getColor() }, getTypeStyle(), style]} {...rest} />\n  );\n}\n","path":null,"size_bytes":1251,"size_tokens":null},"screens/SignupPasswordScreen.tsx":{"content":"import React, { useState } from 'react';\nimport { View, TextInput, StyleSheet, Pressable } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\n\ntype Props = NativeStackScreenProps<any, 'SignupPassword'>;\n\nexport default function SignupPasswordScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const [password, setPassword] = useState('');\n  const [showPassword, setShowPassword] = useState(false);\n  const [agreedToTerms, setAgreedToTerms] = useState(false);\n  const params = route.params as { firstName: string; lastName: string; email: string };\n\n  const getPasswordStrength = (pwd: string) => {\n    if (pwd.length < 6) return { text: 'Too short', color: theme.danger };\n    if (pwd.length < 8) return { text: 'Weak', color: theme.warning };\n    if (pwd.length < 12) return { text: 'Good', color: theme.primary };\n    return { text: 'Strong', color: theme.success };\n  };\n\n  const strength = getPasswordStrength(password);\n  const canContinue = password.length >= 6 && agreedToTerms;\n\n  const handleContinue = () => {\n    if (canContinue) {\n      navigation.navigate('SignupPhone', { ...params, password });\n    }\n  };\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Step 4 of 8\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.xl }]}>\n          Create a password\n        </ThemedText>\n\n        <View style={styles.inputContainer}>\n          <TextInput\n            style={[styles.input, { \n              backgroundColor: theme.surface, \n              color: theme.text, \n              borderColor: theme.border \n            }]}\n            placeholder=\"Password (min. 6 characters)\"\n            placeholderTextColor={theme.textSecondary}\n            value={password}\n            onChangeText={setPassword}\n            secureTextEntry={!showPassword}\n            autoFocus\n            autoCapitalize=\"none\"\n          />\n          <Pressable\n            style={styles.eyeButton}\n            onPress={() => setShowPassword(!showPassword)}\n            hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}\n          >\n            <Feather \n              name={showPassword ? 'eye-off' : 'eye'} \n              size={22} \n              color={theme.textSecondary} \n            />\n          </Pressable>\n        </View>\n\n        {password.length > 0 ? (\n          <ThemedText style={[Typography.caption, { color: strength.color, marginTop: Spacing.sm }]}>\n            {strength.text}\n          </ThemedText>\n        ) : null}\n\n        <Pressable\n          style={styles.termsContainer}\n          onPress={() => setAgreedToTerms(!agreedToTerms)}\n        >\n          <View style={[\n            styles.checkbox,\n            { \n              borderColor: agreedToTerms ? theme.primary : theme.border,\n              backgroundColor: agreedToTerms ? theme.primary : 'transparent',\n            }\n          ]}>\n            {agreedToTerms ? (\n              <Feather name=\"check\" size={14} color={Colors.light.buttonText} />\n            ) : null}\n          </View>\n          <View style={styles.termsTextContainer}>\n            <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n              I agree to the{' '}\n            </ThemedText>\n            <Pressable onPress={() => navigation.navigate('Terms')}>\n              <ThemedText style={[Typography.caption, { color: theme.primary }]}>\n                Terms and Conditions\n              </ThemedText>\n            </Pressable>\n            <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n              {' '}and{' '}\n            </ThemedText>\n            <Pressable onPress={() => navigation.navigate('PrivacyPolicy')}>\n              <ThemedText style={[Typography.caption, { color: theme.primary }]}>\n                Privacy Policy\n              </ThemedText>\n            </Pressable>\n          </View>\n        </Pressable>\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed ? 0.7 : (!canContinue ? 0.4 : 1)\n            }\n          ]}\n          onPress={handleContinue}\n          disabled={!canContinue}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            Continue\n          </ThemedText>\n        </Pressable>\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  inputContainer: {\n    position: 'relative',\n  },\n  input: {\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    paddingRight: 50,\n    fontSize: 16,\n  },\n  eyeButton: {\n    position: 'absolute',\n    right: Spacing.md,\n    top: 0,\n    bottom: 0,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  termsContainer: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    marginTop: Spacing.xl,\n    paddingRight: Spacing.lg,\n  },\n  checkbox: {\n    width: 22,\n    height: 22,\n    borderWidth: 2,\n    borderRadius: 4,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginRight: Spacing.sm,\n    marginTop: 1,\n  },\n  termsTextContainer: {\n    flex: 1,\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":6313,"size_tokens":null},"screens/WithdrawalScreen.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, Alert, ActivityIndicator, Modal, ScrollView, KeyboardAvoidingView, Platform } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { WalletService, NZ_BANKS } from '@/services/wallet.service';\nimport { Wallet } from '@/shared/types';\n\ntype Props = NativeStackScreenProps<any, 'Withdrawal'>;\n\nexport default function WithdrawalScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n  const { user } = useAuth();\n  const [amount, setAmount] = useState('');\n  const [selectedMethod, setSelectedMethod] = useState<'fast' | 'normal' | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [loadingWallet, setLoadingWallet] = useState(true);\n  const [wallet, setWallet] = useState<Wallet | null>(null);\n  \n  const [showBankModal, setShowBankModal] = useState(false);\n  const [bankName, setBankName] = useState('');\n  const [accountNumber, setAccountNumber] = useState('');\n  const [accountHolderName, setAccountHolderName] = useState('');\n  const [savingBank, setSavingBank] = useState(false);\n  const [showBankPicker, setShowBankPicker] = useState(false);\n  const [monthlyLimits, setMonthlyLimits] = useState<{ fast: number; normal: number }>({ fast: 0, normal: 0 });\n\n  const MAX_WITHDRAWALS_PER_MONTH = 4;\n\n  useEffect(() => {\n    loadWallet();\n    loadMonthlyLimits();\n  }, [user]);\n\n  const loadWallet = async () => {\n    if (!user) {\n      setLoadingWallet(false);\n      return;\n    }\n    try {\n      const walletData = await WalletService.getWallet(user.id);\n      setWallet(walletData);\n      \n      if (walletData.bank_details) {\n        setBankName(walletData.bank_details.bank_name || '');\n        setAccountHolderName(walletData.bank_details.account_holder_name || '');\n        setAccountNumber(walletData.bank_details.account_number || '');\n      }\n    } catch (error) {\n      console.error('Failed to load wallet:', error);\n    } finally {\n      setLoadingWallet(false);\n    }\n  };\n\n  const loadMonthlyLimits = async () => {\n    if (!user) return;\n    try {\n      const limits = await WalletService.getMonthlyWithdrawalCounts(user.id);\n      setMonthlyLimits(limits);\n    } catch (error) {\n      console.error('Failed to load monthly limits:', error);\n    }\n  };\n\n  const calculateFee = () => {\n    const withdrawAmount = parseFloat(amount) || 0;\n    if (selectedMethod === 'fast') {\n      return withdrawAmount * 0.035;\n    }\n    return 0;\n  };\n\n  const calculateTotal = () => {\n    const withdrawAmount = parseFloat(amount) || 0;\n    return withdrawAmount;\n  };\n\n  const calculateReceived = () => {\n    const withdrawAmount = parseFloat(amount) || 0;\n    if (selectedMethod === 'fast') {\n      return withdrawAmount - calculateFee();\n    }\n    return withdrawAmount;\n  };\n\n  const getMaxWithdrawable = () => {\n    if (!wallet) return 0;\n    return wallet.balance;\n  };\n\n  const handleSaveBankDetails = async () => {\n    if (!user) return;\n    \n    if (!bankName.trim()) {\n      Alert.alert('Missing Info', 'Please select your bank');\n      return;\n    }\n    \n    if (!accountNumber.trim()) {\n      Alert.alert('Missing Info', 'Please enter your account number');\n      return;\n    }\n    \n    if (!accountHolderName.trim()) {\n      Alert.alert('Missing Info', 'Please enter the account holder name');\n      return;\n    }\n    \n    setSavingBank(true);\n    try {\n      const updatedWallet = await WalletService.connectBankAccount(\n        user.id,\n        bankName,\n        accountNumber,\n        accountHolderName\n      );\n      setWallet(updatedWallet);\n      setShowBankModal(false);\n      Alert.alert('Success', 'Bank account saved successfully');\n    } catch (error: any) {\n      Alert.alert('Error', error.message || 'Failed to save bank details');\n    } finally {\n      setSavingBank(false);\n    }\n  };\n\n  const handleWithdraw = async () => {\n    if (!user) return;\n    \n    const withdrawAmount = parseFloat(amount);\n\n    if (isNaN(withdrawAmount) || withdrawAmount <= 0) {\n      Alert.alert('Invalid Amount', 'Please enter a valid amount');\n      return;\n    }\n\n    if (!selectedMethod) {\n      Alert.alert('Select Method', 'Please select a withdrawal method');\n      return;\n    }\n\n    if (!wallet?.bank_connected) {\n      setShowBankModal(true);\n      return;\n    }\n\n    const totalDeduction = calculateTotal();\n    if (totalDeduction > wallet.balance) {\n      const maxAmount = getMaxWithdrawable();\n      Alert.alert('Insufficient Funds', `You can withdraw up to $${maxAmount.toFixed(2)}`);\n      return;\n    }\n\n    const fee = calculateFee();\n    const received = calculateReceived();\n    const arrivalText = selectedMethod === 'fast' ? 'within a few hours' : 'in 3-5 business days';\n\n    Alert.alert(\n      'Confirm Withdrawal',\n      `Withdrawing $${withdrawAmount.toFixed(2)} from wallet${fee > 0 ? `\\n\\nFast transfer fee: $${fee.toFixed(2)}\\nYou will receive: $${received.toFixed(2)}` : ''}\\n\\nFunds will arrive ${arrivalText}.`,\n      [\n        { text: 'Cancel', style: 'cancel' },\n        {\n          text: 'Confirm',\n          onPress: async () => {\n            setLoading(true);\n            try {\n              await WalletService.withdrawWithType(user.id, withdrawAmount, selectedMethod);\n              \n              Alert.alert(\n                'Withdrawal Initiated',\n                `$${received.toFixed(2)} will arrive in your bank ${arrivalText}`,\n                [{ text: 'OK', onPress: () => navigation.goBack() }]\n              );\n            } catch (error: any) {\n              console.error('Withdrawal error:', error);\n              Alert.alert('Withdrawal Failed', error.message || 'Unable to process withdrawal. Please try again.');\n            } finally {\n              setLoading(false);\n            }\n          }\n        }\n      ]\n    );\n  };\n\n  const formatAccountNumber = (text: string) => {\n    const cleaned = text.replace(/[^0-9-]/g, '');\n    return cleaned;\n  };\n\n  if (loadingWallet) {\n    return (\n      <ThemedView style={[styles.container, { justifyContent: 'center', alignItems: 'center' }]}>\n        <ActivityIndicator size=\"large\" color={theme.primary} />\n      </ThemedView>\n    );\n  }\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.h1, { color: theme.text, marginBottom: Spacing.md }]}>\n          Withdraw Funds\n        </ThemedText>\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing.xl }]}>\n          Available balance: ${wallet?.balance.toFixed(2) || '0.00'}\n        </ThemedText>\n\n        <View style={styles.inputWrapper}>\n          <ThemedText style={[Typography.h2, { color: theme.text, marginRight: Spacing.xs }]}>$</ThemedText>\n          <TextInput\n            style={[styles.input, { \n              backgroundColor: theme.surface, \n              color: theme.text, \n              borderColor: theme.border \n            }]}\n            placeholder=\"0.00\"\n            placeholderTextColor={theme.textSecondary}\n            value={amount}\n            onChangeText={setAmount}\n            keyboardType=\"decimal-pad\"\n            autoFocus\n          />\n        </View>\n\n        <ThemedText style={[Typography.h2, { color: theme.text, marginTop: Spacing.xl, marginBottom: Spacing.md }]}>\n          Transfer Speed\n        </ThemedText>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.methodCard,\n            { \n              backgroundColor: theme.surface,\n              borderColor: selectedMethod === 'fast' ? theme.warning : theme.border,\n              borderWidth: selectedMethod === 'fast' ? 2 : 1,\n              opacity: pressed || monthlyLimits.fast >= MAX_WITHDRAWALS_PER_MONTH ? 0.5 : 1\n            }\n          ]}\n          onPress={() => setSelectedMethod('fast')}\n          disabled={monthlyLimits.fast >= MAX_WITHDRAWALS_PER_MONTH}\n        >\n          <View style={styles.methodHeader}>\n            <View style={[styles.iconContainer, { backgroundColor: theme.warning + '20' }]}>\n              <Feather name=\"zap\" size={24} color={theme.warning} />\n            </View>\n            <View style={styles.methodInfo}>\n              <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n                Fast Transfer\n              </ThemedText>\n              <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                Arrives in minutes to hours\n              </ThemedText>\n              {monthlyLimits.fast >= MAX_WITHDRAWALS_PER_MONTH ? (\n                <ThemedText style={[Typography.small, { color: theme.danger }]}>\n                  Monthly limit reached ({MAX_WITHDRAWALS_PER_MONTH}/{MAX_WITHDRAWALS_PER_MONTH})\n                </ThemedText>\n              ) : null}\n            </View>\n          </View>\n          <View style={styles.feeContainer}>\n            <ThemedText style={[Typography.body, { color: theme.warning, fontWeight: '600' }]}>\n              3.5% fee\n            </ThemedText>\n            {selectedMethod === 'fast' && parseFloat(amount) > 0 ? (\n              <ThemedText style={[Typography.small, { color: theme.textSecondary }]}>\n                ${calculateFee().toFixed(2)}\n              </ThemedText>\n            ) : null}\n          </View>\n        </Pressable>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.methodCard,\n            { \n              backgroundColor: theme.surface,\n              borderColor: selectedMethod === 'normal' ? theme.success : theme.border,\n              borderWidth: selectedMethod === 'normal' ? 2 : 1,\n              opacity: pressed || monthlyLimits.normal >= MAX_WITHDRAWALS_PER_MONTH ? 0.5 : 1\n            }\n          ]}\n          onPress={() => setSelectedMethod('normal')}\n          disabled={monthlyLimits.normal >= MAX_WITHDRAWALS_PER_MONTH}\n        >\n          <View style={styles.methodHeader}>\n            <View style={[styles.iconContainer, { backgroundColor: theme.success + '20' }]}>\n              <Feather name=\"clock\" size={24} color={theme.success} />\n            </View>\n            <View style={styles.methodInfo}>\n              <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n                Normal Transfer\n              </ThemedText>\n              <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                Arrives in 3-5 business days\n              </ThemedText>\n              {monthlyLimits.normal >= MAX_WITHDRAWALS_PER_MONTH ? (\n                <ThemedText style={[Typography.small, { color: theme.danger }]}>\n                  Monthly limit reached ({MAX_WITHDRAWALS_PER_MONTH}/{MAX_WITHDRAWALS_PER_MONTH})\n                </ThemedText>\n              ) : null}\n            </View>\n          </View>\n          <ThemedText style={[Typography.body, { color: theme.success, fontWeight: '600' }]}>\n            Free\n          </ThemedText>\n        </Pressable>\n\n        {selectedMethod && parseFloat(amount) > 0 ? (\n          <View style={[styles.summaryCard, { backgroundColor: theme.backgroundSecondary, borderColor: theme.border }]}>\n            <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600', marginBottom: Spacing.sm }]}>\n              Summary\n            </ThemedText>\n            <View style={styles.summaryRow}>\n              <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n                Withdrawal amount\n              </ThemedText>\n              <ThemedText style={[Typography.body, { color: theme.text }]}>\n                ${parseFloat(amount).toFixed(2)}\n              </ThemedText>\n            </View>\n            {selectedMethod === 'fast' ? (\n              <View style={styles.summaryRow}>\n                <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n                  Fast transfer fee (3.5%)\n                </ThemedText>\n                <ThemedText style={[Typography.body, { color: theme.warning }]}>\n                  -${calculateFee().toFixed(2)}\n                </ThemedText>\n              </View>\n            ) : null}\n            <View style={[styles.summaryRow, styles.summaryTotal]}>\n              <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n                You will receive (approx)\n              </ThemedText>\n              <ThemedText style={[Typography.body, { color: theme.success, fontWeight: '600' }]}>\n                ${calculateReceived().toFixed(2)}\n              </ThemedText>\n            </View>\n            <View style={styles.summaryRow}>\n              <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                Estimated arrival\n              </ThemedText>\n              <ThemedText style={[Typography.caption, { color: theme.primary }]}>\n                {selectedMethod === 'fast' ? 'Within hours' : '3-5 business days'}\n              </ThemedText>\n            </View>\n          </View>\n        ) : null}\n\n        {wallet?.bank_connected && wallet?.bank_details?.bank_name && wallet?.bank_details?.account_last4 ? (\n          <Pressable \n            style={[styles.bankDetailsCard, { backgroundColor: theme.success + '10', borderColor: theme.success }]}\n            onPress={() => setShowBankModal(true)}\n          >\n            <View style={{ flexDirection: 'row', alignItems: 'center', flex: 1 }}>\n              <Feather name=\"check-circle\" size={20} color={theme.success} />\n              <View style={{ marginLeft: Spacing.md, flex: 1 }}>\n                <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n                  {wallet.bank_details.bank_name}\n                </ThemedText>\n                <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                  Account ending in {wallet.bank_details.account_last4}\n                </ThemedText>\n              </View>\n            </View>\n            <Feather name=\"edit-2\" size={16} color={theme.textSecondary} />\n          </Pressable>\n        ) : (\n          <Pressable\n            style={[styles.bankWarning, { backgroundColor: theme.warning + '20', borderColor: theme.warning }]}\n            onPress={() => setShowBankModal(true)}\n          >\n            <Feather name=\"alert-circle\" size={20} color={theme.warning} />\n            <View style={{ marginLeft: Spacing.md, flex: 1 }}>\n              <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n                Setup Bank Account\n              </ThemedText>\n              <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                Enter your bank details to receive withdrawals\n              </ThemedText>\n            </View>\n            <Feather name=\"chevron-right\" size={20} color={theme.textSecondary} />\n          </Pressable>\n        )}\n\n        <View style={[styles.infoBox, { backgroundColor: theme.primary + '10', marginTop: Spacing.lg }]}>\n          <Feather name=\"shield\" size={16} color={theme.primary} style={{ marginRight: Spacing.sm }} />\n          <ThemedText style={[Typography.small, { color: theme.textSecondary, flex: 1 }]}>\n            For security, recently deposited funds have a 24-hour hold before withdrawal. Earned funds from split payments can be withdrawn immediately.\n          </ThemedText>\n        </View>\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary,\n              opacity: pressed ? 0.7 : (loading || !selectedMethod || !parseFloat(amount) ? 0.5 : 1)\n            }\n          ]}\n          onPress={handleWithdraw}\n          disabled={loading || !selectedMethod || !parseFloat(amount)}\n        >\n          {loading ? (\n            <ActivityIndicator size=\"small\" color=\"#FFFFFF\" />\n          ) : (\n            <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n              {wallet?.bank_connected && wallet?.bank_details?.bank_name ? 'Withdraw' : 'Setup Bank & Withdraw'}\n            </ThemedText>\n          )}\n        </Pressable>\n      </View>\n\n      <Modal visible={showBankModal} animationType=\"fade\" transparent>\n        <KeyboardAvoidingView \n          style={styles.modalOverlay} \n          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n        >\n          <Pressable style={styles.modalBackdrop} onPress={() => setShowBankModal(false)} />\n          <View style={[styles.modalContent, { backgroundColor: theme.background }]}>\n            <View style={styles.modalHeader}>\n              <ThemedText style={[Typography.h2, { color: theme.text }]}>\n                Bank Account Details\n              </ThemedText>\n              <Pressable onPress={() => setShowBankModal(false)}>\n                <Feather name=\"x\" size={24} color={theme.textSecondary} />\n              </Pressable>\n            </View>\n            \n            <ScrollView style={{ maxHeight: 350 }} keyboardShouldPersistTaps=\"handled\">\n              <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing.lg }]}>\n                Enter your NZ bank account details for receiving withdrawals. Your details are stored securely.\n              </ThemedText>\n\n              <ThemedText style={[Typography.body, { color: theme.text, marginBottom: Spacing.xs, fontWeight: '600' }]}>\n                Bank\n              </ThemedText>\n              <Pressable\n                style={[styles.pickerButton, { backgroundColor: theme.surface, borderColor: theme.border }]}\n                onPress={() => setShowBankPicker(!showBankPicker)}\n              >\n                <ThemedText style={[Typography.body, { color: bankName ? theme.text : theme.textSecondary }]}>\n                  {bankName || 'Select your bank'}\n                </ThemedText>\n                <Feather name=\"chevron-down\" size={20} color={theme.textSecondary} />\n              </Pressable>\n              \n              {showBankPicker ? (\n                <View style={[styles.pickerDropdown, { backgroundColor: theme.surface, borderColor: theme.border }]}>\n                  {NZ_BANKS.map((bank) => (\n                    <Pressable\n                      key={bank.id}\n                      style={({ pressed }) => [\n                        styles.pickerItem,\n                        { \n                          backgroundColor: bankName === bank.name ? theme.primary + '20' : 'transparent',\n                          opacity: pressed ? 0.7 : 1\n                        }\n                      ]}\n                      onPress={() => {\n                        setBankName(bank.name);\n                        setShowBankPicker(false);\n                      }}\n                    >\n                      <ThemedText style={[Typography.body, { color: theme.text }]}>\n                        {bank.name}\n                      </ThemedText>\n                      {bankName === bank.name ? (\n                        <Feather name=\"check\" size={18} color={theme.primary} />\n                      ) : null}\n                    </Pressable>\n                  ))}\n                </View>\n              ) : null}\n\n              <ThemedText style={[Typography.body, { color: theme.text, marginTop: Spacing.lg, marginBottom: Spacing.xs, fontWeight: '600' }]}>\n                Account Number\n              </ThemedText>\n              <TextInput\n                style={[styles.textInput, { backgroundColor: theme.surface, borderColor: theme.border, color: theme.text }]}\n                value={accountNumber}\n                onChangeText={(text) => setAccountNumber(formatAccountNumber(text))}\n                placeholder=\"00-0000-0000000-00\"\n                placeholderTextColor={theme.textSecondary}\n                keyboardType=\"numbers-and-punctuation\"\n              />\n              <ThemedText style={[Typography.small, { color: theme.textSecondary, marginTop: Spacing.xs }]}>\n                NZ bank format: 00-0000-0000000-00\n              </ThemedText>\n\n              <ThemedText style={[Typography.body, { color: theme.text, marginTop: Spacing.lg, marginBottom: Spacing.xs, fontWeight: '600' }]}>\n                Account Holder Name\n              </ThemedText>\n              <TextInput\n                style={[styles.textInput, { backgroundColor: theme.surface, borderColor: theme.border, color: theme.text }]}\n                value={accountHolderName}\n                onChangeText={setAccountHolderName}\n                placeholder=\"Name as shown on account\"\n                placeholderTextColor={theme.textSecondary}\n                autoCapitalize=\"words\"\n              />\n            </ScrollView>\n\n            <View style={styles.modalButtons}>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.modalButton,\n                  { backgroundColor: theme.surface, borderColor: theme.border, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={() => setShowBankModal(false)}\n                disabled={savingBank}\n              >\n                <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n                  Cancel\n                </ThemedText>\n              </Pressable>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.modalButton,\n                  { backgroundColor: theme.primary, opacity: pressed ? 0.7 : (savingBank ? 0.5 : 1) }\n                ]}\n                onPress={handleSaveBankDetails}\n                disabled={savingBank}\n              >\n                {savingBank ? (\n                  <ActivityIndicator size=\"small\" color=\"#FFFFFF\" />\n                ) : (\n                  <ThemedText style={[Typography.body, { color: '#FFFFFF', fontWeight: '600' }]}>\n                    Save Bank Details\n                  </ThemedText>\n                )}\n              </Pressable>\n            </View>\n          </View>\n        </KeyboardAvoidingView>\n      </Modal>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.xl,\n  },\n  inputWrapper: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  input: {\n    flex: 1,\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    fontSize: 24,\n    fontWeight: '600',\n  },\n  methodCard: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    marginBottom: Spacing.md,\n  },\n  methodHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    flex: 1,\n  },\n  iconContainer: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  methodInfo: {\n    marginLeft: Spacing.md,\n    flex: 1,\n  },\n  feeContainer: {\n    alignItems: 'flex-end',\n  },\n  summaryCard: {\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    marginTop: Spacing.lg,\n  },\n  summaryRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: Spacing.xs,\n  },\n  summaryTotal: {\n    marginTop: Spacing.sm,\n    paddingTop: Spacing.sm,\n    borderTopWidth: 1,\n    borderTopColor: 'rgba(0,0,0,0.1)',\n  },\n  bankDetailsCard: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    marginTop: Spacing.xl,\n  },\n  bankWarning: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    marginTop: Spacing.xl,\n  },\n  infoBox: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: 'rgba(0,0,0,0.5)',\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: Spacing.xl,\n  },\n  modalBackdrop: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n  modalContent: {\n    width: '100%',\n    maxWidth: 400,\n    borderRadius: BorderRadius.md,\n    padding: Spacing.xl,\n    paddingBottom: Spacing['2xl'],\n  },\n  modalHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: Spacing.lg,\n  },\n  textInput: {\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    fontSize: 16,\n  },\n  pickerButton: {\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n  },\n  pickerDropdown: {\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    marginTop: Spacing.xs,\n    overflow: 'hidden',\n  },\n  pickerItem: {\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n  },\n  modalButtons: {\n    flexDirection: 'row',\n    gap: Spacing.md,\n    marginTop: Spacing.xl,\n  },\n  modalButton: {\n    flex: 1,\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    borderWidth: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":26207,"size_tokens":null},"screens/SignupCompleteScreen.tsx":{"content":"import React from 'react';\nimport { View, StyleSheet, Pressable, Alert } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport * as Clipboard from 'expo-clipboard';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenScrollView } from '@/components/ScreenScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\n\ntype Props = NativeStackScreenProps<any, 'SignupComplete'>;\n\nexport default function SignupCompleteScreen({ route }: Props) {\n  const { theme } = useTheme();\n  const { uniqueId } = route.params as { uniqueId: string };\n\n  const copyToClipboard = async () => {\n    await Clipboard.setStringAsync(uniqueId);\n    Alert.alert('Copied!', 'Your unique ID has been copied to clipboard');\n  };\n\n  return (\n    <ScreenScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <View style={[styles.iconContainer, { backgroundColor: theme.success }]}>\n          <Feather name=\"check\" size={48} color={Colors.light.buttonText} />\n        </View>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, textAlign: 'center', marginBottom: Spacing.lg }]}>\n          Welcome to Split!\n        </ThemedText>\n\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, textAlign: 'center', marginBottom: Spacing['2xl'] }]}>\n          Your account has been created successfully\n        </ThemedText>\n\n        <View style={[styles.idCard, { backgroundColor: theme.surface, borderColor: theme.border }]}>\n          <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing.sm }]}>\n            Your Unique ID\n          </ThemedText>\n          <ThemedText style={[Typography.hero, { color: theme.primary, marginBottom: Spacing.lg }]}>\n            {uniqueId}\n          </ThemedText>\n\n          <Pressable\n            style={({ pressed }) => [\n              styles.copyButton,\n              { \n                backgroundColor: theme.backgroundSecondary,\n                opacity: pressed ? 0.7 : 1\n              }\n            ]}\n            onPress={copyToClipboard}\n          >\n            <Feather name=\"copy\" size={16} color={theme.primary} />\n            <ThemedText style={[Typography.body, { color: theme.primary, marginLeft: Spacing.sm }]}>\n              Copy ID\n            </ThemedText>\n          </Pressable>\n        </View>\n\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, textAlign: 'center', marginTop: Spacing.xl }]}>\n          Share this ID with friends to connect and split bills together\n        </ThemedText>\n      </ThemedView>\n    </ScreenScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  iconContainer: {\n    width: 80,\n    height: 80,\n    borderRadius: 40,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginBottom: Spacing.xl,\n  },\n  idCard: {\n    width: '100%',\n    padding: Spacing.xl,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    alignItems: 'center',\n  },\n  copyButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.xs,\n  },\n});\n","path":null,"size_bytes":3525,"size_tokens":null},"screens/SignupProfilePictureScreen.tsx":{"content":"import React, { useState } from 'react';\nimport { View, StyleSheet, Pressable, Image, Alert } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport * as ImagePicker from 'expo-image-picker';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenScrollView } from '@/components/ScreenScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\n\ntype Props = NativeStackScreenProps<any, 'SignupProfilePicture'>;\n\nexport default function SignupProfilePictureScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const [profilePicture, setProfilePicture] = useState<string | undefined>();\n  const params = route.params as { firstName: string; lastName: string; email: string; password: string; phone: string; dateOfBirth: string };\n\n  const pickImage = async () => {\n    // Check current permission status first\n    const { status: currentStatus } = await ImagePicker.getMediaLibraryPermissionsAsync();\n    \n    if (currentStatus !== 'granted') {\n      // Show our own clear explanation before the system dialog\n      Alert.alert(\n        'Photo Library Access',\n        'Spline would like to access your photo library to let you choose a profile picture.',\n        [\n          {\n            text: 'Not Now',\n            style: 'cancel',\n          },\n          {\n            text: 'Allow Access',\n            onPress: async () => {\n              const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();\n              if (status === 'granted') {\n                await launchImagePicker();\n              } else {\n                Alert.alert(\n                  'Permission Required',\n                  'To upload a profile picture, please enable photo library access in your device settings.',\n                  [{ text: 'OK' }]\n                );\n              }\n            },\n          },\n        ]\n      );\n    } else {\n      await launchImagePicker();\n    }\n  };\n\n  const launchImagePicker = async () => {\n    const result = await ImagePicker.launchImageLibraryAsync({\n      mediaTypes: ['images'],\n      allowsEditing: true,\n      aspect: [1, 1],\n      quality: 0.8,\n    });\n\n    if (!result.canceled) {\n      setProfilePicture(result.assets[0].uri);\n    }\n  };\n\n  const handleContinue = () => {\n    navigation.navigate('SignupBio', { ...params, profilePicture });\n  };\n\n  return (\n    <ScreenScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Step 7 of 8\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.xl }]}>\n          Add a profile picture\n        </ThemedText>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.avatarContainer,\n            { \n              backgroundColor: theme.backgroundSecondary,\n              borderColor: theme.border,\n              opacity: pressed ? 0.7 : 1\n            }\n          ]}\n          onPress={pickImage}\n        >\n          {profilePicture ? (\n            <Image source={{ uri: profilePicture }} style={styles.avatar} />\n          ) : (\n            <Feather name=\"camera\" size={40} color={theme.textSecondary} />\n          )}\n        </Pressable>\n\n        <Pressable\n          style={({ pressed }) => [styles.linkButton, { opacity: pressed ? 0.7 : 1 }]}\n          onPress={pickImage}\n        >\n          <ThemedText style={[Typography.body, { color: theme.primary }]}>\n            {profilePicture ? 'Change photo' : 'Choose from gallery'}\n          </ThemedText>\n        </Pressable>\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { backgroundColor: theme.primary, opacity: pressed ? 0.7 : 1 }\n          ]}\n          onPress={handleContinue}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            Continue\n          </ThemedText>\n        </Pressable>\n      </View>\n    </ScreenScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  avatarContainer: {\n    width: Spacing.avatarXLarge,\n    height: Spacing.avatarXLarge,\n    borderRadius: Spacing.avatarXLarge / 2,\n    borderWidth: 2,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginBottom: Spacing.lg,\n    overflow: 'hidden',\n  },\n  avatar: {\n    width: '100%',\n    height: '100%',\n  },\n  linkButton: {\n    marginTop: Spacing.sm,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":5136,"size_tokens":null},"replit.md":{"content":"# Spline Payment App\n\n## Overview\nSpline is a React Native mobile application built with Expo, designed to facilitate bill splitting and shared expense management among friends across iOS, Android, and web platforms. The app integrates a comprehensive onboarding process, friend management, flexible bill splitting functionalities, and an integrated wallet system for payment processing. Its core purpose is to simplify shared financial interactions, offering a seamless and efficient user experience. The project aims to provide a professional marketing presence and robust backend infrastructure for secure and efficient payment handling.\n\n## User Preferences\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Framework\n- **React Native with Expo SDK 54**: Cross-platform development using TypeScript.\n- **React 19.1.0**: Latest React version.\n\n### Backend Architecture\n- **Express Server**: Handles API routes, Stripe integration, and serves the public website and admin dashboard.\n- **Stripe Integration**: Comprehensive payment processing for deposits and split payments.\n- **Supabase PostgreSQL**: Real-time data synchronization and persistent storage, including Row-Level Security (RLS) policies.\n\n### Public Website (splinepay.replit.app)\n- **Landing Page**: Professional marketing page.\n- **Legal Pages**: Terms and Conditions, Privacy Policy.\n- **Admin Access**: Hidden link to `/admin` dashboard.\n\n### UI/UX Architecture\n- **Theming System**: Centralized theme constants with light/dark mode support and custom hooks.\n- **Design Tokens**: Standardized spacing, typography, border radius, and semantic color palette.\n- **Component Library**: Reusable, themed components and screen wrappers, including animated components with Reanimated 4.1.1.\n- **Navigation**: React Navigation for stack and tab-based navigation with a custom bottom tab bar.\n\n### Authentication & User Management\n- **Auth Pattern**: Context-based authentication using React Context API.\n- **Supabase Auth**: Handles password storage securely in `auth.users` (not in public schema).\n- **Auto-Recovery**: Login flow auto-creates missing user profiles and wallets if user exists in Supabase Auth but not in public.users.\n- **Storage**: AsyncStorage for local data persistence.\n- **User Model**: Comprehensive user profiles (password column is nullable - auth handled by Supabase).\n- **Onboarding**: 8-step wizard for user information collection and terms acceptance.\n- **Apple Sign-In**: Only works in TestFlight/production builds. Expo Go returns error \"Unacceptable audience in id_token: [host.exp.Exponent]\" - this is expected behavior per Apple's security requirements.\n\n### Data Management\n- **Service Layer**: Centralized services for Auth, Splits, Wallet, and Stripe interactions.\n- **Data Models**: Users, Friends, Split Events, Wallet, and Notifications.\n- **State Management**: React hooks for local state, Context API for global state, and polling/pull-to-refresh for real-time updates.\n\n### Friend Management\n- **Friend Requests**: Send requests by unique_id (5-10 digit numeric ID).\n- **Friend Lists**: Categorized display of incoming, sent, and accepted friend requests.\n- **Cooldown Period**: 24-hour cooldown for reminder sending.\n- **Realtime Updates**: Supabase Realtime subscription for instant updates when receiving friend requests or when requests are accepted/declined.\n\n### Split Payment Features\n- **Split Types**: Equal and specified amount splitting.\n- **Creation Flow**: Guided process for selecting friends, event details, and finalizing splits.\n- **Status Tracking**: Pending, accepted, paid, and declined states for participants.\n- **Visibility Rules**: Dynamic display of splits based on user participation and status.\n- **Settlement**: Wallet-based payment system.\n- **Realtime Updates**: Supabase Realtime subscriptions for live progress updates.\n  - **EventDetailScreen**: Per-split subscription for instant updates when viewing a specific split\n  - **MainHomeScreen**: Per-split channels (up to 20 most recent) + always-on invite listener + 60s polling backup\n  - **Architecture**: Individual channels per split to avoid Supabase filter size limits (512 bytes)\n  - **Delete Functionality**: Split creators can swipe-delete splits from 'In Progress' tab, removing for all participants\n  - **Future Enhancement**: For 100% realtime coverage beyond 20 splits, implement a `user_split_events_feed` table with database triggers that fan out changes to all participants, allowing a single user-scoped subscription per client\n\n### Wallet System & Payment Processing\n- **Balance Management**: Tracks available funds.\n- **Stripe Integration**: Securely adds payment cards for one-tap payments via PaymentMethod tokens.\n- **Payment Flow**: Prioritizes wallet deduction, then card charge, with automatic refunds for failed card payments.\n- **Creator Wallet Credits**: Creator's wallet credited when participants pay their share.\n- **Withdrawal Types**: Fast Transfer (2% fee) and Normal Transfer (free). Manual processing by admin.\n- **Anti-Abuse Mechanism**: \n  - **5-day hold on deposited funds**: Users cannot withdraw deposited funds for 5 days after deposit (earned funds from split payments can be withdrawn immediately)\n  - **Maximum 2 deposits per day**: Rate limits deposits to prevent rapid fund cycling\n  - **Maximum 3 withdrawals per day**: Daily withdrawal limit across all types\n  - **4 withdrawals per month per type**: Monthly limit for both fast and normal transfers\n- **Atomic RPC Functions**: PostgreSQL RPC functions with `FOR UPDATE` row locks for all wallet balance changes (`process_deposit`, `process_withdrawal`, `process_split_payment`, `credit_recipient_wallet`, `log_transaction_rpc`).\n\n### Stripe Card Binding (PCI Compliant)\n- CVV handling via Stripe Elements, PaymentMethod token storage, off-session payments.\n- Only card brand and last four digits stored in the database for display.\n\n### Stripe Dual-Mode Architecture (App Store Review)\n- **Purpose**: Enables Apple reviewers to test payment features without real charges.\n- **Test Mode Flag**: `stripe_test_mode` boolean column in wallets table (admin-controlled only).\n- **Demo Accounts**: `account1@gmail.com` and `account2@gmail.com` with test mode enabled.\n- **Security**: All Stripe endpoints require Supabase JWT authentication. Test mode is determined server-side only via `userAuthMiddleware`, which reads the wallet's `stripe_test_mode` flag after token verification.\n- **Endpoints**: All card setup, charge, and payment method endpoints derive userId from auth token (no client-supplied userId).\n- **Public Endpoint**: Only `/api/stripe/publishable-key` is unauthenticated (returns live key for StripeProvider initialization).\n- **Files**: `server/routes/stripe.routes.ts`, `services/stripe.service.ts`, `APP_STORE_REVIEW_NOTES.md`.\n\n### Admin Dashboard\n- **Access**: `http://localhost:8082/admin` (dev) / `https://splinepay.replit.app/admin` (prod).\n- **Authentication**: Supabase Auth with admin_roles verification.\n- **Features**: Overview, Buffer Analysis, Transactions, Withdrawals processing, Users & Levels (gamification), Settings (admin user management).\n- **Live Updates**: Server-Sent Events (SSE) stream at `/api/admin/stream` broadcasts metrics every 5 seconds. Dashboard auto-updates without manual refresh, with visual \"Live\" indicator showing connection status.\n- **Supabase Client Pattern**: All admin database queries use fresh Supabase clients (created per-request with explicit schema configuration) to avoid connection state issues with the global client. This ensures reliable data fetching across server restarts.\n- **Users & Levels Tab**: Displays gamification stats including total XP, average level, active streaks, Balance Momentum tier distribution, level distribution chart, and user leaderboard.\n\n### Withdrawal Email Notifications\n- Automatic email to admin (`hzeng1217@gmail.com`) upon user withdrawal request using nodemailer.\n\n### Media Handling\n- `expo-image-picker` for profile pictures and receipts.\n\n### Push Notifications (iOS/Android)\n- `expo-notifications` for native push notifications.\n- **Triggers**: Split invites, payment received, split completed, payment reminders, friend requests.\n- **Features**: Badge count, deep linking to relevant screens.\n- **Deep Linking Routes** (handled in `hooks/usePushNotifications.ts`):\n  - `friend_request` / `friend_accepted` → Friends Tab\n  - `split_invite` / `split_accepted` / `split_declined` / `split_paid` / `split_completed` / `payment_received` → EventDetail screen (with splitEventId)\n  - `payment_reminder` → Notifications screen\n  - Fallback logic based on `splitEventId` or `friendship_id` fields for legacy notifications\n\n### Daily Payment Reminders\n- Automated backend service (hourly run, 9 AM daily) for users with pending split payments.\n- Sends both in-app and push notifications.\n\n### Gamification / XP System\n- **Pure Status-Based**: No monetary rewards, focused on engagement and recognition.\n- **Level System**: 50 levels with progressive XP thresholds. Professional titles reflecting trust and status: Member → Verified → Silver → Gold → Platinum → Premier → Select → Private → Elite → Prestige → Chairman.\n- **XP Awards**: \n  - Split creation (25-40 XP based on size)\n  - Paying splits (20-35 XP based on speed)\n  - Completion bonuses for creators (50 XP)\n  - Streak bonuses (weekly/monthly)\n  - Balance Momentum (10-50 XP/day based on tier)\n- **Perks**:\n  - Level 10: $50 Dinner Voucher (requires admin approval)\n  - Level 15: Extended withdrawal limits\n  - Level 20: 10% discount on fast withdrawals\n  - Level 25: VIP restaurant partner discounts\n  - Level 30: Hotel partner benefits\n  - Level 40: Airport lounge access (coming soon)\n  - Level 50: Premium concierge service\n- **Anti-Abuse Protection**: Prevents XP farming and perk exploitation\n  - Minimum $5 split amount required for XP\n  - Daily XP cap of 500 from splits\n  - Stats still tracked even when XP not awarded\n  - Voucher perks require manual admin approval\n  - Suspicious activity logged for admin review\n- **Badges**: Bronze → Silver → Gold → Platinum tiers for milestones (creator, payer, streak, social).\n- **Streak System**: Daily activity tracking with bonus XP at 7 and 30 day milestones.\n- **Balance Momentum**: Wallet retention incentive system. Users earn XP for maintaining wallet balances over time.\n  - Bronze Tier ($50+ avg balance): 10 XP/day\n  - Silver Tier ($200+ avg balance): 25 XP/day\n  - Gold Tier ($500+ avg balance): 50 XP/day\n  - Based on 7-day rolling average balance, processed daily via `process_all_balance_momentum` RPC\n  - Tables: `wallet_balance_history` (daily snapshots), fields on `user_gamification`\n- **Graceful Degradation**: Service returns sensible defaults (Level 1, \"Member\") if gamification tables not available, ensuring core payment flows are never blocked.\n- **Migration Requirement**: `GAMIFICATION_MIGRATION.sql` must be applied in Supabase for full functionality. Includes Balance Momentum tables.\n- **Components**: `ProfileStatsCard.tsx`, `LevelBadge.tsx`, `LevelUpModal.tsx`, `LevelUpContext.tsx`.\n- **Service**: `services/gamification.service.ts` with XP awarding, streak tracking, badge logic, Balance Momentum status.\n- **Admin Monitoring**: \n  - `/api/admin/gamification/stats` - Overall stats including momentum tier distribution (both processed and eligible)\n  - `/api/admin/gamification/users` - User leaderboard with XP, levels, streaks\n  - `/api/admin/gamification/process-balance-momentum` - Manual trigger for momentum processing (backfills history first)\n  - `/api/admin/gamification/balance-momentum/stats` - Detailed momentum analytics\n  - Admin dashboard \"Users & Levels\" tab with \"Process Momentum\" button for manual triggering\n- **Future Enhancement**: Add Supabase cron or server-side job to run process_all_balance_momentum() daily at 9 AM\n\n### Error Handling\n- Class-based error boundary component with fallback UI.\n- Detailed error modal in DEV mode.\n\n### Platform-Specific Considerations\n- Optimized for iOS, Android, and Web, with Replit integration for development.\n\n## External Dependencies\n\n### UI & Styling\n- `@expo/vector-icons`\n- `expo-blur`\n- `react-native-reanimated`\n- `react-native-safe-area-context`\n\n### Navigation\n- `@react-navigation/native`\n- `@react-navigation/native-stack`\n- `@react-navigation/bottom-tabs`\n- `react-native-screens`\n- `react-native-gesture-handler`\n\n### Input & Interaction\n- `react-native-keyboard-controller`\n- `expo-haptics`\n\n### Media & Utilities\n- `expo-image-picker`\n- `expo-clipboard`\n- `expo-web-browser`\n- `expo-notifications`\n\n### Storage & Backend\n- `@react-native-async-storage/async-storage`\n- `@supabase/supabase-js`\n- `express`\n- `cors`\n- `dotenv`\n- `stripe` (Node.js SDK)\n- `nodemailer`\n\n### Development Tools\n- `babel-plugin-module-resolver`\n- `prettier`\n- `TypeScript`\n- `nodemon`\n- `concurrently`","path":null,"size_bytes":12967,"size_tokens":null},"screens/CreateSplitTypeScreen.tsx":{"content":"import React from 'react';\nimport { View, StyleSheet, Pressable } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenScrollView } from '@/components/ScreenScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { Friend } from '@/utils/storage';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\n\ntype Props = NativeStackScreenProps<any, 'CreateSplitType'>;\n\nexport default function CreateSplitTypeScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n  const insets = useSafeAreaInsets();\n\n  const handleSelectType = (type: 'equal' | 'specified') => {\n    navigation.navigate('CreateSplitSelectFriends', { splitType: type });\n  };\n\n  return (\n    <ScreenScrollView contentContainerStyle={styles.container}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.xl }]}>\n        <Pressable\n          style={({ pressed }) => [styles.closeButton, { opacity: pressed ? 0.7 : 1 }]}\n          onPress={() => navigation.goBack()}\n        >\n          <Feather name=\"x\" size={24} color={theme.text} />\n        </Pressable>\n      </View>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.h1, { color: theme.text, textAlign: 'center', marginBottom: Spacing.md }]}>\n          Choose Split Type\n        </ThemedText>\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, textAlign: 'center', marginBottom: Spacing['2xl'] }]}>\n          How would you like to split this bill?\n        </ThemedText>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.typeCard,\n            { \n              backgroundColor: theme.surface,\n              borderColor: theme.border,\n              opacity: pressed ? 0.7 : 1\n            }\n          ]}\n          onPress={() => handleSelectType('equal')}\n        >\n          <View style={[styles.iconContainer, { backgroundColor: theme.primary + '20' }]}>\n            <Feather name=\"percent\" size={32} color={theme.primary} />\n          </View>\n          <ThemedText style={[Typography.h2, { color: theme.text, marginTop: Spacing.lg, marginBottom: Spacing.sm }]}>\n            Equal Split\n          </ThemedText>\n          <ThemedText style={[Typography.body, { color: theme.textSecondary, textAlign: 'center' }]}>\n            Divide the total amount equally among all participants\n          </ThemedText>\n        </Pressable>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.typeCard,\n            { \n              backgroundColor: theme.surface,\n              borderColor: theme.border,\n              opacity: pressed ? 0.7 : 1\n            }\n          ]}\n          onPress={() => handleSelectType('specified')}\n        >\n          <View style={[styles.iconContainer, { backgroundColor: theme.secondary + '20' }]}>\n            <Feather name=\"file-text\" size={32} color={theme.secondary} />\n          </View>\n          <ThemedText style={[Typography.h2, { color: theme.text, marginTop: Spacing.lg, marginBottom: Spacing.sm }]}>\n            Specified\n          </ThemedText>\n          <ThemedText style={[Typography.body, { color: theme.textSecondary, textAlign: 'center' }]}>\n            Upload a receipt and let each person pay their own share\n          </ThemedText>\n        </Pressable>\n      </ThemedView>\n    </ScreenScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  header: {\n    paddingHorizontal: Spacing.xl,\n    alignItems: 'flex-end',\n  },\n  closeButton: {\n    width: 40,\n    height: 40,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  typeCard: {\n    padding: Spacing.xl,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    alignItems: 'center',\n    marginBottom: Spacing.xl,\n  },\n  iconContainer: {\n    width: 80,\n    height: 80,\n    borderRadius: 40,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":4239,"size_tokens":null},"components/Button.tsx":{"content":"import React, { ReactNode } from \"react\";\nimport { StyleSheet, Pressable, ViewStyle, StyleProp } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { BorderRadius, Spacing } from \"@/constants/theme\";\n\ninterface ButtonProps {\n  onPress?: () => void;\n  children: ReactNode;\n  style?: StyleProp<ViewStyle>;\n  disabled?: boolean;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Button({\n  onPress,\n  children,\n  style,\n  disabled = false,\n}: ButtonProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    if (!disabled) {\n      scale.value = withSpring(0.98, springConfig);\n    }\n  };\n\n  const handlePressOut = () => {\n    if (!disabled) {\n      scale.value = withSpring(1, springConfig);\n    }\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={disabled ? undefined : onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      disabled={disabled}\n      style={[\n        styles.button,\n        {\n          backgroundColor: theme.link,\n          opacity: disabled ? 0.5 : 1,\n        },\n        style,\n        animatedStyle,\n      ]}\n    >\n      <ThemedText\n        type=\"body\"\n        style={[styles.buttonText, { color: theme.buttonText }]}\n      >\n        {children}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.full,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  buttonText: {\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":2014,"size_tokens":null},"components/CustomTabBar.tsx":{"content":"import React from 'react';\nimport { View, Pressable, StyleSheet, Platform } from 'react-native';\nimport { BlurView } from 'expo-blur';\nimport { Feather } from '@expo/vector-icons';\nimport * as Haptics from 'expo-haptics';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { ThemedText } from './ThemedText';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Spacing, BorderRadius } from '@/constants/theme';\n\nexport function CustomTabBar({ state, descriptors, navigation }: any) {\n  const { theme, isDark } = useTheme();\n  const insets = useSafeAreaInsets();\n\n  const tabBarHeight = 60 + insets.bottom;\n\n  return (\n    <View style={[styles.container, { height: tabBarHeight }]}>\n      {Platform.OS === 'ios' ? (\n        <BlurView\n          intensity={100}\n          tint={isDark ? 'dark' : 'light'}\n          style={StyleSheet.absoluteFill}\n        />\n      ) : (\n        <View style={[StyleSheet.absoluteFill, { backgroundColor: theme.backgroundRoot }]} />\n      )}\n      \n      <View style={styles.tabContainer}>\n        {state.routes.map((route: any, index: number) => {\n          const { options } = descriptors[route.key];\n          const isFocused = state.index === index;\n          \n          if (route.name === 'CreateTab') {\n            return (\n              <Pressable\n                key={route.key}\n                style={({ pressed }) => [\n                  styles.centerButton,\n                  {\n                    backgroundColor: theme.primary,\n                    opacity: pressed ? 0.8 : 1,\n                    transform: [{ scale: pressed ? 0.95 : 1 }],\n                  }\n                ]}\n                onPress={() => {\n                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium).catch(() => null);\n                  navigation.navigate('HomeTab');\n                  requestAnimationFrame(() => {\n                    navigation.navigate('HomeTab', {\n                      screen: 'CreateSplitType',\n                    } as never);\n                  });\n                }}\n              >\n                <Feather name=\"plus\" size={28} color=\"#FFFFFF\" />\n              </Pressable>\n            );\n          }\n\n          const onPress = () => {\n            const event = navigation.emit({\n              type: 'tabPress',\n              target: route.key,\n              canPreventDefault: true,\n            });\n\n            if (!isFocused && !event.defaultPrevented) {\n              navigation.navigate(route.name);\n            }\n          };\n\n          const color = isFocused ? theme.tabIconSelected : theme.tabIconDefault;\n\n          return (\n            <Pressable\n              key={route.key}\n              accessibilityRole=\"button\"\n              accessibilityState={isFocused ? { selected: true } : {}}\n              accessibilityLabel={options.tabBarAccessibilityLabel}\n              onPress={onPress}\n              style={styles.tab}\n            >\n              {options.tabBarIcon && options.tabBarIcon({ \n                color, \n                size: 24,\n                focused: isFocused \n              })}\n              <ThemedText style={[styles.label, { color, fontSize: 11 }]}>\n                {options.title}\n              </ThemedText>\n            </Pressable>\n          );\n        })}\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    bottom: 0,\n    left: 0,\n    right: 0,\n    borderTopWidth: 0,\n    elevation: 0,\n  },\n  tabContainer: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.md,\n  },\n  tab: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: Spacing.sm,\n  },\n  label: {\n    marginTop: 4,\n    fontWeight: '500',\n  },\n  centerButton: {\n    width: 56,\n    height: 56,\n    borderRadius: 28,\n    alignItems: 'center',\n    justifyContent: 'center',\n    marginHorizontal: Spacing.md,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.3,\n    shadowRadius: 8,\n    elevation: 8,\n  },\n});\n","path":null,"size_bytes":4070,"size_tokens":null},"components/ScreenFlatList.tsx":{"content":"import React from \"react\";\nimport { FlatList, FlatListProps, StyleSheet } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useScreenInsets } from \"@/hooks/useScreenInsets\";\nimport { Spacing } from \"@/constants/theme\";\n\nexport function ScreenFlatList<T>({\n  contentContainerStyle,\n  style,\n  ...flatListProps\n}: FlatListProps<T>) {\n  const { theme } = useTheme();\n  const { paddingTop, paddingBottom, scrollInsetBottom } = useScreenInsets();\n\n  return (\n    <FlatList\n      style={[\n        styles.container,\n        { backgroundColor: theme.backgroundRoot },\n        style,\n      ]}\n      contentContainerStyle={[\n        {\n          paddingTop,\n          paddingBottom,\n        },\n        styles.contentContainer,\n        contentContainerStyle,\n      ]}\n      scrollIndicatorInsets={{ bottom: scrollInsetBottom }}\n      {...flatListProps}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  contentContainer: {\n    paddingHorizontal: Spacing.xl,\n  },\n});\n","path":null,"size_bytes":1016,"size_tokens":null},"screens/NotificationsScreen.tsx":{"content":"import React, { useState, useEffect, useCallback } from 'react';\nimport { View, StyleSheet, Pressable, FlatList, RefreshControl, ActivityIndicator } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { useFocusEffect } from '@react-navigation/native';\nimport * as Haptics from 'expo-haptics';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { NotificationsService } from '@/services/notifications.service';\nimport { SplitsService } from '@/services/splits.service';\nimport { FriendsService } from '@/services/friends.service';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { supabase } from '@/services/supabase';\nimport type { Notification } from '@/shared/types';\n\ntype Props = NativeStackScreenProps<any, 'Notifications'>;\n\ninterface FriendshipStatus {\n  [key: string]: 'pending' | 'accepted' | 'declined' | 'unknown';\n}\n\ninterface SplitParticipantStatus {\n  [key: string]: 'pending' | 'accepted' | 'declined' | 'paid';\n}\n\nexport default function NotificationsScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n  const { user } = useAuth();\n  const insets = useSafeAreaInsets();\n  const [notifications, setNotifications] = useState<Notification[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [refreshing, setRefreshing] = useState(false);\n  const [processingId, setProcessingId] = useState<string | null>(null);\n  const [friendshipStatuses, setFriendshipStatuses] = useState<FriendshipStatus>({});\n  const [splitParticipantStatuses, setSplitParticipantStatuses] = useState<SplitParticipantStatus>({});\n\n  const loadFriendshipStatuses = useCallback(async (notifs: Notification[]) => {\n    const friendRequestNotifs = notifs.filter(n => n.type === 'friend_request');\n    const friendshipIds = friendRequestNotifs\n      .map(n => n.friendship_id || (n.metadata as any)?.friendship_id)\n      .filter(Boolean);\n    \n    if (friendshipIds.length === 0) return;\n\n    const { data } = await supabase\n      .from('friends')\n      .select('id, status')\n      .in('id', friendshipIds);\n\n    if (data) {\n      const statuses: FriendshipStatus = {};\n      data.forEach(f => {\n        statuses[f.id] = f.status as 'pending' | 'accepted' | 'declined';\n      });\n      setFriendshipStatuses(statuses);\n    }\n  }, []);\n\n  const loadSplitParticipantStatuses = useCallback(async (notifs: Notification[]) => {\n    if (!user) return;\n    \n    const splitInviteNotifs = notifs.filter(n => n.type === 'split_invite' && n.split_event_id);\n    const splitEventIds = splitInviteNotifs\n      .map(n => n.split_event_id)\n      .filter(Boolean) as string[];\n    \n    if (splitEventIds.length === 0) return;\n\n    const { data } = await supabase\n      .from('split_participants')\n      .select('split_event_id, status')\n      .eq('user_id', user.id)\n      .in('split_event_id', splitEventIds);\n\n    if (data) {\n      const statuses: SplitParticipantStatus = {};\n      data.forEach(p => {\n        statuses[p.split_event_id] = p.status as 'pending' | 'accepted' | 'declined' | 'paid';\n      });\n      setSplitParticipantStatuses(statuses);\n    }\n  }, [user]);\n\n  const loadNotifications = useCallback(async () => {\n    if (!user) return;\n    try {\n      const notifs = await NotificationsService.getNotifications(user.id);\n      setNotifications(notifs);\n      await Promise.all([\n        loadFriendshipStatuses(notifs),\n        loadSplitParticipantStatuses(notifs)\n      ]);\n    } catch (error) {\n      console.error('Failed to load notifications:', error);\n    } finally {\n      setLoading(false);\n    }\n  }, [user, loadFriendshipStatuses, loadSplitParticipantStatuses]);\n\n  useEffect(() => {\n    loadNotifications();\n  }, [loadNotifications]);\n\n  useFocusEffect(\n    useCallback(() => {\n      loadNotifications();\n    }, [loadNotifications])\n  );\n\n  const onRefresh = async () => {\n    setRefreshing(true);\n    await loadNotifications();\n    setRefreshing(false);\n  };\n\n  const navigateToRelevantScreen = (notification: Notification) => {\n    const parentNav = navigation.getParent();\n    \n    switch (notification.type) {\n      case 'friend_request':\n      case 'friend_accepted':\n        navigation.goBack();\n        setTimeout(() => {\n          parentNav?.navigate('FriendsTab');\n        }, 100);\n        break;\n      case 'split_invite':\n      case 'split_accepted':\n      case 'split_declined':\n      case 'split_paid':\n      case 'split_completed':\n        if (notification.split_event_id) {\n          navigation.navigate('EventDetail', { eventId: notification.split_event_id });\n        } else {\n          navigation.goBack();\n        }\n        break;\n      case 'payment_reminder':\n        navigation.goBack();\n        break;\n      default:\n        break;\n    }\n  };\n\n  const handleNotificationTap = async (notification: Notification) => {\n    if (processingId) return;\n    \n    setProcessingId(notification.id);\n    try {\n      if (!notification.read) {\n        await NotificationsService.markAsRead(notification.id);\n        setNotifications(prev => \n          prev.map(n => n.id === notification.id ? { ...n, read: true } : n)\n        );\n      }\n      navigateToRelevantScreen(notification);\n    } catch (error) {\n      console.error('Failed to handle notification tap:', error);\n    } finally {\n      setProcessingId(null);\n    }\n  };\n\n  const handleAccept = async (notification: Notification) => {\n    if (!user || !notification.split_event_id) return;\n    \n    const eventId = notification.split_event_id;\n    setProcessingId(notification.id);\n    try {\n      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      await SplitsService.respondToSplit(user.id, eventId, 'accepted');\n      await NotificationsService.markAsRead(notification.id);\n      navigation.navigate('EventDetail', { eventId });\n    } catch (error) {\n      console.error('Failed to accept split:', error);\n    } finally {\n      setProcessingId(null);\n    }\n  };\n\n  const handleDecline = async (notification: Notification) => {\n    if (!user || !notification.split_event_id) return;\n    \n    setProcessingId(notification.id);\n    try {\n      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);\n      await SplitsService.respondToSplit(user.id, notification.split_event_id, 'declined');\n      await NotificationsService.markAsRead(notification.id);\n      await loadNotifications();\n    } catch (error) {\n      console.error('Failed to decline split:', error);\n    } finally {\n      setProcessingId(null);\n    }\n  };\n\n  const handleAcceptFriendRequest = async (notification: Notification) => {\n    console.log('handleAcceptFriendRequest - notification:', JSON.stringify(notification, null, 2));\n    console.log('handleAcceptFriendRequest - friendship_id:', notification.friendship_id);\n    console.log('handleAcceptFriendRequest - metadata:', notification.metadata);\n    \n    if (!user || !notification.friendship_id) {\n      console.error('Missing user or friendship_id. user:', user?.id, 'friendship_id:', notification.friendship_id);\n      return;\n    }\n    \n    setProcessingId(notification.id);\n    try {\n      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      console.log('Calling FriendsService.acceptFriendRequest with userId:', user.id, 'friendshipId:', notification.friendship_id);\n      await FriendsService.acceptFriendRequest(user.id, notification.friendship_id);\n      await NotificationsService.markAsRead(notification.id);\n      await loadNotifications();\n    } catch (error) {\n      console.error('Failed to accept friend request:', error);\n    } finally {\n      setProcessingId(null);\n    }\n  };\n\n  const handleDeclineFriendRequest = async (notification: Notification) => {\n    if (!user || !notification.friendship_id) return;\n    \n    setProcessingId(notification.id);\n    try {\n      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);\n      await FriendsService.declineFriendRequest(user.id, notification.friendship_id);\n      await NotificationsService.markAsRead(notification.id);\n      await loadNotifications();\n    } catch (error) {\n      console.error('Failed to decline friend request:', error);\n    } finally {\n      setProcessingId(null);\n    }\n  };\n\n  const getNotificationIcon = (type: string) => {\n    switch (type) {\n      case 'split_invite':\n        return 'users';\n      case 'split_accepted':\n        return 'check-circle';\n      case 'split_declined':\n        return 'x-circle';\n      case 'split_paid':\n        return 'dollar-sign';\n      case 'split_completed':\n        return 'check-circle';\n      case 'friend_request':\n        return 'user-plus';\n      case 'friend_accepted':\n        return 'user-check';\n      case 'payment_reminder':\n        return 'clock';\n      default:\n        return 'bell';\n    }\n  };\n\n  const getNotificationColor = (type: string) => {\n    switch (type) {\n      case 'split_accepted':\n      case 'split_paid':\n      case 'split_completed':\n      case 'friend_accepted':\n        return theme.success;\n      case 'split_declined':\n        return theme.danger;\n      case 'friend_request':\n        return theme.primary;\n      case 'payment_reminder':\n        return theme.warning;\n      default:\n        return theme.primary;\n    }\n  };\n\n  const renderNotification = ({ item }: { item: Notification }) => {\n    const isProcessing = processingId === item.id;\n    \n    const splitEventId = item.split_event_id;\n    const splitParticipantStatus = splitEventId ? splitParticipantStatuses[splitEventId] : undefined;\n    const isSplitStillPending = splitParticipantStatus === 'pending' || splitParticipantStatus === undefined;\n    const showSplitActions = item.type === 'split_invite' && splitEventId && isSplitStillPending;\n    const splitInviteHandled = item.type === 'split_invite' && splitEventId && !isSplitStillPending;\n    \n    const friendshipId = item.friendship_id || (item.metadata as any)?.friendship_id;\n    const friendshipStatus = friendshipId ? friendshipStatuses[friendshipId] : undefined;\n    const isStillPending = friendshipStatus === 'pending' || friendshipStatus === undefined;\n    const showFriendActions = item.type === 'friend_request' && !item.read && friendshipId && isStillPending;\n    const friendRequestHandled = item.type === 'friend_request' && friendshipId && !isStillPending;\n    const iconColor = getNotificationColor(item.type);\n    const hasActions = showSplitActions || showFriendActions;\n    const isTappable = !hasActions && !isProcessing;\n\n    return (\n      <Pressable\n        style={({ pressed }) => [\n          styles.notificationCard, \n          { \n            backgroundColor: theme.surface, \n            borderColor: item.read ? theme.border : theme.primary + '40',\n            borderWidth: item.read ? 1 : 2,\n            opacity: pressed && isTappable ? 0.7 : (item.read ? 0.7 : 1)\n          }\n        ]}\n        onPress={() => isTappable && handleNotificationTap(item)}\n        disabled={!isTappable}\n      >\n        <View style={[styles.iconContainer, { backgroundColor: iconColor + '20' }]}>\n          <Feather name={getNotificationIcon(item.type) as any} size={24} color={iconColor} />\n        </View>\n\n        <View style={styles.notificationContent}>\n          <View style={styles.notificationHeader}>\n            <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600', flex: 1, marginBottom: Spacing.xs }]}>\n              {item.title}\n            </ThemedText>\n            {!item.read && !hasActions ? (\n              <View style={[styles.unreadDot, { backgroundColor: theme.primary }]} />\n            ) : null}\n          </View>\n          <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing.xs }]}>\n            {item.message}\n          </ThemedText>\n          <ThemedText style={[Typography.small, { color: theme.textSecondary }]}>\n            {new Date(item.created_at).toLocaleDateString()}\n          </ThemedText>\n\n          {isProcessing ? (\n            <View style={styles.processingContainer}>\n              <ActivityIndicator size=\"small\" color={theme.primary} />\n            </View>\n          ) : showSplitActions ? (\n            <View style={styles.actions}>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.actionButton,\n                  styles.acceptButton,\n                  { backgroundColor: theme.success, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={() => handleAccept(item)}\n              >\n                <ThemedText style={[Typography.body, { color: '#FFFFFF' }]}>\n                  Accept\n                </ThemedText>\n              </Pressable>\n\n              <Pressable\n                style={({ pressed }) => [\n                  styles.actionButton,\n                  styles.declineButton,\n                  { backgroundColor: theme.backgroundSecondary, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={() => handleDecline(item)}\n              >\n                <ThemedText style={[Typography.body, { color: theme.text }]}>\n                  Decline\n                </ThemedText>\n              </Pressable>\n            </View>\n          ) : showFriendActions ? (\n            <View style={styles.actions}>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.actionButton,\n                  styles.acceptButton,\n                  { backgroundColor: theme.success, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={() => handleAcceptFriendRequest({ ...item, friendship_id: friendshipId })}\n              >\n                <ThemedText style={[Typography.body, { color: '#FFFFFF' }]}>\n                  Accept\n                </ThemedText>\n              </Pressable>\n\n              <Pressable\n                style={({ pressed }) => [\n                  styles.actionButton,\n                  styles.declineButton,\n                  { backgroundColor: theme.backgroundSecondary, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={() => handleDeclineFriendRequest({ ...item, friendship_id: friendshipId })}\n              >\n                <ThemedText style={[Typography.body, { color: theme.text }]}>\n                  Decline\n                </ThemedText>\n              </Pressable>\n            </View>\n          ) : splitInviteHandled ? (\n            <View style={[styles.statusBadge, { backgroundColor: splitParticipantStatus === 'declined' ? theme.danger + '20' : theme.success + '20' }]}>\n              <Feather \n                name={splitParticipantStatus === 'declined' ? 'x-circle' : 'check-circle'} \n                size={14} \n                color={splitParticipantStatus === 'declined' ? theme.danger : theme.success} \n              />\n              <ThemedText style={[Typography.small, { color: splitParticipantStatus === 'declined' ? theme.danger : theme.success, marginLeft: Spacing.xs }]}>\n                {splitParticipantStatus === 'declined' ? 'Declined' : splitParticipantStatus === 'paid' ? 'Paid' : 'Accepted'}\n              </ThemedText>\n            </View>\n          ) : friendRequestHandled ? (\n            <View style={[styles.statusBadge, { backgroundColor: friendshipStatus === 'accepted' ? theme.success + '20' : theme.danger + '20' }]}>\n              <Feather \n                name={friendshipStatus === 'accepted' ? 'check-circle' : 'x-circle'} \n                size={14} \n                color={friendshipStatus === 'accepted' ? theme.success : theme.danger} \n              />\n              <ThemedText style={[Typography.small, { color: friendshipStatus === 'accepted' ? theme.success : theme.danger, marginLeft: Spacing.xs }]}>\n                {friendshipStatus === 'accepted' ? 'Already accepted' : 'Declined'}\n              </ThemedText>\n            </View>\n          ) : null}\n        </View>\n      </Pressable>\n    );\n  };\n\n  if (loading) {\n    return (\n      <ThemedView style={[styles.container, { justifyContent: 'center', alignItems: 'center' }]}>\n        <ActivityIndicator size=\"large\" color={theme.primary} />\n      </ThemedView>\n    );\n  }\n\n  return (\n    <ThemedView style={[styles.container, { paddingTop: insets.top + Spacing.xl }]}>\n      <View style={styles.header}>\n        <Pressable\n          style={({ pressed }) => [styles.backButton, { opacity: pressed ? 0.7 : 1 }]}\n          onPress={() => navigation.goBack()}\n        >\n          <Feather name=\"arrow-left\" size={24} color={theme.text} />\n        </Pressable>\n        <ThemedText style={[Typography.h1, { color: theme.text }]}>Notifications</ThemedText>\n        <View style={{ width: 40 }} />\n      </View>\n\n      <FlatList\n        data={notifications}\n        renderItem={renderNotification}\n        keyExtractor={(item) => item.id}\n        contentContainerStyle={styles.listContent}\n        refreshControl={\n          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} tintColor={theme.primary} />\n        }\n        ListEmptyComponent={\n          <View style={styles.emptyState}>\n            <Feather name=\"bell\" size={48} color={theme.textSecondary} />\n            <ThemedText style={[Typography.body, { color: theme.textSecondary, marginTop: Spacing.lg }]}>\n              No notifications\n            </ThemedText>\n          </View>\n        }\n      />\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.xl,\n    marginBottom: Spacing.lg,\n  },\n  backButton: {\n    width: 40,\n    height: 40,\n    justifyContent: 'center',\n  },\n  listContent: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  notificationCard: {\n    flexDirection: 'row',\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    marginBottom: Spacing.md,\n  },\n  iconContainer: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  notificationContent: {\n    flex: 1,\n    marginLeft: Spacing.md,\n  },\n  notificationHeader: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n  },\n  unreadDot: {\n    width: 8,\n    height: 8,\n    borderRadius: 4,\n    marginLeft: Spacing.sm,\n    marginTop: 4,\n  },\n  actions: {\n    flexDirection: 'row',\n    gap: Spacing.md,\n    marginTop: Spacing.md,\n  },\n  actionButton: {\n    flex: 1,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.xs,\n    alignItems: 'center',\n  },\n  acceptButton: {},\n  declineButton: {},\n  processingContainer: {\n    marginTop: Spacing.md,\n    alignItems: 'flex-start',\n  },\n  statusBadge: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginTop: Spacing.md,\n    paddingHorizontal: Spacing.sm,\n    paddingVertical: Spacing.xs,\n    borderRadius: BorderRadius.xs,\n    alignSelf: 'flex-start',\n  },\n  emptyState: {\n    alignItems: 'center',\n    paddingVertical: Spacing['2xl'] * 2,\n  },\n});\n","path":null,"size_bytes":19250,"size_tokens":null},"screens/EventDetailScreen.tsx":{"content":"import React, { useState, useEffect, useCallback } from 'react';\nimport { View, StyleSheet, Pressable, Image, ScrollView, Alert, Modal, ActivityIndicator, TextInput } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { Feather } from '@expo/vector-icons';\nimport * as WebBrowser from 'expo-web-browser';\nimport { useHeaderHeight } from '@react-navigation/elements';\nimport { useFocusEffect } from '@react-navigation/native';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { LoadingOverlay } from '@/components/LoadingOverlay';\nimport { LevelBadge } from '@/components/ProfileStatsCard';\nimport { FriendProfileModal } from '@/components/FriendProfileModal';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { useLevelUp } from '@/contexts/LevelUpContext';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { SplitsService } from '@/services/splits.service';\nimport { WalletService } from '@/services/wallet.service';\nimport { FriendsService } from '@/services/friends.service';\nimport { GamificationService } from '@/services/gamification.service';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { useSafeBottomTabBarHeight } from '@/hooks/useSafeBottomTabBarHeight';\n\ninterface SelectedParticipant {\n  id: string;\n  name: string;\n  unique_id?: string;\n  profile_picture_url?: string;\n}\n\ntype Props = NativeStackScreenProps<any, 'EventDetail'>;\n\nexport default function EventDetailScreen({ route, navigation }: Props) {\n  const { theme } = useTheme();\n  const { user } = useAuth();\n  const { checkLevelUp } = useLevelUp();\n  const insets = useSafeAreaInsets();\n  const tabBarHeight = useSafeBottomTabBarHeight();\n  const headerHeight = useHeaderHeight();\n  const { eventId } = route.params as { eventId: string };\n  const [event, setEvent] = useState<any>(null);\n  const [loading, setLoading] = useState(true);\n  const [imageVisible, setImageVisible] = useState(false);\n  const [friendIds, setFriendIds] = useState<Set<string>>(new Set());\n  const [pendingIds, setPendingIds] = useState<Set<string>>(new Set());\n  const [addingFriend, setAddingFriend] = useState<string | null>(null);\n  const [amountModalVisible, setAmountModalVisible] = useState(false);\n  const [customAmount, setCustomAmount] = useState('');\n  const [paymentModalVisible, setPaymentModalVisible] = useState(false);\n  const [paymentAmount, setPaymentAmount] = useState('');\n  const [paymentProcessing, setPaymentProcessing] = useState(false);\n  const [participantGamification, setParticipantGamification] = useState<Record<string, { level: number; title: string } | null>>({});\n  const [selectedParticipant, setSelectedParticipant] = useState<SelectedParticipant | null>(null);\n  const [participantModalVisible, setParticipantModalVisible] = useState(false);\n\n  const handleParticipantPress = (participant: any) => {\n    if (!participant.user) return;\n    setSelectedParticipant({\n      id: participant.user_id,\n      name: participant.user.name || 'Unknown',\n      unique_id: participant.user.unique_id,\n      profile_picture_url: participant.user.profile_picture,\n    });\n    setParticipantModalVisible(true);\n  };\n\n  useEffect(() => {\n    loadEvent();\n    loadFriendIds();\n  }, [eventId, user?.id]);\n\n  // Subscribe to realtime updates for this specific split event\n  useEffect(() => {\n    if (!eventId) return;\n\n    const subscription = SplitsService.subscribeToSplitEventUpdates(eventId, () => {\n      // Reload event data when there are changes\n      loadEvent();\n    });\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [eventId]);\n\n  // Refresh data when screen comes into focus\n  useFocusEffect(\n    useCallback(() => {\n      loadEvent();\n      loadFriendIds();\n    }, [eventId, user?.id])\n  );\n\n  const loadFriendIds = async () => {\n    if (!user?.id) return;\n    try {\n      const friends = await FriendsService.getFriends(user.id);\n      const ids = new Set(friends.map((f: any) => f.friend_details?.id || f.friend_id));\n      setFriendIds(ids);\n      \n      const pendingRequests = await FriendsService.getPendingRequests(user.id);\n      const sentRequests = await FriendsService.getSentPendingRequests(user.id);\n      const pendingUserIds = new Set([\n        ...pendingRequests.map((r: any) => r.user_id),\n        ...sentRequests.map((r: any) => r.friend_id)\n      ]);\n      setPendingIds(pendingUserIds);\n    } catch (error) {\n      console.error('Failed to load friends:', error);\n    }\n  };\n\n  const handleAddFriend = async (participantId: string) => {\n    if (!user?.id || participantId === user.id) return;\n    \n    if (friendIds.has(participantId)) {\n      Alert.alert('Already Friends', 'You are already friends with this person.');\n      return;\n    }\n    \n    if (pendingIds.has(participantId)) {\n      Alert.alert('Request Pending', 'A friend request is already pending.');\n      return;\n    }\n    \n    try {\n      setAddingFriend(participantId);\n      await FriendsService.sendFriendRequestById(user.id, participantId);\n      setPendingIds(prev => new Set([...prev, participantId]));\n      Alert.alert('Request Sent', 'Friend request has been sent! They will appear in your friends list once they accept.');\n      await loadFriendIds();\n    } catch (error: any) {\n      const message = error.message || 'Failed to send friend request';\n      if (message.includes('Already friends')) {\n        await loadFriendIds();\n        Alert.alert('Already Friends', 'You are already friends with this person.');\n      } else if (message.includes('already sent') || message.includes('pending')) {\n        setPendingIds(prev => new Set([...prev, participantId]));\n        Alert.alert('Request Pending', 'A friend request is already pending. Check your Friends tab to accept or view the request.');\n      } else {\n        Alert.alert('Error', message);\n      }\n    } finally {\n      setAddingFriend(null);\n    }\n  };\n\n  const loadEvent = async () => {\n    try {\n      setLoading(true);\n      const data = await SplitsService.getSplitDetails(eventId);\n      setEvent(data);\n      \n      // Load gamification data for all participants\n      if (data?.participants) {\n        const gamificationMap: Record<string, { level: number; title: string } | null> = {};\n        await Promise.all(\n          data.participants.map(async (p: any) => {\n            try {\n              const profile = await GamificationService.getProfile(p.user_id);\n              if (profile) {\n                gamificationMap[p.user_id] = {\n                  level: profile.current_level,\n                  title: profile.title || GamificationService.getTitleForLevel(profile.current_level),\n                };\n              } else {\n                gamificationMap[p.user_id] = null;\n              }\n            } catch {\n              gamificationMap[p.user_id] = null;\n            }\n          })\n        );\n        setParticipantGamification(gamificationMap);\n      }\n    } catch (error) {\n      console.error('Failed to load event:', error);\n      setEvent(null);\n      Alert.alert(\n        'Error', \n        'Failed to load event details. Please try again.',\n        [\n          { text: 'Retry', onPress: loadEvent },\n          { text: 'Go Back', onPress: () => navigation.goBack() }\n        ]\n      );\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleAccept = async () => {\n    if (!user || !event) return;\n    \n    if (event.split_type === 'specified') {\n      setAmountModalVisible(true);\n    } else {\n      try {\n        await SplitsService.respondToSplit(user.id, eventId, 'accepted');\n        Alert.alert('Success', 'You accepted this split request');\n        loadEvent();\n      } catch (error) {\n        console.error('Failed to accept split:', error);\n        Alert.alert('Error', 'Failed to accept split');\n      }\n    }\n  };\n\n  const handleAcceptWithAmount = async () => {\n    if (!user || !event) return;\n    \n    const amount = parseFloat(customAmount);\n    if (isNaN(amount) || amount <= 0) {\n      Alert.alert('Invalid Amount', 'Please enter a valid amount greater than 0');\n      return;\n    }\n\n    const totalAmount = parseFloat(event.total_amount);\n    if (amount > totalAmount) {\n      Alert.alert('Invalid Amount', 'Your share cannot exceed the total amount');\n      return;\n    }\n\n    try {\n      await SplitsService.respondToSplitWithAmount(user.id, eventId, 'accepted', amount);\n      setAmountModalVisible(false);\n      setCustomAmount('');\n      Alert.alert('Success', 'You accepted this split and entered your share');\n      loadEvent();\n    } catch (error) {\n      console.error('Failed to accept split:', error);\n      Alert.alert('Error', 'Failed to accept split');\n    }\n  };\n\n  const handleDecline = async () => {\n    if (!user || !event) return;\n    \n    Alert.alert(\n      'Decline Split',\n      'Are you sure you want to decline this split?',\n      [\n        { text: 'Cancel', style: 'cancel' },\n        {\n          text: 'Decline',\n          style: 'destructive',\n          onPress: async () => {\n            try {\n              await SplitsService.respondToSplit(user.id, eventId, 'declined');\n              Alert.alert('Declined', 'You declined this split request');\n              navigation.goBack();\n            } catch (error) {\n              console.error('Failed to decline split:', error);\n              Alert.alert('Error', 'Failed to decline split');\n            }\n          },\n        },\n      ]\n    );\n  };\n\n  const handlePayment = async () => {\n    if (!event || !user) return;\n\n    try {\n      const myParticipant = event.participants?.find((p: any) => p.user_id === user.id);\n      if (!myParticipant) return;\n\n      const participantAmount = parseFloat(myParticipant.amount);\n      \n      // For specified splits where participant hasn't entered their amount yet, show modal\n      if (event.split_type === 'specified' && participantAmount === 0) {\n        setPaymentModalVisible(true);\n        return;\n      }\n      \n      Alert.alert(\n        'Confirm Payment',\n        `Pay $${participantAmount.toFixed(2)} for ${event.name}?\\n\\nPayment will be deducted from your wallet balance if available, otherwise from your saved card.`,\n        [\n          { text: 'Cancel', style: 'cancel' },\n          {\n            text: 'Confirm',\n            onPress: async () => {\n              setPaymentProcessing(true);\n              try {\n                // paySplitEvent now atomically handles wallet deduction AND split status update\n                const result = await WalletService.paySplitEvent(\n                  user.id,\n                  eventId,\n                  participantAmount,\n                  event.creator_id,\n                  event.name\n                );\n                \n                // Check if user leveled up\n                if (result.xpResult) {\n                  checkLevelUp(result.xpResult);\n                }\n                \n                // No need to call SplitsService.paySplit() - atomic RPC already updated status\n                setPaymentProcessing(false);\n                Alert.alert('Payment Successful', 'Your payment has been processed');\n                loadEvent();\n              } catch (error: any) {\n                setPaymentProcessing(false);\n                console.error('Payment failed:', error);\n                if (error.message.includes('Insufficient wallet balance') || error.message.includes('Add a payment card')) {\n                  Alert.alert(\n                    'Add Card Required',\n                    'You don\\'t have enough balance in your wallet. Would you like to add a payment card to complete this payment?',\n                    [\n                      { text: 'Cancel', style: 'cancel' },\n                      {\n                        text: 'Add Card',\n                        onPress: () => {\n                          // Navigate directly to WalletTab, ensuring it comes to front\n                          navigation.getParent()?.reset({\n                            index: 0,\n                            routes: [{ name: 'WalletTab' }],\n                          });\n                        }\n                      }\n                    ]\n                  );\n                } else {\n                  Alert.alert('Error', error.message || 'Payment failed. Please try again.');\n                }\n              }\n            }\n          }\n        ]\n      );\n    } catch (error: any) {\n      console.error('Payment failed:', error);\n      Alert.alert('Error', error.message || 'Failed to process payment');\n    }\n  };\n\n  const handlePaymentWithAmount = async () => {\n    if (!event || !user) return;\n    \n    const amount = parseFloat(paymentAmount);\n    if (isNaN(amount) || amount <= 0) {\n      Alert.alert('Invalid Amount', 'Please enter a valid amount greater than 0');\n      return;\n    }\n\n    const totalAmount = parseFloat(event.total_amount);\n    if (amount > totalAmount) {\n      Alert.alert('Invalid Amount', 'Your share cannot exceed the total amount');\n      return;\n    }\n\n    setPaymentModalVisible(false);\n    \n    Alert.alert(\n      'Confirm Payment',\n      `Pay $${amount.toFixed(2)} for ${event.name}?\\n\\nPayment will be deducted from your wallet balance if available, otherwise from your saved card.`,\n      [\n        { \n          text: 'Cancel', \n          style: 'cancel',\n          onPress: () => setPaymentAmount('')\n        },\n        {\n          text: 'Confirm',\n          onPress: async () => {\n            setPaymentProcessing(true);\n            try {\n              await SplitsService.updateParticipantAmount(user.id, eventId, amount);\n              \n              // paySplitEvent now atomically handles wallet deduction AND split status update\n              const result = await WalletService.paySplitEvent(\n                user.id,\n                eventId,\n                amount,\n                event.creator_id,\n                event.name\n              );\n              \n              // Check if user leveled up\n              if (result.xpResult) {\n                checkLevelUp(result.xpResult);\n              }\n              \n              // No need to call SplitsService.paySplit() - atomic RPC already updated status\n              setPaymentProcessing(false);\n              setPaymentAmount('');\n              Alert.alert('Payment Successful', 'Your payment has been processed');\n              loadEvent();\n            } catch (error: any) {\n              setPaymentProcessing(false);\n              console.error('Payment failed:', error);\n              if (error.message.includes('Insufficient wallet balance') || error.message.includes('Add a payment card')) {\n                Alert.alert(\n                  'Add Card Required',\n                  'You don\\'t have enough balance in your wallet. Would you like to add a payment card to complete this payment?',\n                  [\n                    { text: 'Cancel', style: 'cancel' },\n                    {\n                      text: 'Add Card',\n                      onPress: () => {\n                        // Navigate directly to WalletTab, ensuring it comes to front\n                        navigation.getParent()?.reset({\n                          index: 0,\n                          routes: [{ name: 'WalletTab' }],\n                        });\n                      }\n                    }\n                  ]\n                );\n              } else {\n                Alert.alert('Error', error.message || 'Payment failed. Please try again.');\n              }\n            }\n          }\n        }\n      ]\n    );\n  };\n\n  const getStatusColor = (status: string) => {\n    switch (status) {\n      case 'paid': return theme.success;\n      case 'declined': return theme.danger;\n      default: return theme.warning;\n    }\n  };\n\n  const getStatusText = (status: string) => {\n    switch (status) {\n      case 'paid': return 'Paid';\n      case 'declined': return 'Declined';\n      default: return 'Pending';\n    }\n  };\n\n  const calculateProgress = () => {\n    if (!event?.participants) return { paidAmount: 0, totalAmount: 0, percentage: 0 };\n    \n    const totalAmount = parseFloat(event.total_amount);\n    let paidAmount = 0;\n    \n    for (const participant of event.participants) {\n      const participantAmount = parseFloat(participant.amount) || 0;\n      \n      if (event.split_type === 'specified') {\n        if (participant.is_creator || (participant.status === 'paid' && participantAmount > 0)) {\n          paidAmount += participantAmount;\n        }\n      } else {\n        if (participant.is_creator || participant.status === 'paid') {\n          paidAmount += participantAmount;\n        }\n      }\n    }\n    \n    const percentage = totalAmount > 0 ? (paidAmount / totalAmount) * 100 : 0;\n    return { paidAmount, totalAmount, percentage };\n  };\n\n  // Get display status - creator is always \"paid\"\n  const getDisplayStatus = (participant: any) => {\n    if (participant.is_creator) return 'paid';\n    return participant.status;\n  };\n\n  if (loading) {\n    return (\n      <ThemedView style={[styles.container, { justifyContent: 'center', alignItems: 'center' }]}>\n        <ActivityIndicator size=\"large\" color={theme.primary} />\n      </ThemedView>\n    );\n  }\n\n  if (!event) {\n    return (\n      <ThemedView style={[styles.container, { justifyContent: 'center', alignItems: 'center', padding: Spacing.xl }]}>\n        <Feather name=\"alert-circle\" size={48} color={theme.textSecondary} style={{ marginBottom: Spacing.lg }} />\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, textAlign: 'center' }]}>\n          Event not found\n        </ThemedText>\n      </ThemedView>\n    );\n  }\n\n  const isCreator = event.creator_id === user?.id;\n  const myParticipation = event.participants?.find((p: any) => p.user_id === user?.id);\n  const myAmount = myParticipation?.amount || 0;\n  const canRespond = myParticipation && myParticipation.status === 'pending' && !isCreator;\n  const canPay = myParticipation && myParticipation.status === 'accepted' && !isCreator;\n\n  return (\n    <ThemedView style={styles.container}>\n      <LoadingOverlay visible={paymentProcessing} message=\"Processing payment...\" fullScreen />\n      <ScrollView \n        style={styles.scrollView}\n        contentContainerStyle={[\n          styles.content,\n          { \n            paddingTop: Math.max(headerHeight, insets.top + 56) + Spacing.md,\n            paddingBottom: tabBarHeight + Spacing.xl \n          }\n        ]}\n      >\n        <View style={[styles.summary, { backgroundColor: theme.surface, borderColor: theme.border }]}>\n          {isCreator ? (\n            <View style={[styles.initiatorBadge, { backgroundColor: theme.primary }]}>\n              <ThemedText style={[Typography.caption, { color: '#FFFFFF' }]}>\n                You are the creator\n              </ThemedText>\n            </View>\n          ) : (\n            <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n              Created by {event.creator?.name || 'Unknown'}\n            </ThemedText>\n          )}\n\n          <ThemedText style={[Typography.h1, { color: theme.text, marginTop: Spacing.md, marginBottom: Spacing.sm }]}>\n            {event.name}\n          </ThemedText>\n\n          <ThemedText style={[Typography.hero, { color: theme.text }]}>\n            ${parseFloat(event.total_amount).toFixed(2)}\n          </ThemedText>\n          {event.split_type === 'specified' && parseFloat(myAmount) === 0 && !isCreator ? (\n            <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n              Your share: Enter after accepting\n            </ThemedText>\n          ) : (\n            <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n              Your share: ${parseFloat(myAmount).toFixed(2)}\n            </ThemedText>\n          )}\n\n          {(() => {\n            const { paidAmount, totalAmount, percentage } = calculateProgress();\n            return (\n              <View style={styles.progressSection}>\n                <View style={styles.progressHeader}>\n                  <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                    Payment Progress\n                  </ThemedText>\n                  <ThemedText style={[Typography.caption, { color: theme.text, fontWeight: '600' }]}>\n                    ${paidAmount.toFixed(2)} / ${totalAmount.toFixed(2)}\n                  </ThemedText>\n                </View>\n                <View style={[styles.progressBar, { backgroundColor: theme.backgroundSecondary }]}>\n                  <View \n                    style={[\n                      styles.progressFill, \n                      { \n                        backgroundColor: theme.success,\n                        width: `${Math.min(percentage, 100)}%`\n                      }\n                    ]} \n                  />\n                </View>\n                <ThemedText style={[Typography.small, { color: theme.success, textAlign: 'right', marginTop: 4 }]}>\n                  {percentage.toFixed(0)}% collected\n                </ThemedText>\n              </View>\n            );\n          })()}\n        </View>\n\n        {event.receipt_image ? (\n          <View style={styles.receiptSection}>\n            <ThemedText style={[Typography.h2, { color: theme.text, marginBottom: Spacing.md }]}>\n              Receipt\n            </ThemedText>\n            <Pressable onPress={() => setImageVisible(true)}>\n              <Image \n                source={{ uri: event.receipt_image }} \n                style={[styles.receiptImage, { borderColor: theme.border }]}\n              />\n              <View style={styles.zoomHint}>\n                <Feather name=\"maximize-2\" size={16} color={theme.textSecondary} />\n                <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginLeft: Spacing.xs }]}>\n                  Tap to enlarge\n                </ThemedText>\n              </View>\n            </Pressable>\n          </View>\n        ) : null}\n\n        <View style={styles.participantsSection}>\n          <ThemedText style={[Typography.h2, { color: theme.text, marginBottom: Spacing.md }]}>\n            Participants\n          </ThemedText>\n\n          {event.participants?.map((participant: any) => {\n            const isCurrentUser = participant.user_id === user?.id;\n            const isFriend = friendIds.has(participant.user_id);\n            const isPending = pendingIds.has(participant.user_id);\n            const showAddFriend = !isCurrentUser && !isFriend && !isPending;\n            const isAdding = addingFriend === participant.user_id;\n            \n            const isSpecifiedSplit = event.split_type === 'specified';\n            const participantAmount = parseFloat(participant.amount) || 0;\n            const hasEnteredAmount = participant.is_creator || participantAmount > 0;\n            const showAmount = !isSpecifiedSplit || hasEnteredAmount;\n            \n            return (\n              <Pressable\n                key={participant.user_id}\n                onPress={() => handleParticipantPress(participant)}\n                style={({ pressed }) => [\n                  styles.participantCard, \n                  { backgroundColor: theme.surface, borderColor: theme.border, opacity: pressed ? 0.8 : 1 }\n                ]}\n              >\n                <View style={[styles.avatarLarge, { backgroundColor: theme.backgroundSecondary }]}>\n                  {participant.user?.profile_picture ? (\n                    <Image source={{ uri: participant.user.profile_picture }} style={styles.avatarImage} />\n                  ) : (\n                    <Feather name=\"user\" size={24} color={theme.textSecondary} />\n                  )}\n                </View>\n                <View style={styles.participantInfo}>\n                  <View style={styles.participantNameRow}>\n                    <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n                      {participant.user?.name || 'Unknown'}\n                    </ThemedText>\n                    {isCurrentUser ? (\n                      <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}> (You)</ThemedText>\n                    ) : null}\n                    {participantGamification[participant.user_id]?.level ? (\n                      <LevelBadge \n                        level={participantGamification[participant.user_id]!.level} \n                        variant=\"pill\"\n                      />\n                    ) : null}\n                  </View>\n                  <ThemedText style={[Typography.small, { color: theme.textSecondary }]}>\n                    ID: {participant.user?.unique_id || 'N/A'}\n                  </ThemedText>\n                  <View style={styles.participantSubRow}>\n                    {showAmount ? (\n                      <ThemedText style={[Typography.caption, { color: theme.primary, fontWeight: '600' }]}>\n                        ${participantAmount.toFixed(2)}\n                      </ThemedText>\n                    ) : (\n                      <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                        Awaiting entry\n                      </ThemedText>\n                    )}\n                    {isPending ? (\n                      <View style={[styles.pendingBadge, { backgroundColor: theme.warning + '20' }]}>\n                        <Feather name=\"clock\" size={12} color={theme.warning} />\n                        <ThemedText style={[Typography.small, { color: theme.warning, marginLeft: 4 }]}>\n                          Pending\n                        </ThemedText>\n                      </View>\n                    ) : showAddFriend ? (\n                      <Pressable\n                        style={({ pressed }) => [\n                          styles.addFriendBtn,\n                          { \n                            backgroundColor: theme.primary + '15',\n                            opacity: pressed || isAdding ? 0.6 : 1\n                          }\n                        ]}\n                        onPress={() => handleAddFriend(participant.user_id)}\n                        disabled={isAdding}\n                      >\n                        <Feather \n                          name={isAdding ? \"loader\" : \"user-plus\"} \n                          size={12} \n                          color={theme.primary} \n                        />\n                        <ThemedText style={[Typography.small, { color: theme.primary, marginLeft: 4 }]}>\n                          {isAdding ? 'Sending...' : 'Add Friend'}\n                        </ThemedText>\n                      </Pressable>\n                    ) : null}\n                  </View>\n                </View>\n                <View \n                  style={[\n                    styles.statusBadge,\n                    { backgroundColor: getStatusColor(getDisplayStatus(participant)) }\n                  ]}\n                >\n                  <ThemedText style={[Typography.small, { color: '#FFFFFF' }]}>\n                    {getStatusText(getDisplayStatus(participant))}\n                  </ThemedText>\n                </View>\n              </Pressable>\n            );\n          })}\n        </View>\n\n        {canRespond ? (\n          <View style={styles.actionButtons}>\n            <Pressable\n              style={({ pressed }) => [\n                styles.declineButton,\n                { borderColor: theme.danger, opacity: pressed ? 0.7 : 1 }\n              ]}\n              onPress={handleDecline}\n            >\n              <ThemedText style={[Typography.body, { color: theme.danger, fontWeight: '600' }]}>\n                Decline\n              </ThemedText>\n            </Pressable>\n            <Pressable\n              style={({ pressed }) => [\n                styles.acceptButton,\n                { backgroundColor: theme.success, opacity: pressed ? 0.7 : 1 }\n              ]}\n              onPress={handleAccept}\n            >\n              <ThemedText style={[Typography.body, { color: '#FFFFFF', fontWeight: '600' }]}>\n                Accept\n              </ThemedText>\n            </Pressable>\n          </View>\n        ) : canPay ? (\n          <Pressable\n            style={({ pressed }) => [\n              styles.payButton,\n              { backgroundColor: theme.primary, opacity: pressed ? 0.7 : 1 }\n            ]}\n            onPress={handlePayment}\n          >\n            <ThemedText style={[Typography.body, { color: '#FFFFFF', fontWeight: '600' }]}>\n              {event?.split_type === 'specified' && parseFloat(myAmount) === 0\n                ? 'Pay'\n                : `Pay $${parseFloat(myAmount).toFixed(2)}`}\n            </ThemedText>\n          </Pressable>\n        ) : null}\n      </ScrollView>\n\n      <Modal\n        visible={imageVisible}\n        transparent\n        animationType=\"fade\"\n        onRequestClose={() => setImageVisible(false)}\n      >\n        <Pressable\n          style={styles.modalOverlay}\n          onPress={() => setImageVisible(false)}\n        >\n          <View style={styles.modalContent}>\n            <Pressable\n              style={[styles.closeButton, { backgroundColor: theme.backgroundRoot }]}\n              onPress={() => setImageVisible(false)}\n            >\n              <Feather name=\"x\" size={24} color={theme.text} />\n            </Pressable>\n            {event?.receipt_image ? (\n              <Image \n                source={{ uri: event.receipt_image }} \n                style={styles.fullImage}\n                resizeMode=\"contain\"\n              />\n            ) : null}\n          </View>\n        </Pressable>\n      </Modal>\n\n      <Modal\n        visible={amountModalVisible}\n        transparent\n        animationType=\"fade\"\n        onRequestClose={() => setAmountModalVisible(false)}\n      >\n        <View style={styles.modalOverlay}>\n          <View style={[styles.amountModalContent, { backgroundColor: theme.backgroundRoot }]}>\n            <ThemedText style={[Typography.h2, { color: theme.text, marginBottom: Spacing.md }]}>\n              Enter Your Share\n            </ThemedText>\n            <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing.lg }]}>\n              How much are you paying for this split?\n            </ThemedText>\n            <TextInput\n              style={[styles.amountInput, { \n                backgroundColor: theme.surface, \n                color: theme.text, \n                borderColor: theme.border \n              }]}\n              placeholder=\"0.00\"\n              placeholderTextColor={theme.textSecondary}\n              value={customAmount}\n              onChangeText={setCustomAmount}\n              keyboardType=\"decimal-pad\"\n              autoFocus\n            />\n            <View style={styles.amountModalButtons}>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.modalCancelButton,\n                  { borderColor: theme.border, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={() => {\n                  setAmountModalVisible(false);\n                  setCustomAmount('');\n                }}\n              >\n                <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n                  Cancel\n                </ThemedText>\n              </Pressable>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.modalConfirmButton,\n                  { backgroundColor: theme.success, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={handleAcceptWithAmount}\n              >\n                <ThemedText style={[Typography.body, { color: '#FFFFFF', fontWeight: '600' }]}>\n                  Accept\n                </ThemedText>\n              </Pressable>\n            </View>\n          </View>\n        </View>\n      </Modal>\n\n      <Modal\n        visible={paymentModalVisible}\n        transparent\n        animationType=\"fade\"\n        onRequestClose={() => setPaymentModalVisible(false)}\n      >\n        <View style={styles.modalOverlay}>\n          <View style={[styles.amountModalContent, { backgroundColor: theme.backgroundRoot }]}>\n            <ThemedText style={[Typography.h2, { color: theme.text, marginBottom: Spacing.md }]}>\n              Enter Payment Amount\n            </ThemedText>\n            <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing.lg }]}>\n              How much are you paying for this split?\n            </ThemedText>\n            <TextInput\n              style={[styles.amountInput, { \n                backgroundColor: theme.surface, \n                color: theme.text, \n                borderColor: theme.border \n              }]}\n              placeholder=\"0.00\"\n              placeholderTextColor={theme.textSecondary}\n              value={paymentAmount}\n              onChangeText={setPaymentAmount}\n              keyboardType=\"decimal-pad\"\n              autoFocus\n            />\n            <View style={styles.amountModalButtons}>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.modalCancelButton,\n                  { borderColor: theme.border, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={() => {\n                  setPaymentModalVisible(false);\n                  setPaymentAmount('');\n                }}\n              >\n                <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n                  Cancel\n                </ThemedText>\n              </Pressable>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.modalConfirmButton,\n                  { backgroundColor: theme.primary, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={handlePaymentWithAmount}\n              >\n                <ThemedText style={[Typography.body, { color: '#FFFFFF', fontWeight: '600' }]}>\n                  Pay\n                </ThemedText>\n              </Pressable>\n            </View>\n          </View>\n        </View>\n      </Modal>\n\n      <FriendProfileModal\n        visible={participantModalVisible}\n        onClose={() => setParticipantModalVisible(false)}\n        friend={selectedParticipant}\n      />\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  scrollView: {\n    flex: 1,\n  },\n  content: {\n    padding: Spacing.xl,\n  },\n  summary: {\n    padding: Spacing.xl,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    marginBottom: Spacing.xl,\n    alignItems: 'center',\n  },\n  initiatorBadge: {\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.xs,\n    borderRadius: BorderRadius.xs,\n  },\n  receiptSection: {\n    marginBottom: Spacing.xl,\n  },\n  receiptImage: {\n    width: '100%',\n    height: 300,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n  },\n  zoomHint: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginTop: Spacing.sm,\n    justifyContent: 'center',\n  },\n  participantsSection: {\n    marginBottom: Spacing.xl,\n  },\n  participantCard: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    marginBottom: Spacing.md,\n  },\n  avatar: {\n    width: Spacing.avatarMedium,\n    height: Spacing.avatarMedium,\n    borderRadius: Spacing.avatarMedium / 2,\n    justifyContent: 'center',\n    alignItems: 'center',\n    overflow: 'hidden',\n  },\n  avatarLarge: {\n    width: 52,\n    height: 52,\n    borderRadius: 26,\n    justifyContent: 'center',\n    alignItems: 'center',\n    overflow: 'hidden',\n  },\n  avatarImage: {\n    width: '100%',\n    height: '100%',\n  },\n  progressSection: {\n    width: '100%',\n    marginTop: Spacing.lg,\n    paddingTop: Spacing.lg,\n    borderTopWidth: 1,\n    borderTopColor: 'rgba(0,0,0,0.1)',\n  },\n  progressHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: Spacing.sm,\n  },\n  progressBar: {\n    height: 8,\n    borderRadius: 4,\n    overflow: 'hidden',\n  },\n  progressFill: {\n    height: '100%',\n    borderRadius: 4,\n  },\n  participantInfo: {\n    flex: 1,\n    marginLeft: Spacing.md,\n  },\n  participantNameRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    flexWrap: 'wrap',\n    gap: Spacing.xs,\n  },\n  participantSubRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: Spacing.md,\n    marginTop: 2,\n  },\n  addFriendBtn: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.sm,\n    paddingVertical: 2,\n    borderRadius: BorderRadius.xs,\n  },\n  pendingBadge: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.sm,\n    paddingVertical: 2,\n    borderRadius: BorderRadius.xs,\n  },\n  statusBadge: {\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.xs,\n    borderRadius: BorderRadius.xs,\n  },\n  actionButtons: {\n    flexDirection: 'row',\n    gap: Spacing.md,\n    marginTop: Spacing.lg,\n  },\n  declineButton: {\n    flex: 1,\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderWidth: 2,\n  },\n  acceptButton: {\n    flex: 1,\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  payButton: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginTop: Spacing.lg,\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: 'rgba(0,0,0,0.9)',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  modalContent: {\n    width: '100%',\n    height: '100%',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  closeButton: {\n    position: 'absolute',\n    top: 50,\n    right: 20,\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 10,\n  },\n  fullImage: {\n    width: '100%',\n    height: '100%',\n  },\n  amountModalContent: {\n    width: '85%',\n    padding: Spacing.xl,\n    borderRadius: BorderRadius.sm,\n    alignItems: 'center',\n  },\n  amountInput: {\n    width: '100%',\n    height: 56,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    fontSize: 24,\n    textAlign: 'center',\n  },\n  amountModalButtons: {\n    flexDirection: 'row',\n    gap: Spacing.md,\n    marginTop: Spacing.xl,\n    width: '100%',\n  },\n  modalCancelButton: {\n    flex: 1,\n    height: 48,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderWidth: 1,\n  },\n  modalConfirmButton: {\n    flex: 1,\n    height: 48,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":38827,"size_tokens":null},"screens/AddFriendScreen.tsx":{"content":"import React, { useState } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, Alert } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { FriendsService } from '@/services/friends.service';\n\ntype Props = NativeStackScreenProps<any, 'AddFriend'>;\n\nexport default function AddFriendScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n  const { user } = useAuth();\n  const [uniqueId, setUniqueId] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [errorMessage, setErrorMessage] = useState<string | null>(null);\n\n  const handleAddFriend = async () => {\n    setErrorMessage(null);\n    \n    if (!user?.id) {\n      setErrorMessage('Please log in to add friends');\n      Alert.alert('Error', 'Please log in to add friends');\n      return;\n    }\n\n    if (uniqueId.length < 5 || uniqueId.length > 10) {\n      setErrorMessage('Unique ID must be between 5-10 digits');\n      Alert.alert('Invalid ID', 'Unique ID must be between 5-10 digits');\n      return;\n    }\n\n    if (uniqueId === user?.unique_id) {\n      setErrorMessage('You cannot add yourself as a friend');\n      Alert.alert('Invalid ID', 'You cannot add yourself as a friend');\n      return;\n    }\n\n    setLoading(true);\n\n    try {\n      await FriendsService.addFriend(user.id, uniqueId);\n      setLoading(false);\n\n      Alert.alert(\n        'Request Sent!',\n        'Friend request has been sent. They will appear in your friends list once they accept.',\n        [{ text: 'OK', onPress: () => navigation.goBack() }]\n      );\n    } catch (error: any) {\n      setLoading(false);\n      const message = error?.message || 'Failed to send friend request';\n      console.error('Add friend error:', message);\n      setErrorMessage(message);\n      Alert.alert('Error', message);\n    }\n  };\n\n  const isValidId = /^\\d{5,10}$/.test(uniqueId);\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.h1, { color: theme.text, marginBottom: Spacing.md }]}>\n          Add Friend\n        </ThemedText>\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing.xl }]}>\n          Enter your friend's unique ID to add them\n        </ThemedText>\n\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: theme.border \n          }]}\n          placeholder=\"Enter 5-10 digit ID\"\n          placeholderTextColor={theme.textSecondary}\n          value={uniqueId}\n          onChangeText={setUniqueId}\n          keyboardType=\"number-pad\"\n          autoFocus\n          maxLength={10}\n        />\n\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginTop: Spacing.sm }]}>\n          Only numeric IDs between 5-10 digits are valid\n        </ThemedText>\n\n        {errorMessage ? (\n          <ThemedText style={[Typography.body, { color: theme.danger, marginTop: Spacing.lg, textAlign: 'center' }]}>\n            {errorMessage}\n          </ThemedText>\n        ) : null}\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed ? 0.7 : (!isValidId || loading ? 0.4 : 1)\n            }\n          ]}\n          onPress={handleAddFriend}\n          disabled={!isValidId || loading}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            {loading ? 'Adding...' : 'Add Friend'}\n          </ThemedText>\n        </Pressable>\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  input: {\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    fontSize: 16,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":4732,"size_tokens":null},"components/ThemedView.tsx":{"content":"import { View, type ViewProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\n\nexport type ThemedViewProps = ViewProps & {\n  lightColor?: string;\n  darkColor?: string;\n};\n\nexport function ThemedView({\n  style,\n  lightColor,\n  darkColor,\n  ...otherProps\n}: ThemedViewProps) {\n  const { theme, isDark } = useTheme();\n\n  const backgroundColor =\n    isDark && darkColor\n      ? darkColor\n      : !isDark && lightColor\n        ? lightColor\n        : theme.backgroundRoot;\n\n  return <View style={[{ backgroundColor }, style]} {...otherProps} />;\n}\n","path":null,"size_bytes":563,"size_tokens":null},"components/ScreenKeyboardAwareScrollView.tsx":{"content":"import { Platform, StyleSheet } from \"react-native\";\nimport {\n  KeyboardAwareScrollView,\n  KeyboardAwareScrollViewProps,\n} from \"react-native-keyboard-controller\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useScreenInsets } from \"@/hooks/useScreenInsets\";\nimport { Spacing } from \"@/constants/theme\";\nimport { ScreenScrollView } from \"./ScreenScrollView\";\n\nexport function ScreenKeyboardAwareScrollView({\n  children,\n  contentContainerStyle,\n  style,\n  keyboardShouldPersistTaps = \"handled\",\n  ...scrollViewProps\n}: KeyboardAwareScrollViewProps) {\n  const { theme } = useTheme();\n  const { paddingTop, paddingBottom, scrollInsetBottom } = useScreenInsets();\n\n  /**\n   * KeyboardAwareScrollView isn't compatible with web (it relies on native APIs), so the code falls back to ScreenScrollView on web to avoid runtime errors.\n   */\n  if (Platform.OS === \"web\") {\n    return (\n      <ScreenScrollView\n        style={style}\n        contentContainerStyle={contentContainerStyle}\n        keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n        {...scrollViewProps}\n      >\n        {children}\n      </ScreenScrollView>\n    );\n  }\n\n  return (\n    <KeyboardAwareScrollView\n      style={[\n        styles.container,\n        { backgroundColor: theme.backgroundRoot },\n        style,\n      ]}\n      contentContainerStyle={[\n        {\n          paddingTop,\n          paddingBottom,\n        },\n        styles.contentContainer,\n        contentContainerStyle,\n      ]}\n      scrollIndicatorInsets={{ bottom: scrollInsetBottom }}\n      keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n      {...scrollViewProps}\n    >\n      {children}\n    </KeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  contentContainer: {\n    paddingHorizontal: Spacing.xl,\n  },\n});\n","path":null,"size_bytes":1813,"size_tokens":null},"screens/FriendsScreen.tsx":{"content":"import React, { useState, useEffect, useCallback } from 'react';\nimport { View, StyleSheet, Pressable, FlatList, Image, TextInput, RefreshControl, Alert, ScrollView } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { LevelBadge } from '@/components/ProfileStatsCard';\nimport { FriendProfileModal } from '@/components/FriendProfileModal';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { FriendsService } from '@/services/friends.service';\nimport { GamificationService } from '@/services/gamification.service';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { useSafeBottomTabBarHeight } from '@/hooks/useSafeBottomTabBarHeight';\nimport type { BlockedUser } from '@/shared/types';\n\ntype Props = NativeStackScreenProps<any, 'Friends'>;\n\ninterface PendingRequest {\n  id: string;\n  user_id: string;\n  friend_id: string;\n  status: string;\n  requester: {\n    id: string;\n    unique_id: string;\n    name: string;\n    email: string;\n    profile_picture?: string;\n    bio?: string;\n  };\n}\n\ninterface FriendWithDetails {\n  id: string;\n  user_id: string;\n  friend_id: string;\n  status: string;\n  friend_details: {\n    id: string;\n    unique_id: string;\n    name: string;\n    email: string;\n    profile_picture?: string;\n    bio?: string;\n  };\n  gamification?: {\n    current_level: number;\n    total_xp: number;\n  } | null;\n}\n\ninterface SentRequest {\n  id: string;\n  user_id: string;\n  friend_id: string;\n  status: string;\n  created_at: string;\n  last_reminder_at?: string;\n  recipient: {\n    id: string;\n    unique_id: string;\n    name: string;\n    email: string;\n    profile_picture?: string;\n    bio?: string;\n  };\n}\n\nconst REMINDER_COOLDOWN_HOURS = 24;\n\nfunction getResendStatus(request: SentRequest): { canResend: boolean; hoursRemaining: number } {\n  const lastSentAt = request.last_reminder_at || request.created_at;\n  const hoursSinceSent = (Date.now() - new Date(lastSentAt).getTime()) / (1000 * 60 * 60);\n  const hoursRemaining = Math.max(0, Math.ceil(REMINDER_COOLDOWN_HOURS - hoursSinceSent));\n  return {\n    canResend: hoursSinceSent >= REMINDER_COOLDOWN_HOURS,\n    hoursRemaining,\n  };\n}\n\ninterface SelectedFriend {\n  id: string;\n  name: string;\n  unique_id?: string;\n  profile_picture_url?: string;\n}\n\nexport default function FriendsScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n  const { user } = useAuth();\n  const insets = useSafeAreaInsets();\n  const tabBarHeight = useSafeBottomTabBarHeight();\n  const [friends, setFriends] = useState<FriendWithDetails[]>([]);\n  const [pendingRequests, setPendingRequests] = useState<PendingRequest[]>([]);\n  const [sentRequests, setSentRequests] = useState<SentRequest[]>([]);\n  const [blockedUsers, setBlockedUsers] = useState<BlockedUser[]>([]);\n  const [blockedUserIds, setBlockedUserIds] = useState<Set<string>>(new Set());\n  const [searchQuery, setSearchQuery] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [refreshing, setRefreshing] = useState(false);\n  const [selectedFriend, setSelectedFriend] = useState<SelectedFriend | null>(null);\n  const [profileModalVisible, setProfileModalVisible] = useState(false);\n\n  const handleFriendPress = (details: FriendWithDetails['friend_details']) => {\n    if (!details) return;\n    setSelectedFriend({\n      id: details.id,\n      name: details.name,\n      unique_id: details.unique_id,\n      profile_picture_url: details.profile_picture,\n    });\n    setProfileModalVisible(true);\n  };\n\n  const gamificationCacheRef = React.useRef<Map<string, { current_level: number; total_xp: number } | null>>(new Map());\n\n  const loadData = useCallback(async (showLoading = true, skipGamification = false) => {\n    if (!user?.id) return;\n    \n    try {\n      if (showLoading) setLoading(true);\n      const [friendsData, requestsData, sentData, blockedData] = await Promise.all([\n        FriendsService.getFriends(user.id),\n        FriendsService.getPendingRequests(user.id),\n        FriendsService.getSentPendingRequests(user.id),\n        FriendsService.getBlockedUsers(user.id).catch(() => []),\n      ]);\n      \n      const blockedIds = new Set(blockedData.map(b => b.blocked_user_id));\n      setBlockedUsers(blockedData);\n      setBlockedUserIds(blockedIds);\n      \n      let friendsWithGamification: FriendWithDetails[];\n      \n      if (skipGamification) {\n        friendsWithGamification = (friendsData as FriendWithDetails[]).map((friend) => {\n          const cachedGamification = gamificationCacheRef.current.get(friend.friend_details.id);\n          return { ...friend, gamification: cachedGamification || null };\n        });\n      } else {\n        friendsWithGamification = await Promise.all(\n          (friendsData as FriendWithDetails[]).map(async (friend) => {\n            try {\n              const gamification = await GamificationService.getProfile(friend.friend_details.id);\n              gamificationCacheRef.current.set(friend.friend_details.id, gamification);\n              return { ...friend, gamification };\n            } catch {\n              return { ...friend, gamification: null };\n            }\n          })\n        );\n      }\n      \n      setFriends(friendsWithGamification);\n      setPendingRequests(requestsData as unknown as PendingRequest[]);\n      setSentRequests(sentData as unknown as SentRequest[]);\n    } catch (error) {\n      console.error('Failed to load friends:', error);\n    } finally {\n      if (showLoading) setLoading(false);\n    }\n  }, [user?.id]);\n\n  useEffect(() => {\n    loadData();\n    const unsubscribe = navigation.addListener('focus', loadData);\n    return unsubscribe;\n  }, [navigation, loadData]);\n\n  // Subscribe to realtime updates for friend requests\n  useEffect(() => {\n    if (!user?.id) return;\n\n    console.log('[FriendsScreen] Setting up realtime subscription for user:', user.id);\n    const subscription = FriendsService.subscribeToFriendUpdates(\n      user.id,\n      () => {\n        console.log('[FriendsScreen] Realtime update received, refreshing data (using cached gamification)');\n        loadData(false, true);\n      }\n    );\n\n    return () => {\n      console.log('[FriendsScreen] Cleaning up realtime subscription');\n      subscription.unsubscribe();\n    };\n  }, [user?.id, loadData]);\n\n  const onRefresh = async () => {\n    setRefreshing(true);\n    await loadData();\n    setRefreshing(false);\n  };\n\n  const handleAcceptRequest = async (requestId: string) => {\n    if (!user?.id) return;\n    try {\n      await FriendsService.acceptFriendRequest(user.id, requestId);\n      loadData();\n    } catch (error: any) {\n      Alert.alert('Error', error.message || 'Failed to accept request');\n    }\n  };\n\n  const handleDeclineRequest = async (requestId: string) => {\n    if (!user?.id) return;\n    try {\n      await FriendsService.declineFriendRequest(user.id, requestId);\n      loadData();\n    } catch (error: any) {\n      Alert.alert('Error', error.message || 'Failed to decline request');\n    }\n  };\n\n  const handleResendRequest = async (request: SentRequest) => {\n    if (!user?.id || !request.recipient?.unique_id) return;\n    \n    const { canResend, hoursRemaining } = getResendStatus(request);\n    if (!canResend) {\n      Alert.alert('Please Wait', `You can resend in ${hoursRemaining} hour${hoursRemaining !== 1 ? 's' : ''}`);\n      return;\n    }\n    \n    try {\n      await FriendsService.sendFriendRequest(user.id, request.recipient.unique_id);\n      Alert.alert('Success', 'Reminder sent successfully!');\n      loadData();\n    } catch (error: any) {\n      Alert.alert('Error', error.message || 'Failed to resend request');\n    }\n  };\n\n  const handleUnblock = async (blockedUserId: string, userName: string) => {\n    if (!user?.id) return;\n    \n    Alert.alert(\n      'Unblock User',\n      `Are you sure you want to unblock ${userName}?`,\n      [\n        { text: 'Cancel', style: 'cancel' },\n        {\n          text: 'Unblock',\n          onPress: async () => {\n            try {\n              await FriendsService.unblockUser(user.id, blockedUserId);\n              Alert.alert('Success', `${userName} has been unblocked`);\n              loadData();\n            } catch (error: any) {\n              Alert.alert('Error', error.message || 'Failed to unblock user');\n            }\n          },\n        },\n      ]\n    );\n  };\n\n  const filteredFriends = friends.filter(f => {\n    const friendId = f.friend_details?.id || '';\n    if (blockedUserIds.has(friendId)) return false;\n    const name = f.friend_details?.name || '';\n    const uniqueId = f.friend_details?.unique_id || '';\n    return name.toLowerCase().includes(searchQuery.toLowerCase()) ||\n      uniqueId.includes(searchQuery);\n  });\n\n  const filteredPendingRequests = pendingRequests.filter(r => {\n    return !blockedUserIds.has(r.requester?.id || '');\n  });\n\n  const filteredSentRequests = sentRequests.filter(r => {\n    return !blockedUserIds.has(r.recipient?.id || '');\n  });\n\n  const renderFriend = ({ item }: { item: FriendWithDetails }) => {\n    const details = item.friend_details;\n    if (!details) return null;\n    \n    return (\n      <View style={[styles.friendCard, { borderBottomColor: theme.border }]}>\n        <View style={[styles.avatar, { backgroundColor: theme.backgroundSecondary }]}>\n          {details.profile_picture ? (\n            <Image source={{ uri: details.profile_picture }} style={styles.avatarImage} />\n          ) : (\n            <Feather name=\"user\" size={24} color={theme.textSecondary} />\n          )}\n        </View>\n        <View style={styles.friendInfo}>\n          <View style={styles.friendNameRow}>\n            <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n              {details.name}\n            </ThemedText>\n            {item.gamification?.current_level ? (\n              <LevelBadge level={item.gamification.current_level} size=\"small\" showTitle />\n            ) : null}\n          </View>\n          <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n            ID: {details.unique_id}\n          </ThemedText>\n        </View>\n      </View>\n    );\n  };\n\n  const renderPendingRequest = (request: PendingRequest) => {\n    const requester = request.requester;\n    const requesterName = requester?.name || 'Someone';\n    const requesterPicture = requester?.profile_picture;\n    \n    return (\n      <View \n        key={request.id} \n        style={[styles.requestCard, { backgroundColor: theme.surface, borderColor: theme.border }]}\n      >\n        <View style={[styles.avatar, { backgroundColor: theme.backgroundSecondary }]}>\n          {requesterPicture ? (\n            <Image source={{ uri: requesterPicture }} style={styles.avatarImage} />\n          ) : (\n            <Feather name=\"user\" size={24} color={theme.textSecondary} />\n          )}\n        </View>\n        <View style={styles.friendInfo}>\n          <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n            {requesterName}\n          </ThemedText>\n          <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n            Wants to be your friend\n          </ThemedText>\n        </View>\n        <View style={styles.requestActions}>\n          <Pressable\n            style={({ pressed }) => [\n              styles.declineBtn,\n              { borderColor: theme.danger, opacity: pressed ? 0.7 : 1 }\n            ]}\n            onPress={() => handleDeclineRequest(request.id)}\n          >\n            <Feather name=\"x\" size={18} color={theme.danger} />\n          </Pressable>\n          <Pressable\n            style={({ pressed }) => [\n              styles.acceptBtn,\n              { backgroundColor: theme.success, opacity: pressed ? 0.7 : 1 }\n            ]}\n            onPress={() => handleAcceptRequest(request.id)}\n          >\n            <Feather name=\"check\" size={18} color=\"#FFFFFF\" />\n          </Pressable>\n        </View>\n      </View>\n    );\n  };\n\n  const renderSentRequest = (request: SentRequest) => {\n    const recipient = request.recipient;\n    const recipientName = recipient?.name || 'Someone';\n    const recipientPicture = recipient?.profile_picture;\n    const { canResend, hoursRemaining } = getResendStatus(request);\n    \n    return (\n      <View \n        key={request.id} \n        style={[styles.requestCard, { backgroundColor: theme.surface, borderColor: theme.border }]}\n      >\n        <View style={[styles.avatar, { backgroundColor: theme.backgroundSecondary }]}>\n          {recipientPicture ? (\n            <Image source={{ uri: recipientPicture }} style={styles.avatarImage} />\n          ) : (\n            <Feather name=\"user\" size={24} color={theme.textSecondary} />\n          )}\n        </View>\n        <View style={styles.friendInfo}>\n          <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n            {recipientName}\n          </ThemedText>\n          <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n            ID: {recipient?.unique_id}\n          </ThemedText>\n        </View>\n        <View style={styles.sentRequestActions}>\n          <Pressable\n            style={({ pressed }) => [\n              styles.resendBtn,\n              { \n                backgroundColor: canResend ? theme.primary : theme.backgroundSecondary,\n                opacity: pressed ? 0.7 : 1 \n              }\n            ]}\n            onPress={() => handleResendRequest(request)}\n          >\n            <Feather \n              name=\"send\" \n              size={14} \n              color={canResend ? '#FFFFFF' : theme.textSecondary} \n            />\n            <ThemedText \n              style={[\n                Typography.caption, \n                { \n                  color: canResend ? '#FFFFFF' : theme.textSecondary, \n                  fontWeight: '600',\n                  marginLeft: 4 \n                }\n              ]}\n            >\n              {canResend ? 'Resend' : `${hoursRemaining}h`}\n            </ThemedText>\n          </Pressable>\n        </View>\n      </View>\n    );\n  };\n\n  return (\n    <ThemedView style={[styles.container, { paddingTop: insets.top + Spacing.xl }]}>\n      <View style={styles.header}>\n        <ThemedText style={[Typography.h1, { color: theme.text }]}>Friends</ThemedText>\n        <Pressable\n          style={({ pressed }) => [\n            styles.addButton,\n            { backgroundColor: theme.primary, opacity: pressed ? 0.7 : 1 }\n          ]}\n          onPress={() => navigation.navigate('AddFriend')}\n        >\n          <Feather name=\"user-plus\" size={20} color=\"#FFFFFF\" />\n        </Pressable>\n      </View>\n\n      <View style={[styles.searchBar, { backgroundColor: theme.surface, borderColor: theme.border }]}>\n        <Feather name=\"search\" size={20} color={theme.textSecondary} />\n        <TextInput\n          style={[styles.searchInput, { color: theme.text }]}\n          placeholder=\"Search by name or ID\"\n          placeholderTextColor={theme.textSecondary}\n          value={searchQuery}\n          onChangeText={setSearchQuery}\n        />\n      </View>\n\n      <ScrollView\n        refreshControl={\n          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />\n        }\n        contentContainerStyle={[\n          styles.listContent,\n          { paddingBottom: tabBarHeight + Spacing.xl + Spacing.fabSize }\n        ]}\n      >\n        {filteredPendingRequests.length > 0 ? (\n          <View style={styles.section}>\n            <ThemedText style={[Typography.h2, { color: theme.text, marginBottom: Spacing.md }]}>\n              Friend Requests ({filteredPendingRequests.length})\n            </ThemedText>\n            {filteredPendingRequests.map(renderPendingRequest)}\n          </View>\n        ) : null}\n\n        {filteredSentRequests.length > 0 ? (\n          <View style={styles.section}>\n            <ThemedText style={[Typography.h2, { color: theme.text, marginBottom: Spacing.md }]}>\n              Sent Requests ({filteredSentRequests.length})\n            </ThemedText>\n            {filteredSentRequests.map(renderSentRequest)}\n          </View>\n        ) : null}\n\n        {filteredFriends.length > 0 ? (\n          <View style={styles.section}>\n            {(filteredPendingRequests.length > 0 || filteredSentRequests.length > 0) ? (\n              <ThemedText style={[Typography.h2, { color: theme.text, marginBottom: Spacing.md }]}>\n                Your Friends ({filteredFriends.length})\n              </ThemedText>\n            ) : null}\n            {filteredFriends.map((item) => {\n              const details = item.friend_details;\n              if (!details) return null;\n              \n              return (\n                <Pressable \n                  key={item.id} \n                  onPress={() => handleFriendPress(details)}\n                  style={({ pressed }) => [\n                    styles.friendCard, \n                    { borderBottomColor: theme.border, opacity: pressed ? 0.7 : 1 }\n                  ]}\n                >\n                  <View style={[styles.avatar, { backgroundColor: theme.backgroundSecondary }]}>\n                    {details.profile_picture ? (\n                      <Image source={{ uri: details.profile_picture }} style={styles.avatarImage} />\n                    ) : (\n                      <Feather name=\"user\" size={24} color={theme.textSecondary} />\n                    )}\n                  </View>\n                  <View style={styles.friendInfo}>\n                    <View style={styles.friendNameRow}>\n                      <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n                        {details.name}\n                      </ThemedText>\n                      {item.gamification?.current_level ? (\n                        <LevelBadge level={item.gamification.current_level} size=\"small\" showTitle />\n                      ) : null}\n                    </View>\n                    <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                      ID: {details.unique_id}\n                    </ThemedText>\n                  </View>\n                  <Feather name=\"chevron-right\" size={20} color={theme.textSecondary} />\n                </Pressable>\n              );\n            })}\n          </View>\n        ) : null}\n\n        {blockedUsers.length > 0 ? (\n          <View style={styles.section}>\n            <ThemedText style={[Typography.h2, { color: theme.text, marginBottom: Spacing.md }]}>\n              Blocked Users ({blockedUsers.length})\n            </ThemedText>\n            {blockedUsers.map((blockedUser) => {\n              const details = blockedUser.blocked_user;\n              if (!details) return null;\n              \n              return (\n                <View \n                  key={blockedUser.id} \n                  style={[styles.requestCard, { backgroundColor: theme.surface, borderColor: theme.border }]}\n                >\n                  <View style={[styles.avatar, { backgroundColor: theme.backgroundSecondary }]}>\n                    {details.profile_picture ? (\n                      <Image source={{ uri: details.profile_picture }} style={styles.avatarImage} />\n                    ) : (\n                      <Feather name=\"user\" size={24} color={theme.textSecondary} />\n                    )}\n                  </View>\n                  <View style={styles.friendInfo}>\n                    <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n                      {details.name}\n                    </ThemedText>\n                    <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                      ID: {details.unique_id}\n                    </ThemedText>\n                  </View>\n                  <Pressable\n                    style={({ pressed }) => [\n                      styles.unblockBtn,\n                      { borderColor: theme.primary, opacity: pressed ? 0.7 : 1 }\n                    ]}\n                    onPress={() => handleUnblock(blockedUser.blocked_user_id, details.name)}\n                  >\n                    <ThemedText style={[Typography.caption, { color: theme.primary, fontWeight: '600' }]}>\n                      Unblock\n                    </ThemedText>\n                  </Pressable>\n                </View>\n              );\n            })}\n          </View>\n        ) : null}\n\n        {filteredFriends.length === 0 && filteredPendingRequests.length === 0 && filteredSentRequests.length === 0 && blockedUsers.length === 0 ? (\n          <View style={styles.emptyState}>\n            <Feather name=\"users\" size={48} color={theme.textSecondary} />\n            <ThemedText style={[Typography.body, { color: theme.textSecondary, marginTop: Spacing.lg, textAlign: 'center' }]}>\n              {searchQuery ? 'No friends found' : 'Add friends using their unique ID'}\n            </ThemedText>\n            {!searchQuery ? (\n              <Pressable\n                style={({ pressed }) => [\n                  styles.emptyButton,\n                  { backgroundColor: theme.primary, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={() => navigation.navigate('AddFriend')}\n              >\n                <ThemedText style={[Typography.body, { color: '#FFFFFF', fontWeight: '600' }]}>\n                  Add Friend\n                </ThemedText>\n              </Pressable>\n            ) : null}\n          </View>\n        ) : null}\n      </ScrollView>\n\n      <FriendProfileModal\n        visible={profileModalVisible}\n        onClose={() => {\n          setProfileModalVisible(false);\n          setSelectedFriend(null);\n        }}\n        friend={selectedFriend}\n        userId={user?.id}\n        onBlock={() => {\n          setProfileModalVisible(false);\n          setSelectedFriend(null);\n          loadData();\n        }}\n      />\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.xl,\n    marginBottom: Spacing.lg,\n  },\n  addButton: {\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  searchBar: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginHorizontal: Spacing.xl,\n    marginBottom: Spacing.lg,\n    paddingHorizontal: Spacing.lg,\n    height: Spacing.inputHeight,\n    borderRadius: BorderRadius.xs,\n    borderWidth: 1,\n  },\n  searchInput: {\n    flex: 1,\n    marginLeft: Spacing.md,\n    fontSize: 16,\n  },\n  listContent: {\n    paddingHorizontal: Spacing.xl,\n  },\n  friendCard: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingVertical: Spacing.lg,\n    borderBottomWidth: 1,\n  },\n  avatar: {\n    width: Spacing.avatarMedium,\n    height: Spacing.avatarMedium,\n    borderRadius: Spacing.avatarMedium / 2,\n    justifyContent: 'center',\n    alignItems: 'center',\n    overflow: 'hidden',\n  },\n  avatarImage: {\n    width: '100%',\n    height: '100%',\n  },\n  friendInfo: {\n    flex: 1,\n    marginLeft: Spacing.md,\n  },\n  friendNameRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: Spacing.sm,\n  },\n  emptyState: {\n    alignItems: 'center',\n    paddingVertical: Spacing['2xl'] * 2,\n  },\n  emptyButton: {\n    paddingHorizontal: Spacing.xl,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.xs,\n    marginTop: Spacing.xl,\n  },\n  section: {\n    marginBottom: Spacing.xl,\n  },\n  requestCard: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    marginBottom: Spacing.md,\n  },\n  requestActions: {\n    flexDirection: 'row',\n    gap: Spacing.sm,\n  },\n  declineBtn: {\n    width: 36,\n    height: 36,\n    borderRadius: 18,\n    borderWidth: 2,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  acceptBtn: {\n    width: 36,\n    height: 36,\n    borderRadius: 18,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  pendingBadge: {\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.xs,\n    borderRadius: BorderRadius.xs,\n  },\n  sentRequestActions: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  resendBtn: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.xs,\n  },\n  unblockBtn: {\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.xs,\n    borderWidth: 1,\n  },\n});\n","path":null,"size_bytes":24738,"size_tokens":null},"hooks/useAuth.tsx":{"content":"import React, { createContext, useContext, useState, useEffect, useRef, ReactNode } from 'react';\nimport { User } from '@/shared/types';\nimport { AuthService, SignupData } from '@/services/auth.service';\nimport { generateUniqueId } from '@/utils/storage';\nimport { supabase } from '@/services/supabase';\n\ninterface AuthContextType {\n  user: User | null;\n  isLoading: boolean;\n  isSigningUp: boolean;\n  login: (email: string, password: string) => Promise<boolean>;\n  signup: (userData: SignupData) => Promise<string>;\n  logout: () => Promise<void>;\n  updateUser: (updates: Partial<User>) => Promise<void>;\n  refreshUser: () => Promise<void>;\n  setSocialSignupInProgress: (inProgress: boolean) => void;\n  clearSignupOverlay: () => void;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// Global flag to track signup state (survives re-renders and closures)\nlet globalIsSigningUp = false;\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isSigningUp, setIsSigningUp] = useState(false);\n  const userSetBySignup = useRef(false);\n  const instanceId = useRef(Date.now());\n\n  useEffect(() => {\n    console.log(`[AuthProvider ${instanceId.current}] Mounted`);\n    loadUser();\n    \n    const { data: authListener } = supabase.auth.onAuthStateChange(async (event, session) => {\n      console.log('[Auth] State changed:', event, 'globalIsSigningUp:', globalIsSigningUp, 'userSetBySignup:', userSetBySignup.current);\n      \n      // Skip ALL auth state changes during active signup\n      if (globalIsSigningUp) {\n        console.log('[Auth] Skipping - signup in progress');\n        return;\n      }\n      \n      // For SIGNED_OUT, verify there's actually no session before clearing user\n      if (event === 'SIGNED_OUT') {\n        if (userSetBySignup.current) {\n          console.log('[Auth] SIGNED_OUT but userSetBySignup is true, verifying session...');\n          const { data: { session: currentSession } } = await supabase.auth.getSession();\n          if (currentSession?.user) {\n            console.log('[Auth] Session still valid, ignoring spurious SIGNED_OUT');\n            return;\n          }\n        }\n        console.log('[Auth] Processing SIGNED_OUT - clearing user');\n        setUser(null);\n        userSetBySignup.current = false;\n      } else if (event === 'SIGNED_IN' && session?.user) {\n        if (userSetBySignup.current) {\n          console.log('[Auth] Skipping SIGNED_IN - user already set by signup');\n          return;\n        }\n        const { data: profile } = await supabase\n          .from('users')\n          .select('*')\n          .eq('id', session.user.id)\n          .single();\n        \n        if (profile) {\n          // Check if profile is complete (has phone and DOB)\n          const isProfileComplete = Boolean(profile.phone && profile.date_of_birth);\n          if (!isProfileComplete) {\n            console.log('[Auth] Profile incomplete (missing phone/DOB), not setting user - needs profile completion');\n            return;\n          }\n          setUser(profile as User);\n        }\n      } else if (event === 'TOKEN_REFRESHED' && session?.user) {\n        const { data: profile } = await supabase\n          .from('users')\n          .select('*')\n          .eq('id', session.user.id)\n          .single();\n        \n        if (profile) {\n          // Check if profile is complete (has phone and DOB)\n          const isProfileComplete = Boolean(profile.phone && profile.date_of_birth);\n          if (!isProfileComplete) {\n            console.log('[Auth] Profile incomplete on token refresh, not updating user');\n            return;\n          }\n          setUser(profile as User);\n        }\n      }\n    });\n\n    return () => {\n      console.log(`[AuthProvider ${instanceId.current}] Unmounting`);\n      authListener?.subscription?.unsubscribe();\n    };\n  }, []);\n\n  const loadUser = async () => {\n    try {\n      console.log(`[AuthProvider ${instanceId.current}] Loading user...`);\n      const session = await AuthService.restoreSession();\n      if (session) {\n        console.log(`[AuthProvider ${instanceId.current}] Restored user:`, session.user.id);\n        setUser(session.user);\n      } else {\n        console.log(`[AuthProvider ${instanceId.current}] No session found`);\n      }\n    } catch (error) {\n      console.error('Failed to load user:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const login = async (email: string, password: string): Promise<boolean> => {\n    try {\n      const { user: loggedInUser } = await AuthService.login(email, password);\n      setUser(loggedInUser);\n      return true;\n    } catch (error) {\n      console.error('Login failed:', error);\n      return false;\n    }\n  };\n\n  const signup = async (userData: SignupData): Promise<string> => {\n    try {\n      // Set flags to prevent auth state listener from interfering and show loading\n      globalIsSigningUp = true;\n      setIsSigningUp(true);\n      console.log('[Signup] Starting, setting globalIsSigningUp flag');\n      \n      const { user: newUser } = await AuthService.signup(userData);\n      console.log('[Signup] Complete, setting user:', newUser.id);\n      \n      // Mark that user was set by signup (prevents auth listener from overriding)\n      userSetBySignup.current = true;\n      setUser(newUser);\n      setIsLoading(false);\n      console.log('[Signup] User state updated, userSetBySignup is now true');\n      \n      // Clear isSigningUp AFTER user is set - this triggers navigation\n      setIsSigningUp(false);\n      \n      // Defer clearing globalIsSigningUp to allow any pending auth events to be skipped\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // Verify session is stable before clearing the flag\n      const { data: { session } } = await supabase.auth.getSession();\n      if (session?.user?.id === newUser.id) {\n        console.log('[Signup] Session verified stable, clearing globalIsSigningUp flag');\n        globalIsSigningUp = false;\n      } else {\n        console.log('[Signup] Session mismatch, keeping flag for safety');\n        setTimeout(() => { globalIsSigningUp = false; }, 2000);\n      }\n      \n      return newUser.unique_id;\n    } catch (error) {\n      globalIsSigningUp = false;\n      setIsSigningUp(false);\n      userSetBySignup.current = false;\n      console.error('Signup failed:', error);\n      throw error;\n    }\n  };\n\n  const logout = async () => {\n    console.log('[Auth] Logout called');\n    try {\n      // Set user to null first to immediately update UI\n      setUser(null);\n      userSetBySignup.current = false;\n      globalIsSigningUp = false;\n      setIsSigningUp(false);\n      \n      // Then sign out from Supabase with a timeout (this might be slow or fail, but UI is already updated)\n      // Attach .catch() to prevent unhandled rejection if promise rejects after timeout\n      const signOutPromise = AuthService.logout().catch((err) => {\n        console.log('[Auth] Logout promise rejected (handled):', err);\n      });\n      const timeoutPromise = new Promise<void>((resolve) => setTimeout(resolve, 3000));\n      await Promise.race([signOutPromise, timeoutPromise]);\n      console.log('[Auth] Logout completed');\n    } catch (error) {\n      console.error('[Auth] Logout failed:', error);\n      // Even if signOut fails, ensure user state is cleared\n      setUser(null);\n      userSetBySignup.current = false;\n      globalIsSigningUp = false;\n      setIsSigningUp(false);\n    }\n  };\n\n  const updateUser = async (updates: Partial<User>) => {\n    if (user) {\n      try {\n        const updatedUser = await AuthService.updateProfile(user.id, updates);\n        setUser(updatedUser);\n      } catch (error) {\n        console.error('Update user failed:', error);\n        throw error;\n      }\n    }\n  };\n\n  const refreshUser = async () => {\n    try {\n      const { data: { session } } = await supabase.auth.getSession();\n      \n      if (session?.user) {\n        const { data: profile } = await supabase\n          .from('users')\n          .select('*')\n          .eq('id', session.user.id)\n          .single();\n        \n        if (profile) {\n          userSetBySignup.current = true;\n          globalIsSigningUp = false;\n          setIsSigningUp(false);\n          setUser(profile as User);\n        }\n      }\n    } catch (error) {\n      console.error('Refresh user failed:', error);\n    }\n  };\n\n  const setSocialSignupInProgress = (inProgress: boolean) => {\n    console.log('[Auth] setSocialSignupInProgress:', inProgress);\n    globalIsSigningUp = inProgress;\n    setIsSigningUp(inProgress);\n  };\n\n  const clearSignupOverlay = () => {\n    console.log('[Auth] clearSignupOverlay - hiding loading but keeping auth listener blocked');\n    setIsSigningUp(false);\n  };\n\n  return (\n    <AuthContext.Provider value={{ user, isLoading, isSigningUp, login, signup, logout, updateUser, refreshUser, setSocialSignupInProgress, clearSignupOverlay }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n}\n","path":null,"size_bytes":9252,"size_tokens":null},"screens/CreateSplitDetailsScreen.tsx":{"content":"import React, { useState } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, Image, Alert } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport * as ImagePicker from 'expo-image-picker';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { useLevelUp } from '@/contexts/LevelUpContext';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { SplitsService } from '@/services/splits.service';\n\ntype Friend = {\n  uniqueId: string;\n  odooUserId: string;\n  firstName: string;\n  lastName: string;\n  profilePicture: string | null;\n};\n\ntype Props = NativeStackScreenProps<any, 'CreateSplitDetails'>;\n\nexport default function CreateSplitDetailsScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const { user } = useAuth();\n  const { checkLevelUp } = useLevelUp();\n  const { selectedFriends, splitType } = route.params as { selectedFriends: Friend[]; splitType: 'equal' | 'specified' };\n\n  const [eventName, setEventName] = useState('');\n  const [totalAmount, setTotalAmount] = useState('');\n  const [myShare, setMyShare] = useState('');\n  const [friendShares, setFriendShares] = useState<{ [key: string]: string }>({});\n  const [receiptImage, setReceiptImage] = useState<string | undefined>();\n  const [loading, setLoading] = useState(false);\n\n  const updateFriendShare = (odooUserId: string, value: string) => {\n    setFriendShares(prev => ({ ...prev, [odooUserId]: value }));\n  };\n\n  const calculateTotalShares = () => {\n    const creatorAmount = parseFloat(myShare) || 0;\n    const friendsTotal = Object.values(friendShares).reduce((sum, val) => sum + (parseFloat(val) || 0), 0);\n    return creatorAmount + friendsTotal;\n  };\n\n  const getRemainingAmount = () => {\n    const total = parseFloat(totalAmount) || 0;\n    return total - calculateTotalShares();\n  };\n\n  const pickImage = async () => {\n    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();\n    if (status !== 'granted') {\n      Alert.alert('Permission needed', 'Please grant camera roll permission');\n      return;\n    }\n\n    const result = await ImagePicker.launchImageLibraryAsync({\n      mediaTypes: ['images'],\n      allowsEditing: true,\n      quality: 0.8,\n    });\n\n    if (!result.canceled) {\n      setReceiptImage(result.assets[0].uri);\n    }\n  };\n\n  const handleCreateEvent = async () => {\n    if (!eventName.trim()) {\n      Alert.alert('Missing information', 'Please enter an event name');\n      return;\n    }\n\n    const amount = parseFloat(totalAmount);\n    if (isNaN(amount) || amount <= 0) {\n      Alert.alert('Invalid amount', 'Please enter a valid amount');\n      return;\n    }\n\n    if (splitType === 'specified') {\n      if (!receiptImage) {\n        Alert.alert('Missing receipt', 'Please upload a receipt image');\n        return;\n      }\n      const share = parseFloat(myShare);\n      if (isNaN(share) || share <= 0 || share > amount) {\n        Alert.alert('Invalid share', 'Please enter a valid share amount for yourself');\n        return;\n      }\n    }\n\n    if (!user) return;\n\n    setLoading(true);\n\n    try {\n      if (selectedFriends.length === 0) {\n        Alert.alert('Error', 'Please select at least one friend to split with');\n        setLoading(false);\n        return;\n      }\n\n      const participantCount = selectedFriends.length + 1;\n      let creatorAmount = 0;\n\n      if (splitType === 'equal') {\n        const equalShare = amount / participantCount;\n        creatorAmount = equalShare;\n        \n        const participants = [\n          { userId: user.id, amount: creatorAmount },\n          ...selectedFriends.map(friend => ({\n            userId: friend.odooUserId,\n            amount: equalShare,\n          })),\n        ];\n\n        const totalShares = participants.reduce((sum, p) => sum + p.amount, 0);\n        if (Math.abs(totalShares - amount) > 0.01) {\n          Alert.alert('Error', `Participant shares ($${totalShares.toFixed(2)}) must equal total amount ($${amount.toFixed(2)})`);\n          setLoading(false);\n          return;\n        }\n\n        const result = await SplitsService.createSplit({\n          name: eventName.trim(),\n          totalAmount: amount,\n          splitType,\n          creatorId: user.id,\n          participants,\n          receiptUri: receiptImage,\n        });\n        \n        if (result.xpResult) {\n          checkLevelUp(result.xpResult);\n        }\n      } else {\n        creatorAmount = parseFloat(myShare || '0');\n        \n        const participants = [\n          { userId: user.id, amount: creatorAmount },\n          ...selectedFriends.map(friend => ({\n            userId: friend.odooUserId,\n            amount: 0,\n          })),\n        ];\n\n        const result = await SplitsService.createSplit({\n          name: eventName.trim(),\n          totalAmount: amount,\n          splitType,\n          creatorId: user.id,\n          participants,\n          receiptUri: receiptImage,\n        });\n        \n        if (result.xpResult) {\n          checkLevelUp(result.xpResult);\n        }\n      }\n\n      // Reset the navigation stack to show MainHome with the tab bar\n      navigation.getParent()?.reset({\n        index: 0,\n        routes: [{ name: 'HomeTab', params: { screen: 'MainHome' } }],\n      });\n    } catch (error) {\n      console.error('Failed to create split:', error);\n      Alert.alert('Error', 'Failed to create split. Please try again.');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const calculatedShare = splitType === 'equal' && totalAmount\n    ? (parseFloat(totalAmount) / (selectedFriends.length + 1)).toFixed(2)\n    : '0.00';\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.h1, { color: theme.text, marginBottom: Spacing.xl }]}>\n          Event Details\n        </ThemedText>\n\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing.sm }]}>\n          Event Name\n        </ThemedText>\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: theme.border \n          }]}\n          placeholder=\"e.g., Dinner at Restaurant\"\n          placeholderTextColor={theme.textSecondary}\n          value={eventName}\n          onChangeText={setEventName}\n        />\n\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing.sm, marginTop: Spacing.lg }]}>\n          Total Amount\n        </ThemedText>\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: theme.border \n          }]}\n          placeholder=\"0.00\"\n          placeholderTextColor={theme.textSecondary}\n          value={totalAmount}\n          onChangeText={setTotalAmount}\n          keyboardType=\"decimal-pad\"\n        />\n\n        {splitType === 'equal' ? (\n          <View style={[styles.infoBox, { backgroundColor: theme.primary + '20', marginTop: Spacing.lg }]}>\n            <ThemedText style={[Typography.caption, { color: theme.text }]}>\n              Each person pays: ${calculatedShare}\n            </ThemedText>\n          </View>\n        ) : (\n          <>\n            <Pressable\n              style={[styles.uploadButton, { \n                backgroundColor: receiptImage ? theme.success + '20' : theme.surface,\n                borderColor: theme.border,\n                marginTop: Spacing.lg\n              }]}\n              onPress={pickImage}\n            >\n              <Feather \n                name={receiptImage ? 'check-circle' : 'upload'} \n                size={24} \n                color={receiptImage ? theme.success : theme.textSecondary} \n              />\n              <ThemedText style={[Typography.body, { color: theme.text, marginLeft: Spacing.md }]}>\n                {receiptImage ? 'Receipt uploaded' : 'Upload Receipt'}\n              </ThemedText>\n            </Pressable>\n\n            {receiptImage ? (\n              <Image source={{ uri: receiptImage }} style={styles.receiptPreview} />\n            ) : null}\n\n            <ThemedText style={[Typography.h2, { color: theme.text, marginTop: Spacing.xl, marginBottom: Spacing.md }]}>\n              Your Share\n            </ThemedText>\n\n            <View style={[styles.participantRow, { backgroundColor: theme.surface, borderColor: theme.border }]}>\n              <View style={styles.participantInfo}>\n                <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n                  You (Creator)\n                </ThemedText>\n                <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                  Enter the amount you are paying\n                </ThemedText>\n              </View>\n              <View style={styles.amountInputWrapper}>\n                <ThemedText style={[Typography.body, { color: theme.text, marginRight: Spacing.xs }]}>$</ThemedText>\n                <TextInput\n                  style={[styles.amountInput, { \n                    backgroundColor: theme.backgroundSecondary, \n                    color: theme.text, \n                    borderColor: theme.border \n                  }]}\n                  placeholder=\"0.00\"\n                  placeholderTextColor={theme.textSecondary}\n                  value={myShare}\n                  onChangeText={setMyShare}\n                  keyboardType=\"decimal-pad\"\n                />\n              </View>\n            </View>\n\n            <View style={[styles.infoBox, { backgroundColor: theme.primary + '15', marginTop: Spacing.lg }]}>\n              <Feather name=\"info\" size={16} color={theme.primary} style={{ marginBottom: Spacing.xs }} />\n              <ThemedText style={[Typography.caption, { color: theme.text }]}>\n                Your {selectedFriends.length} invited friend{selectedFriends.length > 1 ? 's' : ''} will enter their own amounts after accepting the invite.\n              </ThemedText>\n            </View>\n          </>\n        )}\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed ? 0.7 : (loading ? 0.4 : 1)\n            }\n          ]}\n          onPress={handleCreateEvent}\n          disabled={loading}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            {loading ? 'Creating...' : 'Create Event'}\n          </ThemedText>\n        </Pressable>\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.xl,\n  },\n  input: {\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    fontSize: 16,\n  },\n  infoBox: {\n    padding: Spacing.md,\n    borderRadius: BorderRadius.xs,\n  },\n  uploadButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.xs,\n    borderWidth: 1,\n  },\n  receiptPreview: {\n    width: '100%',\n    height: 200,\n    borderRadius: BorderRadius.sm,\n    marginTop: Spacing.lg,\n  },\n  participantRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    padding: Spacing.md,\n    borderRadius: BorderRadius.xs,\n    borderWidth: 1,\n    marginBottom: Spacing.sm,\n  },\n  participantInfo: {\n    flex: 1,\n  },\n  amountInputWrapper: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  amountInput: {\n    width: 100,\n    height: 44,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.md,\n    fontSize: 16,\n    textAlign: 'right',\n  },\n  summaryRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":12596,"size_tokens":null},"screens/SignupDOBScreen.tsx":{"content":"import React, { useState } from 'react';\nimport { View, StyleSheet, Pressable, Platform, TextInput } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport DateTimePicker from '@react-native-community/datetimepicker';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenScrollView } from '@/components/ScreenScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\n\ntype Props = NativeStackScreenProps<any, 'SignupDOB'>;\n\nexport default function SignupDOBScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const [date, setDate] = useState(new Date(2000, 0, 1));\n  const [dateText, setDateText] = useState('2000-01-01');\n  const params = route.params as { firstName: string; lastName: string; email: string; password: string; phone: string };\n\n  const handleContinue = () => {\n    navigation.navigate('SignupProfilePicture', { ...params, dateOfBirth: date.toISOString() });\n  };\n\n  const handleDateTextChange = (text: string) => {\n    setDateText(text);\n    const parsedDate = new Date(text);\n    if (!isNaN(parsedDate.getTime())) {\n      setDate(parsedDate);\n    }\n  };\n\n  return (\n    <ScreenScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Step 6 of 8\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.xl }]}>\n          When's your birthday?\n        </ThemedText>\n\n        <View style={styles.pickerContainer}>\n          {Platform.OS === 'web' ? (\n            <View style={styles.webInputContainer}>\n              <ThemedText style={[Typography.small, { color: theme.textSecondary, marginBottom: Spacing.sm }]}>\n                Date of Birth (YYYY-MM-DD)\n              </ThemedText>\n              <TextInput\n                style={[\n                  styles.webInput,\n                  {\n                    backgroundColor: theme.backgroundSecondary,\n                    color: theme.text,\n                    borderColor: theme.border,\n                  }\n                ]}\n                value={dateText}\n                onChangeText={handleDateTextChange}\n                placeholder=\"2000-01-01\"\n                placeholderTextColor={theme.textSecondary}\n                autoCapitalize=\"none\"\n              />\n            </View>\n          ) : (\n            <DateTimePicker\n              value={date}\n              mode=\"date\"\n              display={Platform.OS === 'ios' ? 'spinner' : 'default'}\n              onChange={(event, selectedDate) => {\n                if (selectedDate) {\n                  setDate(selectedDate);\n                }\n              }}\n              maximumDate={new Date()}\n              minimumDate={new Date(1900, 0, 1)}\n              textColor={theme.text}\n            />\n          )}\n        </View>\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { backgroundColor: theme.primary, opacity: pressed ? 0.7 : 1 }\n          ]}\n          onPress={handleContinue}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            Continue\n          </ThemedText>\n        </Pressable>\n      </View>\n    </ScreenScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  pickerContainer: {\n    alignItems: 'center',\n  },\n  webInputContainer: {\n    width: '100%',\n  },\n  webInput: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.md,\n    fontSize: 16,\n    borderWidth: 1,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":4230,"size_tokens":null},"screens/MainHomeScreen.tsx":{"content":"import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';\nimport { View, StyleSheet, Pressable, FlatList, RefreshControl, ActivityIndicator, AppState, AppStateStatus, Alert } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { Feather } from '@expo/vector-icons';\nimport { Gesture, GestureDetector, GestureType } from 'react-native-gesture-handler';\nimport Animated, { useSharedValue, useAnimatedStyle, withSpring, runOnJS, useDerivedValue, withTiming, SharedValue } from 'react-native-reanimated';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { SplitEvent, Wallet } from '@/shared/types';\nimport { SplitsService } from '@/services/splits.service';\nimport { WalletService } from '@/services/wallet.service';\nimport { NotificationsService } from '@/services/notifications.service';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { useSafeBottomTabBarHeight } from '@/hooks/useSafeBottomTabBarHeight';\nimport { useFocusEffect } from '@react-navigation/native';\n\ntype Props = NativeStackScreenProps<any, 'MainHome'>;\n\nconst DELETE_BUTTON_WIDTH = 80;\nconst SWIPE_THRESHOLD = DELETE_BUTTON_WIDTH * 0.5;\n\nfunction SwipeableEventCard({ \n  item, \n  onPress, \n  onDelete,\n  showGreyOverlay,\n  isCreator,\n  userAmount,\n  progress,\n  isInProgress,\n  theme,\n  swipeOpenIdShared,\n  setSwipeOpenId,\n  nativeScrollGesture\n}: {\n  item: SplitEvent;\n  onPress: () => void;\n  onDelete: () => void;\n  showGreyOverlay: boolean;\n  isCreator: boolean;\n  userAmount: number;\n  progress?: number;\n  isInProgress?: boolean;\n  theme: any;\n  swipeOpenIdShared: SharedValue<string | null>;\n  setSwipeOpenId: (id: string | null) => void;\n  nativeScrollGesture: GestureType;\n}) {\n  const translateX = useSharedValue(0);\n  const isOpen = useSharedValue(false);\n  const isGestureActive = useSharedValue(false);\n  const itemIdRef = useRef(item.id);\n\n  useDerivedValue(() => {\n    if (isGestureActive.value) return;\n    \n    const isThisOpen = swipeOpenIdShared.value === item.id;\n    if (!isThisOpen && isOpen.value) {\n      translateX.value = withTiming(0, { duration: 200 });\n      isOpen.value = false;\n    }\n  }, [item.id]);\n\n  if (itemIdRef.current !== item.id) {\n    translateX.value = 0;\n    isOpen.value = false;\n    itemIdRef.current = item.id;\n  }\n\n  const closeSwipe = useCallback(() => {\n    setSwipeOpenId(null);\n  }, [setSwipeOpenId]);\n\n  const openSwipe = useCallback(() => {\n    setSwipeOpenId(item.id);\n  }, [setSwipeOpenId, item.id]);\n\n  const handleDelete = useCallback(() => {\n    const isCreatorDeletingInProgress = isCreator && isInProgress;\n    \n    Alert.alert(\n      isCreatorDeletingInProgress ? 'Delete Split' : 'Remove Split',\n      isCreatorDeletingInProgress \n        ? 'Delete this split permanently? This will cancel the split for all participants. Any collected payments are already processed, but pending participants will no longer be able to pay.'\n        : 'Remove this split from your view? This won\\'t affect other participants.',\n      [\n        { \n          text: 'Cancel', \n          style: 'cancel', \n          onPress: () => {\n            translateX.value = withSpring(0, { damping: 20, stiffness: 200 });\n            isOpen.value = false;\n            closeSwipe();\n          }\n        },\n        { \n          text: isCreatorDeletingInProgress ? 'Delete' : 'Remove', \n          style: 'destructive', \n          onPress: () => {\n            translateX.value = withSpring(0, { damping: 20, stiffness: 200 });\n            isOpen.value = false;\n            closeSwipe();\n            onDelete();\n          }\n        },\n      ]\n    );\n  }, [translateX, isOpen, closeSwipe, onDelete, isCreator, isInProgress]);\n\n  const panGesture = useMemo(() => \n    Gesture.Pan()\n      .activeOffsetX([-25, 25])\n      .failOffsetY([-20, 20])\n      .maxPointers(1)\n      .simultaneousWithExternalGesture(nativeScrollGesture)\n      .onStart(() => {\n        'worklet';\n        isGestureActive.value = true;\n        if (!isOpen.value) {\n          swipeOpenIdShared.value = item.id;\n        }\n      })\n      .onUpdate((event) => {\n        'worklet';\n        const base = isOpen.value ? -DELETE_BUTTON_WIDTH : 0;\n        const newValue = base + event.translationX;\n        translateX.value = Math.max(Math.min(newValue, 0), -DELETE_BUTTON_WIDTH);\n      })\n      .onEnd(() => {\n        'worklet';\n        isGestureActive.value = false;\n        if (translateX.value < -SWIPE_THRESHOLD) {\n          translateX.value = withSpring(-DELETE_BUTTON_WIDTH, { damping: 20, stiffness: 200 });\n          isOpen.value = true;\n          runOnJS(openSwipe)();\n        } else {\n          translateX.value = withSpring(0, { damping: 20, stiffness: 200 });\n          isOpen.value = false;\n          runOnJS(closeSwipe)();\n        }\n      })\n      .onFinalize(() => {\n        'worklet';\n        isGestureActive.value = false;\n      }),\n    [translateX, isOpen, isGestureActive, openSwipe, closeSwipe, nativeScrollGesture, swipeOpenIdShared, item.id]\n  );\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ translateX: translateX.value }],\n  }));\n\n  const deleteButtonAnimatedStyle = useAnimatedStyle(() => {\n    const progress = Math.abs(translateX.value) / DELETE_BUTTON_WIDTH;\n    return {\n      opacity: progress,\n      transform: [{ scale: 0.8 + (progress * 0.2) }],\n    };\n  });\n\n  return (\n    <View style={styles.swipeableContainer}>\n      <Animated.View \n        style={[styles.deleteButtonContainer, { backgroundColor: theme.danger }, deleteButtonAnimatedStyle]}\n      >\n        <Pressable \n          style={styles.deleteButton}\n          onPress={handleDelete}\n        >\n          <Feather name=\"trash-2\" size={20} color=\"#FFFFFF\" />\n        </Pressable>\n      </Animated.View>\n      <GestureDetector gesture={panGesture}>\n        <Animated.View style={[styles.swipeableCard, animatedStyle]}>\n          <Pressable\n            style={({ pressed }) => [\n              styles.eventCardInner,\n              { \n                backgroundColor: theme.surface,\n                borderColor: theme.border,\n                opacity: pressed ? 0.7 : 1\n              }\n            ]}\n            onPress={onPress}\n          >\n            {showGreyOverlay ? (\n              <View style={styles.paidOverlay}>\n                <View style={[StyleSheet.absoluteFill, { backgroundColor: theme.text, opacity: 0.08 }]} />\n              </View>\n            ) : null}\n            \n            <View style={styles.eventHeader}>\n              <ThemedText style={[Typography.h2, { color: showGreyOverlay ? theme.textSecondary : theme.text, flex: 1 }]}>\n                {item.name}\n              </ThemedText>\n              <View style={styles.badgeContainer}>\n                {isCreator ? (\n                  <View style={[styles.badge, { backgroundColor: theme.primary }]}>\n                    <ThemedText style={[Typography.small, { color: '#FFFFFF' }]}>Creator</ThemedText>\n                  </View>\n                ) : null}\n              </View>\n            </View>\n\n            <View style={styles.eventInfo}>\n              <ThemedText style={[Typography.body, { color: showGreyOverlay ? theme.textSecondary : theme.text, fontWeight: '600' }]}>\n                ${parseFloat(item.total_amount?.toString() || '0').toFixed(2)}\n              </ThemedText>\n              <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                Your share: ${parseFloat(userAmount.toString()).toFixed(2)}\n              </ThemedText>\n            </View>\n\n            {isInProgress && progress !== undefined ? (\n              <View style={styles.progressContainer}>\n                <View style={[styles.progressBar, { backgroundColor: showGreyOverlay ? theme.textSecondary + '30' : theme.border }]}>\n                  <View \n                    style={[\n                      styles.progressFill, \n                      { backgroundColor: showGreyOverlay ? theme.textSecondary : theme.primary, width: `${progress}%` }\n                    ]} \n                  />\n                </View>\n                <View style={styles.progressInfo}>\n                  <ThemedText style={[Typography.small, { color: theme.textSecondary }]}>\n                    {Math.round(progress)}% paid\n                  </ThemedText>\n                </View>\n              </View>\n            ) : null}\n\n            <View style={styles.eventFooter}>\n              <View style={styles.participantCount}>\n                <Feather name=\"users\" size={14} color={theme.textSecondary} />\n                <ThemedText style={[Typography.small, { color: theme.textSecondary, marginLeft: Spacing.xs }]}>\n                  {item.participants?.length || 0} participants\n                </ThemedText>\n              </View>\n              <ThemedText style={[Typography.small, { color: theme.textSecondary }]}>\n                {new Date(item.created_at).toLocaleDateString()}\n              </ThemedText>\n            </View>\n          </Pressable>\n        </Animated.View>\n      </GestureDetector>\n    </View>\n  );\n}\n\nfunction EventCard({ \n  item, \n  onPress, \n  showGreyOverlay,\n  isCreator,\n  userAmount,\n  progress,\n  theme \n}: {\n  item: SplitEvent;\n  onPress: () => void;\n  showGreyOverlay: boolean;\n  isCreator: boolean;\n  userAmount: number;\n  progress: number;\n  theme: any;\n}) {\n  return (\n    <View style={styles.eventCard}>\n      <Pressable\n        style={({ pressed }) => [\n          styles.eventCardInner,\n          { \n            backgroundColor: theme.surface,\n            borderColor: theme.border,\n            opacity: pressed ? 0.7 : 1\n          }\n        ]}\n        onPress={onPress}\n      >\n        {showGreyOverlay ? (\n          <View style={styles.paidOverlay}>\n            <View style={[StyleSheet.absoluteFill, { backgroundColor: theme.text, opacity: 0.08 }]} />\n          </View>\n        ) : null}\n        \n        <View style={styles.eventHeader}>\n          <ThemedText style={[Typography.h2, { color: showGreyOverlay ? theme.textSecondary : theme.text, flex: 1 }]}>\n            {item.name}\n          </ThemedText>\n          <View style={styles.badgeContainer}>\n            {isCreator ? (\n              <View style={[styles.badge, { backgroundColor: theme.primary }]}>\n                <ThemedText style={[Typography.small, { color: '#FFFFFF' }]}>Creator</ThemedText>\n              </View>\n            ) : null}\n          </View>\n        </View>\n\n        <View style={styles.eventInfo}>\n          <ThemedText style={[Typography.body, { color: showGreyOverlay ? theme.textSecondary : theme.text, fontWeight: '600' }]}>\n            ${parseFloat(item.total_amount?.toString() || '0').toFixed(2)}\n          </ThemedText>\n          <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n            Your share: ${parseFloat(userAmount.toString()).toFixed(2)}\n          </ThemedText>\n        </View>\n\n        <View style={styles.progressContainer}>\n          <View style={[styles.progressBar, { backgroundColor: showGreyOverlay ? theme.textSecondary + '30' : theme.border }]}>\n            <View \n              style={[\n                styles.progressFill, \n                { backgroundColor: showGreyOverlay ? theme.textSecondary : theme.primary, width: `${progress}%` }\n              ]} \n            />\n          </View>\n          <View style={styles.progressInfo}>\n            <ThemedText style={[Typography.small, { color: theme.textSecondary }]}>\n              {Math.round(progress)}% paid\n            </ThemedText>\n          </View>\n        </View>\n\n        <View style={styles.eventFooter}>\n          <View style={styles.participantCount}>\n            <Feather name=\"users\" size={14} color={theme.textSecondary} />\n            <ThemedText style={[Typography.small, { color: theme.textSecondary, marginLeft: Spacing.xs }]}>\n              {item.participants?.length || 0} participants\n            </ThemedText>\n          </View>\n          <ThemedText style={[Typography.small, { color: theme.textSecondary }]}>\n            {new Date(item.created_at).toLocaleDateString()}\n          </ThemedText>\n        </View>\n      </Pressable>\n    </View>\n  );\n}\n\nexport default function MainHomeScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n  const { user } = useAuth();\n  const insets = useSafeAreaInsets();\n  const tabBarHeight = useSafeBottomTabBarHeight();\n  const scrollRef = useRef<FlatList>(null);\n  const [selectedTab, setSelectedTab] = useState<'in_progress' | 'completed'>('in_progress');\n  const [events, setEvents] = useState<SplitEvent[]>([]);\n  const [hiddenEventIds, setHiddenEventIds] = useState<string[]>([]);\n  const [wallet, setWallet] = useState<Wallet | null>(null);\n  const [refreshing, setRefreshing] = useState(false);\n  const [loading, setLoading] = useState(true);\n  const [notifications, setNotifications] = useState<number>(0);\n  const [networkError, setNetworkError] = useState(false);\n  const [swipeOpenId, setSwipeOpenId] = useState<string | null>(null);\n  const swipeOpenIdShared = useSharedValue<string | null>(null);\n  const retryCountRef = useRef(0);\n  const appState = useRef(AppState.currentState);\n  const subscriptionRef = useRef<{ unsubscribe: () => void; updateSplitIds: (ids: string[]) => void } | null>(null);\n\n  const nativeScrollGesture = useMemo(() => Gesture.Native(), []);\n\n  const loadData = useCallback(async (isRetry = false) => {\n    if (!user) return;\n    \n    try {\n      const results = await Promise.allSettled([\n        SplitsService.getSplits(user.id),\n        WalletService.getWallet(user.id),\n        NotificationsService.getUnreadCount(user.id),\n      ]);\n      \n      const [splitsResult, walletResult, notificationsResult] = results;\n      \n      if (splitsResult.status === 'fulfilled') {\n        setEvents(splitsResult.value);\n        if (subscriptionRef.current?.updateSplitIds) {\n          subscriptionRef.current.updateSplitIds(splitsResult.value.map(s => s.id));\n        }\n      } else {\n        console.error('Failed to load splits:', splitsResult.reason);\n      }\n      \n      if (walletResult.status === 'fulfilled') {\n        setWallet(walletResult.value);\n      } else {\n        console.error('Failed to load wallet:', walletResult.reason);\n        setWallet({ id: '', user_id: user.id, balance: 0, bank_connected: false } as Wallet);\n      }\n      \n      if (notificationsResult.status === 'fulfilled') {\n        setNotifications(notificationsResult.value);\n      }\n      \n      const hasNetworkError = results.some(r => \n        r.status === 'rejected' && (\n          r.reason?.message?.includes('Network') || \n          r.reason?.message?.includes('network') ||\n          r.reason?.message?.includes('fetch')\n        )\n      );\n      \n      if (hasNetworkError) {\n        setNetworkError(true);\n        if (!isRetry && retryCountRef.current < 3) {\n          retryCountRef.current += 1;\n          const delay = Math.min(1000 * Math.pow(2, retryCountRef.current), 5000);\n          setTimeout(() => loadData(true), delay);\n        }\n      } else {\n        setNetworkError(false);\n        retryCountRef.current = 0;\n      }\n    } catch (error: any) {\n      console.error('Failed to load home data:', error);\n    } finally {\n      setLoading(false);\n    }\n  }, [user]);\n\n  useEffect(() => {\n    loadData();\n    // Backup polling for edge cases (splits beyond MAX_SPLIT_CHANNELS limit)\n    const interval = setInterval(() => loadData(false), 60000);\n    return () => clearInterval(interval);\n  }, [loadData]);\n\n  // Subscribe to realtime updates for instant cross-participant updates\n  // Uses per-split channels for up to 15 most recent splits\n  useEffect(() => {\n    if (!user?.id) return;\n\n    const subscription = SplitsService.subscribeToSplitUpdates(\n      user.id,\n      () => loadData()\n    );\n    subscriptionRef.current = subscription;\n\n    return () => {\n      subscription.unsubscribe();\n      subscriptionRef.current = null;\n    };\n  }, [user?.id, loadData]);\n\n  // Refresh data when screen comes into focus\n  useFocusEffect(\n    useCallback(() => {\n      loadData();\n    }, [loadData])\n  );\n\n  useEffect(() => {\n    const subscription = AppState.addEventListener('change', (nextAppState: AppStateStatus) => {\n      if (appState.current.match(/inactive|background/) && nextAppState === 'active') {\n        retryCountRef.current = 0;\n        loadData();\n      }\n      appState.current = nextAppState;\n    });\n\n    return () => subscription.remove();\n  }, [loadData]);\n\n  const updateSwipeOpenId = useCallback((id: string | null) => {\n    setSwipeOpenId(id);\n    swipeOpenIdShared.value = id;\n  }, [swipeOpenIdShared]);\n\n  useEffect(() => {\n    updateSwipeOpenId(null);\n  }, [selectedTab, updateSwipeOpenId]);\n\n  const onRefresh = async () => {\n    setRefreshing(true);\n    updateSwipeOpenId(null);\n    retryCountRef.current = 0;\n    await loadData();\n    setRefreshing(false);\n  };\n\n  const handleHideEvent = (eventId: string) => {\n    setHiddenEventIds(prev => [...prev, eventId]);\n  };\n\n  const handleDeleteSplit = async (eventId: string) => {\n    if (!user?.id) return;\n    \n    // Optimistically remove from UI immediately\n    setEvents(prev => prev.filter(e => e.id !== eventId));\n    \n    try {\n      await SplitsService.deleteSplit(user.id, eventId);\n    } catch (error: any) {\n      console.error('Failed to delete split:', error);\n      // Restore events on error by reloading data\n      loadData();\n      Alert.alert('Error', error.message || 'Failed to delete split');\n    }\n  };\n\n  const filteredEvents = events.filter(event => {\n    if (!user || !event.participants) return false;\n    \n    if (hiddenEventIds.includes(event.id)) return false;\n    \n    const userParticipant = event.participants.find((p: any) => p.user_id === user.id);\n    if (!userParticipant) return false;\n    \n    const isCreator = event.creator_id === user.id;\n    const userAccepted = userParticipant.status === 'accepted' || userParticipant.status === 'paid';\n    \n    if (!isCreator && !userAccepted) return false;\n    \n    const allSettled = event.participants.every((p: any) => p.status === 'paid' || p.is_creator);\n    return selectedTab === 'in_progress' ? !allSettled : allSettled;\n  });\n\n  const getProgress = (event: any) => {\n    if (!event?.participants) return 0;\n    \n    const totalAmount = parseFloat(event.total_amount) || 0;\n    if (totalAmount === 0) return 0;\n    \n    let paidAmount = 0;\n    \n    for (const participant of event.participants) {\n      const participantAmount = parseFloat(participant.amount) || 0;\n      \n      if (event.split_type === 'specified') {\n        // For specified splits: count creator + participants who paid with amount > 0\n        if (participant.is_creator || (participant.status === 'paid' && participantAmount > 0)) {\n          paidAmount += participantAmount;\n        }\n      } else {\n        // For equal splits: count creator + participants who paid\n        if (participant.is_creator || participant.status === 'paid') {\n          paidAmount += participantAmount;\n        }\n      }\n    }\n    \n    return (paidAmount / totalAmount) * 100;\n  };\n\n  const renderEvent = ({ item }: { item: SplitEvent }) => {\n    const progress = getProgress(item);\n    const isCreator = item.creator_id === user?.id;\n    const userParticipant = item.participants?.find((p: any) => p.user_id === user?.id);\n    const userAmount = userParticipant?.amount || 0;\n    const userHasPaid = userParticipant?.status === 'paid';\n    const isCompleted = selectedTab === 'completed';\n    const isInProgress = selectedTab === 'in_progress';\n    \n    // Grey overlay only shows when: user is NOT the creator AND user has paid AND split is still in progress\n    const showGreyOverlay = isInProgress && !isCreator && userHasPaid && progress < 100;\n\n    // For completed tab: all users can swipe to hide\n    if (isCompleted) {\n      return (\n        <SwipeableEventCard\n          key={item.id}\n          item={item}\n          onPress={() => navigation.navigate('EventDetail', { eventId: item.id })}\n          onDelete={() => handleHideEvent(item.id)}\n          showGreyOverlay={false}\n          isCreator={isCreator}\n          userAmount={userAmount}\n          isInProgress={false}\n          theme={theme}\n          swipeOpenIdShared={swipeOpenIdShared}\n          setSwipeOpenId={updateSwipeOpenId}\n          nativeScrollGesture={nativeScrollGesture}\n        />\n      );\n    }\n\n    // For in_progress tab: only creators can swipe to delete\n    if (isInProgress && isCreator) {\n      return (\n        <SwipeableEventCard\n          key={item.id}\n          item={item}\n          onPress={() => navigation.navigate('EventDetail', { eventId: item.id })}\n          onDelete={() => handleDeleteSplit(item.id)}\n          showGreyOverlay={showGreyOverlay}\n          isCreator={isCreator}\n          userAmount={userAmount}\n          progress={progress}\n          isInProgress={true}\n          theme={theme}\n          swipeOpenIdShared={swipeOpenIdShared}\n          setSwipeOpenId={updateSwipeOpenId}\n          nativeScrollGesture={nativeScrollGesture}\n        />\n      );\n    }\n\n    // For in_progress tab: non-creators see regular EventCard\n    return (\n      <EventCard\n        item={item}\n        onPress={() => navigation.navigate('EventDetail', { eventId: item.id })}\n        showGreyOverlay={showGreyOverlay}\n        isCreator={isCreator}\n        userAmount={userAmount}\n        progress={progress}\n        theme={theme}\n      />\n    );\n  };\n\n  if (loading) {\n    return (\n      <ThemedView style={[styles.container, { justifyContent: 'center', alignItems: 'center' }]}>\n        <ActivityIndicator size=\"large\" color={theme.primary} />\n      </ThemedView>\n    );\n  }\n\n  return (\n    <ThemedView style={[styles.container, { paddingTop: insets.top + Spacing.xl }]}>\n      {networkError && !loading ? (\n        <Pressable \n          style={[styles.networkBanner, { backgroundColor: theme.warning + '20' }]}\n          onPress={onRefresh}\n        >\n          <Feather name=\"wifi-off\" size={14} color={theme.warning} />\n          <ThemedText style={[Typography.small, { color: theme.warning, marginLeft: Spacing.sm, flex: 1 }]}>\n            Connection issue. Tap to retry\n          </ThemedText>\n          <ActivityIndicator size=\"small\" color={theme.warning} />\n        </Pressable>\n      ) : null}\n\n      <View style={styles.header}>\n        <ThemedText style={[Typography.h1, { color: theme.text }]}>Split</ThemedText>\n        <Pressable\n          style={({ pressed }) => [styles.notificationButton, { opacity: pressed ? 0.7 : 1 }]}\n          onPress={() => navigation.navigate('Notifications')}\n        >\n          <Feather name=\"bell\" size={24} color={theme.text} />\n          {notifications > 0 ? (\n            <View style={[styles.notificationBadge, { backgroundColor: theme.danger }]}>\n              <ThemedText style={{ color: '#FFFFFF', fontSize: 11, fontWeight: '600' }}>\n                {notifications > 99 ? '99+' : notifications}\n              </ThemedText>\n            </View>\n          ) : null}\n        </Pressable>\n      </View>\n\n      {wallet ? (\n        <ThemedView style={[styles.walletCard, { backgroundColor: theme.surface, borderColor: theme.border }]}>\n          <View style={styles.walletHeader}>\n            <View style={[styles.walletIconContainer, { backgroundColor: theme.primary + '20' }]}>\n              <Feather name=\"dollar-sign\" size={24} color={theme.primary} />\n            </View>\n            <View style={styles.walletInfo}>\n              <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                Wallet Balance\n              </ThemedText>\n              <ThemedText style={[Typography.h1, { color: theme.text }]}>\n                ${parseFloat(wallet.balance.toString()).toFixed(2)}\n              </ThemedText>\n            </View>\n          </View>\n        </ThemedView>\n      ) : null}\n\n      <View style={[styles.segmentedControl, { backgroundColor: theme.backgroundSecondary }]}>\n        <Pressable\n          style={[\n            styles.segment,\n            selectedTab === 'in_progress' && { backgroundColor: theme.surface }\n          ]}\n          onPress={() => setSelectedTab('in_progress')}\n        >\n          <ThemedText \n            style={[\n              Typography.body,\n              { color: selectedTab === 'in_progress' ? theme.text : theme.textSecondary }\n            ]}\n          >\n            In Progress\n          </ThemedText>\n        </Pressable>\n        <Pressable\n          style={[\n            styles.segment,\n            selectedTab === 'completed' && { backgroundColor: theme.surface }\n          ]}\n          onPress={() => setSelectedTab('completed')}\n        >\n          <ThemedText \n            style={[\n              Typography.body,\n              { color: selectedTab === 'completed' ? theme.text : theme.textSecondary }\n            ]}\n          >\n            Completed\n          </ThemedText>\n        </Pressable>\n      </View>\n\n      <GestureDetector gesture={nativeScrollGesture}>\n        <FlatList\n          ref={scrollRef}\n          data={filteredEvents}\n          renderItem={renderEvent}\n          keyExtractor={(item) => item.id}\n          extraData={swipeOpenId}\n          contentContainerStyle={[\n            styles.listContent,\n            { paddingBottom: tabBarHeight + Spacing.xl + Spacing.fabSize }\n          ]}\n          refreshControl={\n            <RefreshControl refreshing={refreshing} onRefresh={onRefresh} tintColor={theme.primary} />\n          }\n          onScrollBeginDrag={() => updateSwipeOpenId(null)}\n          ListEmptyComponent={\n            <View style={styles.emptyState}>\n              <Feather name=\"inbox\" size={48} color={theme.textSecondary} />\n              <ThemedText style={[Typography.body, { color: theme.textSecondary, marginTop: Spacing.lg }]}>\n                {selectedTab === 'in_progress' ? 'No active splits' : 'No completed splits'}\n              </ThemedText>\n            </View>\n          }\n        />\n      </GestureDetector>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  networkBanner: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.sm,\n    marginHorizontal: Spacing.xl,\n    marginBottom: Spacing.sm,\n    borderRadius: BorderRadius.xs,\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.xl,\n    marginBottom: Spacing.lg,\n  },\n  notificationButton: {\n    padding: Spacing.sm,\n    position: 'relative',\n  },\n  notificationBadge: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n    minWidth: 18,\n    height: 18,\n    borderRadius: 9,\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingHorizontal: 4,\n  },\n  walletCard: {\n    marginHorizontal: Spacing.xl,\n    marginBottom: Spacing.lg,\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n  },\n  walletHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginBottom: Spacing.lg,\n  },\n  walletIconContainer: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    alignItems: 'center',\n    justifyContent: 'center',\n    marginRight: Spacing.md,\n  },\n  walletInfo: {\n    flex: 1,\n  },\n  segmentedControl: {\n    flexDirection: 'row',\n    marginHorizontal: Spacing.xl,\n    marginBottom: Spacing.lg,\n    padding: Spacing.xs,\n    borderRadius: BorderRadius.xs,\n  },\n  segment: {\n    flex: 1,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.xs - 2,\n    alignItems: 'center',\n  },\n  listContent: {\n    paddingHorizontal: Spacing.xl,\n  },\n  swipeableContainer: {\n    marginBottom: Spacing.lg,\n    position: 'relative',\n  },\n  deleteButtonContainer: {\n    position: 'absolute',\n    right: 0,\n    top: 0,\n    bottom: 0,\n    width: DELETE_BUTTON_WIDTH,\n    borderRadius: BorderRadius.sm,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  deleteButton: {\n    width: '100%',\n    height: '100%',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  swipeableCard: {\n    backgroundColor: 'transparent',\n  },\n  eventCard: {\n    marginBottom: Spacing.lg,\n  },\n  eventCardInner: {\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    overflow: 'hidden',\n    position: 'relative',\n  },\n  paidOverlay: {\n    ...StyleSheet.absoluteFillObject,\n    borderRadius: BorderRadius.sm,\n    overflow: 'hidden',\n  },\n  eventHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginBottom: Spacing.sm,\n  },\n  badgeContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  eventInfo: {\n    marginBottom: Spacing.md,\n  },\n  progressContainer: {\n    marginBottom: Spacing.md,\n  },\n  progressBar: {\n    height: 8,\n    borderRadius: 4,\n    overflow: 'hidden',\n  },\n  progressFill: {\n    height: '100%',\n    borderRadius: 4,\n  },\n  progressInfo: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginTop: Spacing.xs,\n  },\n  eventFooter: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n  },\n  participantCount: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  badge: {\n    paddingHorizontal: Spacing.sm,\n    paddingVertical: 2,\n    borderRadius: 4,\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  emptyState: {\n    alignItems: 'center',\n    paddingVertical: Spacing['2xl'] * 2,\n  },\n});\n","path":null,"size_bytes":29630,"size_tokens":null},"navigation/FriendsStackNavigator.tsx":{"content":"import React from 'react';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport FriendsScreen from '@/screens/FriendsScreen';\nimport AddFriendScreen from '@/screens/AddFriendScreen';\nimport { useTheme } from '@/hooks/useTheme';\nimport { getCommonScreenOptions } from './screenOptions';\n\nconst Stack = createNativeStackNavigator();\n\nexport default function FriendsStackNavigator() {\n  const { theme, isDark } = useTheme();\n\n  return (\n    <Stack.Navigator screenOptions={getCommonScreenOptions({ theme, isDark })}>\n      <Stack.Screen \n        name=\"Friends\" \n        component={FriendsScreen}\n        options={{ headerShown: false }}\n      />\n      <Stack.Screen \n        name=\"AddFriend\" \n        component={AddFriendScreen}\n        options={{ title: 'Add Friend' }}\n      />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":838,"size_tokens":null},"components/ErrorBoundary.tsx":{"content":"import React, { Component, ComponentType, PropsWithChildren } from \"react\";\nimport { ErrorFallback, ErrorFallbackProps } from \"@/components/ErrorFallback\";\n\nexport type ErrorBoundaryProps = PropsWithChildren<{\n  FallbackComponent?: ComponentType<ErrorFallbackProps>;\n  onError?: (error: Error, stackTrace: string) => void;\n}>;\n\ntype ErrorBoundaryState = { error: Error | null };\n\n/**\n * This is a special case for for using the class components. Error boundaries must be class components because React only provides error boundary functionality through lifecycle methods (componentDidCatch and getDerivedStateFromError) which are not available in functional components.\n * https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary\n */\n\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  state: ErrorBoundaryState = { error: null };\n\n  static defaultProps: {\n    FallbackComponent: ComponentType<ErrorFallbackProps>;\n  } = {\n    FallbackComponent: ErrorFallback,\n  };\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { error };\n  }\n\n  componentDidCatch(error: Error, info: { componentStack: string }): void {\n    if (typeof this.props.onError === \"function\") {\n      this.props.onError(error, info.componentStack);\n    }\n  }\n\n  resetError = (): void => {\n    this.setState({ error: null });\n  };\n\n  render() {\n    const { FallbackComponent } = this.props;\n\n    return this.state.error && FallbackComponent ? (\n      <FallbackComponent\n        error={this.state.error}\n        resetError={this.resetError}\n      />\n    ) : (\n      this.props.children\n    );\n  }\n}\n","path":null,"size_bytes":1674,"size_tokens":null},"hooks/useScreenInsets.ts":{"content":"import { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { useSafeBottomTabBarHeight } from \"./useSafeBottomTabBarHeight\";\n\nimport { Spacing } from \"@/constants/theme\";\n\nexport function useScreenInsets() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const tabBarHeight = useSafeBottomTabBarHeight();\n\n  return {\n    paddingTop: headerHeight + Spacing.xl,\n    paddingBottom: tabBarHeight + Spacing.xl,\n    scrollInsetBottom: insets.bottom + 16,\n  };\n}\n","path":null,"size_bytes":569,"size_tokens":null},"navigation/MainTabNavigator.tsx":{"content":"import React from \"react\";\nimport { View } from \"react-native\";\nimport { createBottomTabNavigator } from \"@react-navigation/bottom-tabs\";\nimport { Feather } from \"@expo/vector-icons\";\nimport RootStackNavigator from \"@/navigation/RootStackNavigator\";\nimport FriendsStackNavigator from \"@/navigation/FriendsStackNavigator\";\nimport WalletStackNavigator from \"@/navigation/WalletStackNavigator\";\nimport ProfileStackNavigator from \"@/navigation/ProfileStackNavigator\";\nimport { CustomTabBar } from \"@/components/CustomTabBar\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useAuth } from \"@/hooks/useAuth\";\nimport { usePushNotifications } from \"@/hooks/usePushNotifications\";\n\nexport type MainTabParamList = {\n  HomeTab: { screen?: string } | undefined;\n  FriendsTab: undefined;\n  CreateTab: undefined;\n  WalletTab: undefined;\n  ProfileTab: undefined;\n};\n\nconst Tab = createBottomTabNavigator<MainTabParamList>();\n\nexport default function MainTabNavigator() {\n  const { theme, isDark } = useTheme();\n  const { user } = useAuth();\n  \n  usePushNotifications(user?.id);\n\n  return (\n    <Tab.Navigator\n        initialRouteName=\"HomeTab\"\n        tabBar={(props) => <CustomTabBar {...props} />}\n        screenOptions={{\n          headerShown: false,\n        }}\n      >\n        <Tab.Screen\n          name=\"HomeTab\"\n          component={RootStackNavigator}\n          options={{\n            title: \"Home\",\n            tabBarIcon: ({ color, size }) => (\n              <Feather name=\"home\" size={size} color={color} />\n            ),\n          }}\n        />\n        <Tab.Screen\n          name=\"FriendsTab\"\n          component={FriendsStackNavigator}\n          options={{\n            title: \"Friends\",\n            tabBarIcon: ({ color, size }) => (\n              <Feather name=\"users\" size={size} color={color} />\n            ),\n          }}\n        />\n        <Tab.Screen\n          name=\"CreateTab\"\n          component={View}\n          options={{\n            title: \"\",\n            tabBarIcon: () => null,\n          }}\n          listeners={{\n            tabPress: (e) => {\n              e.preventDefault();\n            },\n          }}\n        />\n        <Tab.Screen\n          name=\"WalletTab\"\n          component={WalletStackNavigator}\n          options={{\n            title: \"Wallet\",\n            tabBarIcon: ({ color, size }) => (\n              <Feather name=\"credit-card\" size={size} color={color} />\n            ),\n          }}\n        />\n        <Tab.Screen\n          name=\"ProfileTab\"\n          component={ProfileStackNavigator}\n          options={{\n            title: \"Profile\",\n            tabBarIcon: ({ color, size }) => (\n              <Feather name=\"user\" size={size} color={color} />\n            ),\n          }}\n        />\n      </Tab.Navigator>\n  );\n}\n","path":null,"size_bytes":2758,"size_tokens":null},"eslint.config.js":{"content":"// https://docs.expo.dev/guides/using-eslint/\nconst { defineConfig } = require(\"eslint/config\");\nconst expoConfig = require(\"eslint-config-expo/flat\");\nconst eslintPluginPrettierRecommended = require(\"eslint-plugin-prettier/recommended\");\n\nmodule.exports = defineConfig([\n  expoConfig,\n  eslintPluginPrettierRecommended,\n  {\n    ignores: [\"dist/*\"],\n  },\n]);\n","path":null,"size_bytes":359,"size_tokens":null},"scripts/build.js":{"content":"const fs = require(\"fs\");\nconst path = require(\"path\");\nconst { spawn } = require(\"child_process\");\nconst { Readable } = require(\"stream\");\nconst { pipeline } = require(\"stream/promises\");\n\nlet metroProcess = null;\n\nfunction exitWithError(message) {\n  console.error(message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n}\n\nfunction setupSignalHandlers() {\n  const cleanup = () => {\n    if (metroProcess) {\n      console.log(\"Cleaning up Metro process...\");\n      metroProcess.kill();\n    }\n    process.exit(0);\n  };\n\n  process.on(\"SIGINT\", cleanup);\n  process.on(\"SIGTERM\", cleanup);\n  process.on(\"SIGHUP\", cleanup);\n}\n\nfunction getDeploymentUrl() {\n  if (process.env.REPLIT_INTERNAL_APP_DOMAIN) {\n    const url = `https://${process.env.REPLIT_INTERNAL_APP_DOMAIN}`;\n    console.log(\"Using REPLIT_INTERNAL_APP_DOMAIN:\", url);\n    return url;\n  }\n\n  if (process.env.REPLIT_DEV_DOMAIN) {\n    const url = `https://${process.env.REPLIT_DEV_DOMAIN}`;\n    console.log(\"Using REPLIT_DEV_DOMAIN:\", url);\n    return url;\n  }\n\n  console.error(\n    \"ERROR: REPLIT_INTERNAL_APP_DOMAIN and REPLIT_DEV_DOMAIN not set\",\n  );\n  process.exit(1);\n}\n\nfunction prepareDirectories(timestamp) {\n  console.log(\"Preparing build directories...\");\n\n  if (fs.existsSync(\"static-build\")) {\n    fs.rmSync(\"static-build\", { recursive: true });\n  }\n\n  const dirs = [\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"ios\"),\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"android\"),\n    path.join(\"static-build\", \"ios\"),\n    path.join(\"static-build\", \"android\"),\n  ];\n\n  for (const dir of dirs) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n\n  console.log(\"Build:\", timestamp);\n}\n\nfunction clearMetroCache() {\n  console.log(\"Clearing Metro cache...\");\n\n  const cacheDirs = [\n    ...fs.globSync(\".metro-cache\"),\n    ...fs.globSync(\"node_modules/.cache/metro\"),\n  ];\n\n  for (const dir of cacheDirs) {\n    fs.rmSync(dir, { recursive: true, force: true });\n  }\n\n  console.log(\"Cache cleared\");\n}\n\nasync function checkMetroHealth() {\n  try {\n    const response = await fetch(\"http://localhost:8081/status\");\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\nasync function startMetro() {\n  const isRunning = await checkMetroHealth();\n  if (isRunning) {\n    return;\n  }\n\n  console.log(\"Starting Metro...\");\n  metroProcess = spawn(\"npm\", [\"run\", \"dev\"], {\n    stdio: [\"ignore\", \"ignore\", \"ignore\"],\n    detached: false,\n  });\n\n  for (let i = 0; i < 30; i++) {\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n    const healthy = await checkMetroHealth();\n    if (healthy) {\n      console.log(\"Metro ready\");\n      return;\n    }\n  }\n\n  console.error(\"Metro timeout\");\n  process.exit(1);\n}\n\nasync function downloadFile(url, outputPath) {\n  try {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const file = fs.createWriteStream(outputPath);\n    await pipeline(Readable.fromWeb(response.body), file);\n\n    const fileSize = fs.statSync(outputPath).size;\n\n    if (fileSize === 0) {\n      fs.unlinkSync(outputPath);\n      throw new Error(\"Downloaded file is empty\");\n    }\n  } catch (error) {\n    if (fs.existsSync(outputPath)) {\n      fs.unlinkSync(outputPath);\n    }\n    throw error;\n  }\n}\n\nasync function downloadBundle(platform, timestamp) {\n  const url = new URL(\"http://localhost:8081/index.bundle\");\n  url.searchParams.set(\"platform\", platform);\n  url.searchParams.set(\"dev\", \"false\");\n  url.searchParams.set(\"hot\", \"false\");\n  url.searchParams.set(\"lazy\", \"false\");\n  url.searchParams.set(\"minify\", \"true\");\n\n  const output = path.join(\n    \"static-build\",\n    timestamp,\n    \"_expo\",\n    \"static\",\n    \"js\",\n    platform,\n    \"bundle.js\",\n  );\n\n  try {\n    await downloadFile(url.toString(), output);\n  } catch (error) {\n    exitWithError(`Failed to download ${platform} bundle: ${error.message}`);\n  }\n}\n\nasync function downloadManifest(platform) {\n  const response = await fetch(\"http://localhost:8081/manifest\", {\n    headers: { \"expo-platform\": platform },\n  });\n\n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status}`);\n  }\n\n  return await response.json();\n}\n\nasync function downloadBundlesAndManifests(timestamp) {\n  console.log(\"Downloading bundles and manifests...\");\n\n  try {\n    const [, , iosManifest, androidManifest] = await Promise.all([\n      downloadBundle(\"ios\", timestamp),\n      downloadBundle(\"android\", timestamp),\n      downloadManifest(\"ios\"),\n      downloadManifest(\"android\"),\n    ]);\n    console.log(\"Downloaded\");\n    return { ios: iosManifest, android: androidManifest };\n  } catch (error) {\n    exitWithError(`Download failed: ${error.message}`);\n  }\n}\n\nfunction extractAssets(timestamp) {\n  const bundles = {\n    ios: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"ios\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n    android: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"android\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n  };\n\n  const assetsMap = new Map();\n  const assetPattern =\n    /httpServerLocation:\"([^\"]+)\"[^}]*hash:\"([^\"]+)\"[^}]*name:\"([^\"]+)\"[^}]*type:\"([^\"]+)\"/g;\n\n  const extractFromBundle = (bundle, platform) => {\n    for (const match of bundle.matchAll(assetPattern)) {\n      const originalPath = match[1];\n      const filename = match[3] + \".\" + match[4];\n\n      const tempUrl = new URL(`http://localhost:8081${originalPath}`);\n      const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n      if (!unstablePath) {\n        throw new Error(`Asset missing unstable_path: ${originalPath}`);\n      }\n\n      const decodedPath = decodeURIComponent(unstablePath).replace(/^\\.\\//, \"\");\n      const key = path.posix.join(decodedPath, filename);\n\n      if (!assetsMap.has(key)) {\n        const asset = {\n          url: path.posix.join(\"/\", decodedPath, filename),\n          originalPath: originalPath,\n          filename: filename,\n          relativePath: decodedPath,\n          hash: match[2],\n          platforms: new Set(),\n        };\n\n        assetsMap.set(key, asset);\n      }\n      assetsMap.get(key).platforms.add(platform);\n    }\n  };\n\n  extractFromBundle(bundles.ios, \"ios\");\n  extractFromBundle(bundles.android, \"android\");\n\n  return Array.from(assetsMap.values());\n}\n\nasync function downloadAssets(assets, timestamp) {\n  if (assets.length === 0) {\n    return 0;\n  }\n\n  console.log(\"Downloading assets...\");\n  let successCount = 0;\n  const failures = [];\n\n  const downloadPromises = assets.map(async (asset) => {\n    const platform = Array.from(asset.platforms)[0];\n\n    const tempUrl = new URL(`http://localhost:8081${asset.originalPath}`);\n    const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n    if (!unstablePath) {\n      throw new Error(`Asset missing unstable_path: ${asset.originalPath}`);\n    }\n\n    const decodedPath = decodeURIComponent(unstablePath).replace(/^\\./, \"\");\n    const metroUrl = new URL(\n      `http://localhost:8081${path.posix.join(\"/assets\", decodedPath, asset.filename)}`,\n    );\n    metroUrl.searchParams.set(\"platform\", platform);\n    metroUrl.searchParams.set(\"hash\", asset.hash);\n\n    const outputDir = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      asset.relativePath,\n    );\n    fs.mkdirSync(outputDir, { recursive: true });\n    const output = path.join(outputDir, asset.filename);\n\n    try {\n      await downloadFile(metroUrl.toString(), output);\n      successCount++;\n    } catch (error) {\n      failures.push({\n        filename: asset.filename,\n        error: error.message,\n        url: metroUrl.toString(),\n      });\n    }\n  });\n\n  await Promise.all(downloadPromises);\n\n  if (failures.length > 0) {\n    const errorMsg =\n      `Failed to download ${failures.length} asset(s):\\n` +\n      failures\n        .map((f) => `  - ${f.filename}: ${f.error} (${f.url})`)\n        .join(\"\\n\");\n    exitWithError(errorMsg);\n  }\n\n  console.log(`Downloaded ${successCount} assets`);\n  return successCount;\n}\n\nfunction updateBundleUrls(timestamp, baseUrl) {\n  const updateForPlatform = (platform) => {\n    const bundlePath = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      platform,\n      \"bundle.js\",\n    );\n    let bundle = fs.readFileSync(bundlePath, \"utf-8\");\n\n    bundle = bundle.replace(\n      /httpServerLocation:\"(\\/[^\"]+)\"/g,\n      (_match, capturedPath) => {\n        const tempUrl = new URL(`http://localhost:8081${capturedPath}`);\n        const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n        if (!unstablePath) {\n          throw new Error(\n            `Asset missing unstable_path in bundle: ${capturedPath}`,\n          );\n        }\n\n        const decodedPath = decodeURIComponent(unstablePath).replace(\n          /^\\.\\//,\n          \"\",\n        );\n        return `httpServerLocation:\"${baseUrl}/${timestamp}/_expo/static/js/${decodedPath}\"`;\n      },\n    );\n\n    fs.writeFileSync(bundlePath, bundle);\n  };\n\n  updateForPlatform(\"ios\");\n  updateForPlatform(\"android\");\n  console.log(\"Updated bundle URLs\");\n}\n\nfunction updateManifests(manifests, timestamp, baseUrl, assetsByHash) {\n  const updateForPlatform = (platform, manifest) => {\n    if (!manifest.launchAsset || !manifest.extra) {\n      exitWithError(`Malformed manifest for ${platform}`);\n    }\n\n    manifest.launchAsset.url = `${baseUrl}/${timestamp}/_expo/static/js/${platform}/bundle.js`;\n    manifest.launchAsset.key = `bundle-${timestamp}`;\n    manifest.createdAt = new Date(\n      Number(timestamp.split(\"-\")[0]),\n    ).toISOString();\n    manifest.extra.expoClient.hostUri =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.debuggerHost =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.packagerOpts.dev = false;\n\n    if (manifest.assets && manifest.assets.length > 0) {\n      manifest.assets.forEach((asset) => {\n        if (!asset.url) return;\n\n        const hash = asset.hash;\n        if (!hash) return;\n\n        const assetInfo = assetsByHash.get(hash);\n        if (!assetInfo) return;\n\n        asset.url = `${baseUrl}/${timestamp}/_expo/static/js/${assetInfo.relativePath}/${assetInfo.filename}`;\n      });\n    }\n\n    fs.writeFileSync(\n      path.join(\"static-build\", platform, \"manifest.json\"),\n      JSON.stringify(manifest, null, 2),\n    );\n  };\n\n  updateForPlatform(\"ios\", manifests.ios);\n  updateForPlatform(\"android\", manifests.android);\n  console.log(\"Manifests updated\");\n}\n\nfunction createLandingPage(baseUrl) {\n  const expsUrl = baseUrl.replace(\"https://\", \"\");\n  const template = fs.readFileSync(\n    path.join(\"scripts\", \"landing-page-template.html\"),\n    \"utf-8\",\n  );\n\n  const html = template\n    .replace(/BASE_URL_PLACEHOLDER/g, baseUrl)\n    .replace(/EXPS_URL_PLACEHOLDER/g, expsUrl);\n\n  fs.writeFileSync(path.join(\"static-build\", \"index.html\"), html);\n  console.log(\"Complete\");\n}\n\nfunction buildServer() {\n  console.log(\"Building server TypeScript...\");\n  \n  const serverDistPath = path.join(\"server\", \"dist\");\n  \n  // Clean previous build\n  if (fs.existsSync(serverDistPath)) {\n    fs.rmSync(serverDistPath, { recursive: true });\n  }\n  \n  // Compile TypeScript\n  const result = require(\"child_process\").spawnSync(\n    \"npx\", \n    [\"tsc\", \"--project\", \"server/tsconfig.json\"],\n    { stdio: \"inherit\", shell: true }\n  );\n  \n  if (result.status !== 0) {\n    exitWithError(\"Server TypeScript compilation failed\");\n  }\n  \n  // Copy public folder to dist (server uses __dirname for static files)\n  const srcPublic = path.join(\"server\", \"public\");\n  const destPublic = path.join(serverDistPath, \"public\");\n  \n  if (fs.existsSync(srcPublic)) {\n    fs.cpSync(srcPublic, destPublic, { recursive: true });\n    console.log(\"Copied server public folder to dist\");\n  }\n  \n  console.log(\"Server build complete\");\n}\n\nasync function main() {\n  console.log(\"Building static Expo Go deployment...\");\n\n  setupSignalHandlers();\n  \n  // Build server first\n  buildServer();\n\n  const baseUrl = getDeploymentUrl();\n  const timestamp = `${Date.now()}-${process.pid}`;\n\n  prepareDirectories(timestamp);\n  clearMetroCache();\n\n  await startMetro();\n  const manifests = await downloadBundlesAndManifests(timestamp);\n\n  console.log(\"Processing assets...\");\n  const assets = extractAssets(timestamp);\n  console.log(\"Found\", assets.length, \"unique asset(s)\");\n\n  const assetsByHash = new Map();\n  for (const asset of assets) {\n    assetsByHash.set(asset.hash, {\n      relativePath: asset.relativePath,\n      filename: asset.filename,\n    });\n  }\n\n  const assetCount = await downloadAssets(assets, timestamp);\n\n  if (assetCount > 0) {\n    updateBundleUrls(timestamp, baseUrl);\n  }\n\n  console.log(\"Updating manifests and creating landing page...\");\n  updateManifests(manifests, timestamp, baseUrl, assetsByHash);\n  createLandingPage(baseUrl);\n\n  console.log(\"Build complete! Deploy to:\", baseUrl);\n\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(0);\n}\n\nmain().catch((error) => {\n  console.error(\"Build failed:\", error.message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n});\n","path":null,"size_bytes":13313,"size_tokens":null},"babel.config.js":{"content":"module.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\"babel-preset-expo\"],\n    plugins: [\n      [\n        \"module-resolver\",\n        {\n          root: [\"./\"],\n          alias: {\n            \"@\": \"./\",\n          },\n          extensions: [\".ios.js\", \".android.js\", \".js\", \".ts\", \".tsx\", \".json\"],\n        },\n      ],\n      \"react-native-reanimated/plugin\",\n    ],\n  };\n};\n","path":null,"size_bytes":395,"size_tokens":null},"navigation/AuthStackNavigator.tsx":{"content":"import React from 'react';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport WelcomeScreen from '@/screens/WelcomeScreen';\nimport LoginScreen from '@/screens/LoginScreen';\nimport ForgotPasswordScreen from '@/screens/ForgotPasswordScreen';\nimport ResetPasswordScreen from '@/screens/ResetPasswordScreen';\nimport SignupFirstNameScreen from '@/screens/SignupFirstNameScreen';\nimport SignupLastNameScreen from '@/screens/SignupLastNameScreen';\nimport SignupEmailScreen from '@/screens/SignupEmailScreen';\nimport SignupPasswordScreen from '@/screens/SignupPasswordScreen';\nimport SignupPhoneScreen from '@/screens/SignupPhoneScreen';\nimport SignupPhoneOTPScreen from '@/screens/SignupPhoneOTPScreen';\nimport SignupDOBScreen from '@/screens/SignupDOBScreen';\nimport SignupProfilePictureScreen from '@/screens/SignupProfilePictureScreen';\nimport SignupBioScreen from '@/screens/SignupBioScreen';\nimport SignupCompleteScreen from '@/screens/SignupCompleteScreen';\nimport SocialSignupNameScreen from '@/screens/SocialSignupNameScreen';\nimport SocialSignupPhoneScreen from '@/screens/SocialSignupPhoneScreen';\nimport SocialSignupPhoneOTPScreen from '@/screens/SocialSignupPhoneOTPScreen';\nimport SocialSignupDOBScreen from '@/screens/SocialSignupDOBScreen';\nimport SocialSignupProfilePictureScreen from '@/screens/SocialSignupProfilePictureScreen';\nimport SocialSignupBioScreen from '@/screens/SocialSignupBioScreen';\nimport SocialSignupCompleteScreen from '@/screens/SocialSignupCompleteScreen';\nimport TermsScreen from '@/screens/TermsScreen';\nimport PrivacyPolicyScreen from '@/screens/PrivacyPolicyScreen';\nimport { useTheme } from '@/hooks/useTheme';\nimport { getCommonScreenOptions } from './screenOptions';\n\nconst Stack = createNativeStackNavigator();\n\nexport default function AuthStackNavigator() {\n  const { theme, isDark } = useTheme();\n\n  return (\n    <Stack.Navigator screenOptions={getCommonScreenOptions({ theme, isDark })}>\n      <Stack.Screen \n        name=\"Welcome\" \n        component={WelcomeScreen}\n        options={{ headerShown: false }}\n      />\n      <Stack.Screen \n        name=\"Login\" \n        component={LoginScreen}\n        options={{ headerShown: false }}\n      />\n      <Stack.Screen \n        name=\"ForgotPassword\" \n        component={ForgotPasswordScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"ResetPassword\" \n        component={ResetPasswordScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SignupFirstName\" \n        component={SignupFirstNameScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SignupLastName\" \n        component={SignupLastNameScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SignupEmail\" \n        component={SignupEmailScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SignupPassword\" \n        component={SignupPasswordScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SignupPhone\" \n        component={SignupPhoneScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SignupPhoneOTP\" \n        component={SignupPhoneOTPScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SignupDOB\" \n        component={SignupDOBScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SignupProfilePicture\" \n        component={SignupProfilePictureScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SignupBio\" \n        component={SignupBioScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SignupComplete\" \n        component={SignupCompleteScreen}\n        options={{ \n          headerShown: false,\n          gestureEnabled: false,\n        }}\n      />\n      <Stack.Screen \n        name=\"SocialSignupName\" \n        component={SocialSignupNameScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SocialSignupPhone\" \n        component={SocialSignupPhoneScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SocialSignupPhoneOTP\" \n        component={SocialSignupPhoneOTPScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SocialSignupDOB\" \n        component={SocialSignupDOBScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SocialSignupProfilePicture\" \n        component={SocialSignupProfilePictureScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SocialSignupBio\" \n        component={SocialSignupBioScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: '',\n          headerBackTitle: 'Back',\n        }}\n      />\n      <Stack.Screen \n        name=\"SocialSignupComplete\" \n        component={SocialSignupCompleteScreen}\n        options={{ \n          headerShown: false,\n          gestureEnabled: false,\n        }}\n      />\n      <Stack.Screen \n        name=\"Terms\" \n        component={TermsScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: 'Terms',\n          headerBackTitle: 'Back',\n          presentation: 'modal',\n        }}\n      />\n      <Stack.Screen \n        name=\"PrivacyPolicy\" \n        component={PrivacyPolicyScreen}\n        options={{ \n          headerTransparent: true,\n          headerTitle: 'Privacy',\n          headerBackTitle: 'Back',\n          presentation: 'modal',\n        }}\n      />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":7109,"size_tokens":null},"navigation/RootStackNavigator.tsx":{"content":"import React from 'react';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport MainHomeScreen from '@/screens/MainHomeScreen';\nimport EventDetailScreen from '@/screens/EventDetailScreen';\nimport NotificationsScreen from '@/screens/NotificationsScreen';\nimport CreateSplitSelectFriendsScreen from '@/screens/CreateSplitSelectFriendsScreen';\nimport CreateSplitTypeScreen from '@/screens/CreateSplitTypeScreen';\nimport CreateSplitDetailsScreen from '@/screens/CreateSplitDetailsScreen';\nimport { useTheme } from '@/hooks/useTheme';\nimport { getCommonScreenOptions } from './screenOptions';\n\nconst Stack = createNativeStackNavigator();\n\nexport default function RootStackNavigator() {\n  const { theme, isDark } = useTheme();\n\n  return (\n    <Stack.Navigator screenOptions={getCommonScreenOptions({ theme, isDark })}>\n      <Stack.Screen \n        name=\"MainHome\" \n        component={MainHomeScreen}\n        options={{ headerShown: false }}\n      />\n      <Stack.Screen \n        name=\"EventDetail\" \n        component={EventDetailScreen}\n        options={{ title: 'Event Details' }}\n      />\n      <Stack.Screen \n        name=\"Notifications\" \n        component={NotificationsScreen}\n        options={{ headerShown: false, presentation: 'modal' }}\n      />\n      <Stack.Screen \n        name=\"CreateSplitType\" \n        component={CreateSplitTypeScreen}\n        options={{ headerShown: false, presentation: 'modal' }}\n      />\n      <Stack.Screen \n        name=\"CreateSplitSelectFriends\" \n        component={CreateSplitSelectFriendsScreen}\n        options={{ headerShown: false }}\n      />\n      <Stack.Screen \n        name=\"CreateSplitDetails\" \n        component={CreateSplitDetailsScreen}\n        options={{ title: 'Event Details' }}\n      />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":1796,"size_tokens":null},"screens/LoginScreen.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, Alert, Platform, ActivityIndicator } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { SocialAuthService } from '@/services/socialAuth.service';\n\ntype Props = NativeStackScreenProps<any, 'Login'>;\n\nexport default function LoginScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n  const { login, refreshUser, setSocialSignupInProgress, clearSignupOverlay } = useAuth();\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [appleLoading, setAppleLoading] = useState(false);\n  const [googleLoading, setGoogleLoading] = useState(false);\n  const [showAppleButton, setShowAppleButton] = useState(false);\n\n  useEffect(() => {\n    SocialAuthService.isAppleSignInAvailable().then(setShowAppleButton);\n  }, []);\n\n  const handleLogin = async () => {\n    if (!email || !password) {\n      Alert.alert('Error', 'Please fill in all fields');\n      return;\n    }\n\n    setLoading(true);\n    try {\n      const success = await login(email, password);\n      if (!success) {\n        Alert.alert('Error', 'Invalid email or password');\n      }\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleSocialAuthResult = async (result: any, provider: 'apple' | 'google') => {\n    if (result.success && result.userId) {\n      if (result.needsName) {\n        clearSignupOverlay();\n        navigation.navigate('SocialSignupName', {\n          userId: result.userId,\n          email: result.email,\n          provider,\n          needsPhone: result.needsPhoneVerification,\n          needsDOB: result.needsDOB,\n          existingPhone: result.existingPhone,\n        });\n      } else if (result.needsPhoneVerification) {\n        clearSignupOverlay();\n        navigation.navigate('SocialSignupPhone', {\n          userId: result.userId,\n          email: result.email,\n          fullName: result.fullName,\n          provider,\n        });\n      } else if (result.needsDOB) {\n        clearSignupOverlay();\n        navigation.navigate('SocialSignupDOB', {\n          userId: result.userId,\n          fullName: result.fullName,\n          provider,\n          phone: result.existingPhone,\n        });\n      } else {\n        await refreshUser();\n      }\n    } else {\n      setSocialSignupInProgress(false);\n      if (result.error && result.error !== 'Sign-in was cancelled' && result.error !== 'Google Sign-In was cancelled') {\n        Alert.alert('Sign-In Failed', result.error);\n      }\n    }\n  };\n\n  const handleAppleSignIn = async () => {\n    setAppleLoading(true);\n    setSocialSignupInProgress(true);\n    try {\n      const result = await SocialAuthService.signInWithApple();\n      await handleSocialAuthResult(result, 'apple');\n    } catch (error: any) {\n      setSocialSignupInProgress(false);\n      Alert.alert('Error', error.message || 'Apple Sign-In failed');\n    } finally {\n      setAppleLoading(false);\n    }\n  };\n\n  const handleGoogleSignIn = async () => {\n    setGoogleLoading(true);\n    setSocialSignupInProgress(true);\n    try {\n      const result = await SocialAuthService.signInWithGoogle();\n      await handleSocialAuthResult(result, 'google');\n    } catch (error: any) {\n      setSocialSignupInProgress(false);\n      Alert.alert('Error', error.message || 'Google Sign-In failed');\n    } finally {\n      setGoogleLoading(false);\n    }\n  };\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.sm }]}>\n          Welcome Back\n        </ThemedText>\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Sign in to continue splitting bills\n        </ThemedText>\n\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: theme.border \n          }]}\n          placeholder=\"Email\"\n          placeholderTextColor={theme.textSecondary}\n          value={email}\n          onChangeText={setEmail}\n          keyboardType=\"email-address\"\n          autoCapitalize=\"none\"\n          autoCorrect={false}\n        />\n\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: theme.border \n          }]}\n          placeholder=\"Password\"\n          placeholderTextColor={theme.textSecondary}\n          value={password}\n          onChangeText={setPassword}\n          secureTextEntry\n          autoCapitalize=\"none\"\n        />\n\n        <Pressable\n          style={({ pressed }) => [styles.forgotButton, { opacity: pressed ? 0.7 : 1 }]}\n          onPress={() => navigation.navigate('ForgotPassword')}\n        >\n          <ThemedText style={[Typography.caption, { color: theme.primary }]}>\n            Forgot Password?\n          </ThemedText>\n        </Pressable>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { backgroundColor: theme.primary, opacity: pressed ? 0.7 : 1 }\n          ]}\n          onPress={handleLogin}\n          disabled={loading}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            {loading ? 'Signing in...' : 'Sign In'}\n          </ThemedText>\n        </Pressable>\n\n        <Pressable\n          style={({ pressed }) => [styles.linkButton, { opacity: pressed ? 0.7 : 1 }]}\n          onPress={() => navigation.navigate('SignupFirstName')}\n        >\n          <ThemedText style={[Typography.body, { color: theme.primary }]}>\n            Don't have an account? Sign up\n          </ThemedText>\n        </Pressable>\n\n        <View style={styles.dividerContainer}>\n          <View style={[styles.divider, { backgroundColor: theme.border }]} />\n          <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginHorizontal: Spacing.md }]}>\n            or continue with\n          </ThemedText>\n          <View style={[styles.divider, { backgroundColor: theme.border }]} />\n        </View>\n\n        {showAppleButton && (\n          <Pressable\n            style={({ pressed }) => [\n              styles.socialButton,\n              { backgroundColor: '#000', opacity: pressed ? 0.8 : 1 }\n            ]}\n            onPress={handleAppleSignIn}\n            disabled={appleLoading}\n          >\n            {appleLoading ? (\n              <ActivityIndicator color=\"#fff\" size=\"small\" />\n            ) : (\n              <>\n                <Feather name=\"smartphone\" size={20} color=\"#fff\" style={styles.socialIcon} />\n                <ThemedText style={[Typography.body, { color: '#fff', fontWeight: '600' }]}>\n                  Continue with Apple\n                </ThemedText>\n              </>\n            )}\n          </Pressable>\n        )}\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.socialButton,\n            { backgroundColor: theme.surface, borderWidth: 1, borderColor: theme.border, opacity: pressed ? 0.8 : 1 }\n          ]}\n          onPress={handleGoogleSignIn}\n          disabled={googleLoading}\n        >\n          {googleLoading ? (\n            <ActivityIndicator color={theme.text} size=\"small\" />\n          ) : (\n            <>\n              <ThemedText style={[styles.googleIcon, { marginRight: Spacing.sm }]}>G</ThemedText>\n              <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n                Continue with Google\n              </ThemedText>\n            </>\n          )}\n        </Pressable>\n      </ThemedView>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  input: {\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    marginBottom: Spacing.lg,\n    fontSize: 16,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginTop: Spacing.sm,\n  },\n  forgotButton: {\n    alignSelf: 'flex-end',\n    marginBottom: Spacing.sm,\n  },\n  linkButton: {\n    marginTop: Spacing.xl,\n    alignItems: 'center',\n  },\n  dividerContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginTop: Spacing.xl,\n    marginBottom: Spacing.lg,\n  },\n  divider: {\n    flex: 1,\n    height: 1,\n  },\n  socialButton: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    flexDirection: 'row',\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginBottom: Spacing.md,\n  },\n  socialIcon: {\n    marginRight: Spacing.sm,\n  },\n  googleIcon: {\n    fontSize: 20,\n    fontWeight: '700',\n    color: '#4285F4',\n  },\n});\n","path":null,"size_bytes":9457,"size_tokens":null},"navigation/WalletStackNavigator.tsx":{"content":"import React from 'react';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport WalletScreen from '@/screens/WalletScreen';\nimport WithdrawalScreen from '@/screens/WithdrawalScreen';\nimport { useTheme } from '@/hooks/useTheme';\nimport { getCommonScreenOptions } from './screenOptions';\n\nconst Stack = createNativeStackNavigator();\n\nexport default function WalletStackNavigator() {\n  const { theme, isDark } = useTheme();\n\n  return (\n    <Stack.Navigator screenOptions={getCommonScreenOptions({ theme, isDark })}>\n      <Stack.Screen \n        name=\"Wallet\" \n        component={WalletScreen}\n        options={{ headerShown: false }}\n      />\n      <Stack.Screen \n        name=\"Withdrawal\" \n        component={WithdrawalScreen}\n        options={{ title: 'Withdraw Funds' }}\n      />\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":841,"size_tokens":null},"screens/ProfileSettingsScreen.tsx":{"content":"import React, { useState } from 'react';\nimport { View, StyleSheet, Pressable, Image, Alert, Platform, TextInput, ActivityIndicator, Modal, Linking, KeyboardAvoidingView, ScrollView } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport * as Clipboard from 'expo-clipboard';\nimport * as ImagePicker from 'expo-image-picker';\nimport * as MailComposer from 'expo-mail-composer';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenScrollView } from '@/components/ScreenScrollView';\nimport { ProfileStatsCard } from '@/components/ProfileStatsCard';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Spacing, BorderRadius, Typography, Colors } from '@/constants/theme';\nimport { AuthService } from '@/services/auth.service';\nimport { supabase } from '@/services/supabase';\nimport { User } from '@/shared/types';\n\ntype Props = NativeStackScreenProps<any, 'ProfileSettings'>;\n\nexport default function ProfileSettingsScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n  const { user, logout, updateUser, refreshUser } = useAuth();\n  const [uploading, setUploading] = useState(false);\n  const [isEditingBio, setIsEditingBio] = useState(false);\n  const [bioText, setBioText] = useState(user?.bio || '');\n  const [savingBio, setSavingBio] = useState(false);\n  const [loggingOut, setLoggingOut] = useState(false);\n  const [showSupportModal, setShowSupportModal] = useState(false);\n  const [supportMessage, setSupportMessage] = useState('');\n  const [sendingSupport, setSendingSupport] = useState(false);\n  const [showDeleteModal, setShowDeleteModal] = useState(false);\n  const [deletingAccount, setDeletingAccount] = useState(false);\n\n  const copyToClipboard = async () => {\n    if (user?.unique_id) {\n      await Clipboard.setStringAsync(user.unique_id);\n      Alert.alert('Copied!', 'Your unique ID has been copied');\n    }\n  };\n\n  const handleEditProfilePicture = async () => {\n    if (Platform.OS === 'web') {\n      const input = document.createElement('input');\n      input.type = 'file';\n      input.accept = 'image/*';\n      input.onchange = async (e: any) => {\n        const file = e.target?.files?.[0];\n        if (file && user) {\n          setUploading(true);\n          try {\n            const reader = new FileReader();\n            reader.onload = async () => {\n              const base64 = reader.result as string;\n              await AuthService.uploadProfilePictureWeb(user.id, file, file.name);\n              await refreshUser();\n              Alert.alert('Success', 'Profile picture updated');\n              setUploading(false);\n            };\n            reader.onerror = () => {\n              console.error('File read error');\n              Alert.alert('Error', 'Failed to read file');\n              setUploading(false);\n            };\n            reader.readAsDataURL(file);\n          } catch (error) {\n            console.error('Profile picture upload error:', error);\n            Alert.alert('Error', 'Failed to update profile picture');\n            setUploading(false);\n          }\n        }\n      };\n      input.click();\n      return;\n    }\n\n    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();\n    if (status !== 'granted') {\n      Alert.alert('Permission Required', 'Please allow access to your photos');\n      return;\n    }\n\n    const result = await ImagePicker.launchImageLibraryAsync({\n      mediaTypes: ImagePicker.MediaTypeOptions.Images,\n      allowsEditing: true,\n      aspect: [1, 1],\n      quality: 0.8,\n    });\n\n    if (!result.canceled && result.assets[0] && user) {\n      setUploading(true);\n      try {\n        await AuthService.uploadProfilePicture(user.id, result.assets[0].uri);\n        await refreshUser();\n        Alert.alert('Success', 'Profile picture updated');\n      } catch (error) {\n        console.error('Profile picture upload error:', error);\n        Alert.alert('Error', 'Failed to update profile picture');\n      } finally {\n        setUploading(false);\n      }\n    }\n  };\n\n  const handleSaveBio = async () => {\n    if (!user) return;\n\n    setSavingBio(true);\n    try {\n      await AuthService.updateProfile(user.id, { bio: bioText });\n      await updateUser({ bio: bioText });\n      setIsEditingBio(false);\n      Alert.alert('Success', 'Bio updated');\n    } catch (error) {\n      console.error('Bio update error:', error);\n      Alert.alert('Error', 'Failed to update bio');\n    } finally {\n      setSavingBio(false);\n    }\n  };\n\n  const handleCancelEditBio = () => {\n    setBioText(user?.bio || '');\n    setIsEditingBio(false);\n  };\n\n  const handleLogout = async () => {\n    const performLogout = () => {\n      setLoggingOut(true);\n      console.log('[Logout] Starting logout...');\n      \n      // Fire-and-forget logout - don't await to avoid UI hang\n      // logout() internally clears user state and signs out from Supabase\n      logout().catch(e => console.log('[Logout] Background logout error:', e));\n      \n      // Clear loading state immediately - user will see they're logged out\n      setLoggingOut(false);\n      console.log('[Logout] UI cleared, logout running in background');\n    };\n\n    if (Platform.OS === 'web') {\n      const confirmed = window.confirm('Are you sure you want to logout?');\n      if (confirmed) {\n        await performLogout();\n      }\n      return;\n    }\n    \n    Alert.alert(\n      'Logout',\n      'Are you sure you want to logout?',\n      [\n        { text: 'Cancel', style: 'cancel' },\n        {\n          text: 'Logout',\n          style: 'destructive',\n          onPress: performLogout,\n        },\n      ]\n    );\n  };\n\n  const handleSendSupport = async () => {\n    if (!user || !supportMessage.trim()) {\n      Alert.alert('Error', 'Please enter your message');\n      return;\n    }\n\n    setSendingSupport(true);\n    \n    const emailSubject = `Spline Support Request - User #${user.unique_id}`;\n    const emailBody = `\nSUPPORT REQUEST FROM SPLINE APP\n\nUser Information:\n- Name: ${user.name}\n- Email: ${user.email}\n- Unique ID: ${user.unique_id}\n- Phone: ${user.phone || 'Not provided'}\n- User ID: ${user.id}\n- Date of Birth: ${user.date_of_birth ? new Date(user.date_of_birth).toLocaleDateString() : 'Not provided'}\n- Bio: ${user.bio || 'Not set'}\n\n---\n\nMessage:\n${supportMessage}\n\n---\nSent from Spline App on ${Platform.OS} at ${new Date().toLocaleString()}\n    `.trim();\n\n    try {\n      if (Platform.OS === 'web') {\n        const mailtoUrl = `mailto:hzeng1217@gmail.com?subject=${encodeURIComponent(emailSubject)}&body=${encodeURIComponent(emailBody)}`;\n        await Linking.openURL(mailtoUrl);\n        Alert.alert('Email Opened', 'Your email app should now be open with the support request. Please send it to complete your request.');\n      } else {\n        const isAvailable = await MailComposer.isAvailableAsync();\n        if (!isAvailable) {\n          const mailtoUrl = `mailto:hzeng1217@gmail.com?subject=${encodeURIComponent(emailSubject)}&body=${encodeURIComponent(emailBody)}`;\n          await Linking.openURL(mailtoUrl);\n          Alert.alert('Email Opened', 'Your email app should now be open. Please send it to complete your request.');\n        } else {\n          await MailComposer.composeAsync({\n            recipients: ['hzeng1217@gmail.com'],\n            subject: emailSubject,\n            body: emailBody,\n          });\n        }\n      }\n      setSupportMessage('');\n      setShowSupportModal(false);\n    } catch (error) {\n      console.error('Support email error:', error);\n      Alert.alert('Error', 'Could not open email app. Please email hzeng1217@gmail.com directly.');\n    } finally {\n      setSendingSupport(false);\n    }\n  };\n\n  const handleDeleteAccount = async () => {\n    setDeletingAccount(true);\n    console.log('[DeleteAccount] Starting account deletion...');\n    \n    try {\n      // The AuthService.deleteAccount has its own 30 second timeout\n      await AuthService.deleteAccount();\n      \n      console.log('[DeleteAccount] Account deletion successful');\n      \n      // IMPORTANT: Clear loading state and close modal BEFORE calling logout\n      // because logout will set user to null, which causes this component to unmount\n      // If we don't clear state first, the loading indicator could get stuck\n      setDeletingAccount(false);\n      setShowDeleteModal(false);\n      \n      // Show success message before navigation\n      Alert.alert(\n        'Account Deleted',\n        'Your account has been successfully deleted. You will now be signed out.',\n        [\n          {\n            text: 'OK',\n            onPress: () => {\n              // Call logout from auth context to properly clear user state\n              // This is fire-and-forget since account is already deleted\n              logout().catch(e => console.log('[DeleteAccount] Logout cleanup:', e));\n            }\n          }\n        ]\n      );\n    } catch (error: any) {\n      console.error('[DeleteAccount] Error:', error);\n      \n      // Always clear loading state on error\n      setDeletingAccount(false);\n      \n      // Provide more specific error messages\n      let errorMessage = 'Failed to delete account.';\n      if (error.message?.includes('timed out')) {\n        errorMessage = 'The request timed out. Please check your internet connection and try again.';\n      } else if (error.message?.includes('Not authenticated')) {\n        errorMessage = 'Your session has expired. Please sign out and sign back in, then try again.';\n      } else if (error.message) {\n        errorMessage = error.message;\n      }\n      \n      Alert.alert('Error', errorMessage + ' If the problem persists, please contact support.');\n    }\n  };\n\n  if (!user) return null;\n\n  return (\n    <ScreenScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <View style={styles.profileHeader}>\n          <Pressable \n            style={styles.avatarContainer}\n            onPress={handleEditProfilePicture}\n            disabled={uploading}\n          >\n            <View style={[styles.avatar, { backgroundColor: theme.backgroundSecondary, borderWidth: 3, borderColor: theme.primary }]}>\n              {user.profile_picture ? (\n                <Image source={{ uri: user.profile_picture }} style={styles.avatarImage} />\n              ) : (\n                <Feather name=\"user\" size={56} color={theme.textSecondary} />\n              )}\n            </View>\n            <View style={[styles.editBadge, { backgroundColor: theme.primary }]}>\n              {uploading ? (\n                <ActivityIndicator size=\"small\" color=\"#FFFFFF\" />\n              ) : (\n                <Feather name=\"camera\" size={18} color=\"#FFFFFF\" />\n              )}\n            </View>\n          </Pressable>\n\n          <ThemedText style={[Typography.h1, { color: theme.text, marginTop: Spacing.xl, fontSize: 28, fontWeight: '700' }]}>\n            {user.name}\n          </ThemedText>\n          \n          <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginTop: Spacing.xs }]}>\n            {user.email}\n          </ThemedText>\n\n          <Pressable\n            style={[styles.idContainer, { backgroundColor: theme.backgroundSecondary, borderColor: theme.border }]}\n            onPress={copyToClipboard}\n          >\n            <Feather name=\"hash\" size={14} color={theme.primary} />\n            <ThemedText style={[Typography.caption, { color: theme.text, fontWeight: '600', marginLeft: Spacing.xs }]}>\n              {user.unique_id}\n            </ThemedText>\n            <View style={{ flex: 1 }} />\n            <Feather name=\"copy\" size={14} color={theme.primary} />\n          </Pressable>\n\n          <View style={styles.bioSection}>\n            {isEditingBio ? (\n              <>\n                <TextInput\n                  style={[\n                    styles.bioInput,\n                    {\n                      backgroundColor: theme.surface,\n                      borderColor: theme.border,\n                      color: theme.text,\n                    },\n                  ]}\n                  value={bioText}\n                  onChangeText={setBioText}\n                  placeholder=\"Tell us about yourself...\"\n                  placeholderTextColor={theme.textSecondary}\n                  multiline\n                  maxLength={150}\n                  editable={!savingBio}\n                />\n                <View style={styles.bioActions}>\n                  <Pressable\n                    style={({ pressed }) => [\n                      styles.bioButton,\n                      { backgroundColor: theme.surface, borderColor: theme.border, opacity: pressed ? 0.7 : 1 },\n                    ]}\n                    onPress={handleCancelEditBio}\n                    disabled={savingBio}\n                  >\n                    <ThemedText style={[Typography.small, { color: theme.textSecondary }]}>\n                      Cancel\n                    </ThemedText>\n                  </Pressable>\n                  <Pressable\n                    style={({ pressed }) => [\n                      styles.bioButton,\n                      { backgroundColor: theme.primary, opacity: pressed ? 0.7 : 1 },\n                    ]}\n                    onPress={handleSaveBio}\n                    disabled={savingBio}\n                  >\n                    {savingBio ? (\n                      <ActivityIndicator size=\"small\" color=\"#FFFFFF\" />\n                    ) : (\n                      <ThemedText style={[Typography.small, { color: '#FFFFFF', fontWeight: '600' }]}>\n                        Save\n                      </ThemedText>\n                    )}\n                  </Pressable>\n                </View>\n              </>\n            ) : (\n              <>\n                <ThemedText\n                  style={[\n                    Typography.body,\n                    {\n                      color: user.bio ? theme.text : theme.textSecondary,\n                      textAlign: 'center',\n                      fontStyle: user.bio ? 'normal' : 'italic',\n                    },\n                  ]}\n                >\n                  {user.bio || 'No bio yet'}\n                </ThemedText>\n                <Pressable\n                  style={({ pressed }) => [\n                    styles.editBioButton,\n                    { opacity: pressed ? 0.7 : 1 },\n                  ]}\n                  onPress={() => setIsEditingBio(true)}\n                >\n                  <Feather name=\"edit-2\" size={16} color={theme.primary} />\n                  <ThemedText style={[Typography.small, { color: theme.primary, marginLeft: Spacing.xs }]}>\n                    Edit Bio\n                  </ThemedText>\n                </Pressable>\n              </>\n            )}\n          </View>\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText style={[Typography.h2, { color: theme.text, marginBottom: Spacing.md }]}>\n            Your Stats\n          </ThemedText>\n          <ProfileStatsCard userId={user.id} showBadges={true} />\n        </View>\n\n        <View style={styles.section}>\n          <ThemedText style={[Typography.h2, { color: theme.text, marginBottom: Spacing.md }]}>\n            Account Info\n          </ThemedText>\n\n          <View style={[styles.infoCard, { backgroundColor: theme.surface, borderColor: theme.border }]}>\n            <View style={styles.infoRow}>\n              <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                Email\n              </ThemedText>\n              <ThemedText style={[Typography.body, { color: theme.text }]}>\n                {user.email}\n              </ThemedText>\n            </View>\n\n            {user.phone ? (\n              <>\n                <View style={[styles.divider, { backgroundColor: theme.border }]} />\n                <View style={styles.infoRow}>\n                  <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                    Phone\n                  </ThemedText>\n                  <ThemedText style={[Typography.body, { color: theme.text }]}>\n                    {user.phone}\n                  </ThemedText>\n                </View>\n              </>\n            ) : null}\n\n            {user.date_of_birth ? (\n              <>\n                <View style={[styles.divider, { backgroundColor: theme.border }]} />\n                <View style={styles.infoRow}>\n                  <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n                    Date of Birth\n                  </ThemedText>\n                  <ThemedText style={[Typography.body, { color: theme.text }]}>\n                    {new Date(user.date_of_birth).toLocaleDateString()}\n                  </ThemedText>\n                </View>\n              </>\n            ) : null}\n          </View>\n        </View>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.supportButton,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed ? 0.7 : 1 \n            }\n          ]}\n          onPress={() => setShowSupportModal(true)}\n        >\n          <Feather name=\"help-circle\" size={20} color=\"#FFFFFF\" />\n          <ThemedText style={[Typography.body, { color: '#FFFFFF', marginLeft: Spacing.md, fontWeight: '600' }]}>\n            Contact Support\n          </ThemedText>\n        </Pressable>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.logoutButton,\n            { \n              backgroundColor: theme.surface, \n              borderColor: theme.border,\n              opacity: pressed ? 0.7 : 1 \n            }\n          ]}\n          onPress={handleLogout}\n          disabled={loggingOut}\n        >\n          {loggingOut ? (\n            <ActivityIndicator size=\"small\" color={theme.textSecondary} />\n          ) : (\n            <>\n              <Feather name=\"log-out\" size={20} color={theme.textSecondary} />\n              <ThemedText style={[Typography.body, { color: theme.textSecondary, marginLeft: Spacing.md, fontWeight: '600' }]}>\n                Sign Out\n              </ThemedText>\n            </>\n          )}\n        </Pressable>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.deleteAccountButton,\n            { \n              opacity: pressed ? 0.7 : 1 \n            }\n          ]}\n          onPress={() => setShowDeleteModal(true)}\n        >\n          <Feather name=\"trash-2\" size={18} color={Colors.light.danger} />\n          <ThemedText style={[Typography.body, { color: Colors.light.danger, marginLeft: Spacing.sm, fontWeight: '500' }]}>\n            Delete Account\n          </ThemedText>\n        </Pressable>\n      </ThemedView>\n\n      <Modal\n        visible={showSupportModal}\n        animationType=\"fade\"\n        transparent\n        onRequestClose={() => setShowSupportModal(false)}\n      >\n        <KeyboardAvoidingView \n          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n          style={styles.modalOverlay}\n        >\n          <Pressable \n            style={styles.modalBackdrop} \n            onPress={() => {\n              setShowSupportModal(false);\n              setSupportMessage('');\n            }}\n          />\n          <View style={[styles.modalContent, { backgroundColor: theme.background }]}>\n            <View style={styles.modalHeader}>\n              <ThemedText style={[Typography.h2, { color: theme.text }]}>\n                Contact Support\n              </ThemedText>\n              <Pressable\n                onPress={() => {\n                  setShowSupportModal(false);\n                  setSupportMessage('');\n                }}\n                hitSlop={8}\n              >\n                <Feather name=\"x\" size={24} color={theme.textSecondary} />\n              </Pressable>\n            </View>\n\n            <ThemedText style={[Typography.body, { color: theme.textSecondary, marginTop: Spacing.md }]}>\n              Describe your issue or question below. Your account information will be included automatically.\n            </ThemedText>\n\n            <TextInput\n              style={[\n                styles.supportInput,\n                {\n                  backgroundColor: theme.surface,\n                  borderColor: theme.border,\n                  color: theme.text,\n                }\n              ]}\n              value={supportMessage}\n              onChangeText={setSupportMessage}\n              placeholder=\"How can we help you?\"\n              placeholderTextColor={theme.textSecondary}\n              multiline\n              textAlignVertical=\"top\"\n              maxLength={1000}\n              editable={!sendingSupport}\n            />\n\n            <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginTop: Spacing.xs, textAlign: 'right' }]}>\n              {supportMessage.length}/1000\n            </ThemedText>\n\n            <View style={styles.modalButtons}>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.modalButton,\n                  { backgroundColor: theme.surface, borderColor: theme.border, borderWidth: 1, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={() => {\n                  setShowSupportModal(false);\n                  setSupportMessage('');\n                }}\n                disabled={sendingSupport}\n              >\n                <ThemedText style={[Typography.body, { color: theme.textSecondary, fontWeight: '600' }]}>\n                  Cancel\n                </ThemedText>\n              </Pressable>\n\n              <Pressable\n                style={({ pressed }) => [\n                  styles.modalButton,\n                  { backgroundColor: theme.primary, opacity: pressed || sendingSupport ? 0.7 : 1 }\n                ]}\n                onPress={handleSendSupport}\n                disabled={sendingSupport || !supportMessage.trim()}\n              >\n                {sendingSupport ? (\n                  <ActivityIndicator size=\"small\" color=\"#FFFFFF\" />\n                ) : (\n                  <ThemedText style={[Typography.body, { color: '#FFFFFF', fontWeight: '600' }]}>\n                    Send\n                  </ThemedText>\n                )}\n              </Pressable>\n            </View>\n          </View>\n        </KeyboardAvoidingView>\n      </Modal>\n\n      <Modal\n        visible={showDeleteModal}\n        animationType=\"fade\"\n        transparent\n        onRequestClose={() => setShowDeleteModal(false)}\n      >\n        <View style={styles.modalOverlay}>\n          <Pressable \n            style={styles.modalBackdrop} \n            onPress={() => !deletingAccount && setShowDeleteModal(false)}\n          />\n          <View style={[styles.deleteModalContent, { backgroundColor: theme.background }]}>\n            <View style={styles.deleteModalIcon}>\n              <Feather name=\"alert-triangle\" size={48} color={Colors.light.danger} />\n            </View>\n\n            <ThemedText style={[Typography.h2, { color: theme.text, textAlign: 'center', marginTop: Spacing.lg }]}>\n              Delete Account?\n            </ThemedText>\n\n            <ThemedText style={[Typography.body, { color: theme.textSecondary, textAlign: 'center', marginTop: Spacing.md, lineHeight: 22 }]}>\n              This action is permanent and cannot be undone. Before proceeding, please be aware:\n            </ThemedText>\n\n            <View style={[styles.warningBox, { backgroundColor: `${Colors.light.danger}10`, borderColor: `${Colors.light.danger}30` }]}>\n              <View style={styles.warningItem}>\n                <Feather name=\"x-circle\" size={16} color={Colors.light.danger} />\n                <ThemedText style={[Typography.small, { color: theme.text, marginLeft: Spacing.sm, flex: 1 }]}>\n                  Any remaining wallet balance will be forfeited\n                </ThemedText>\n              </View>\n              <View style={styles.warningItem}>\n                <Feather name=\"x-circle\" size={16} color={Colors.light.danger} />\n                <ThemedText style={[Typography.small, { color: theme.text, marginLeft: Spacing.sm, flex: 1 }]}>\n                  All payment history and splits will be permanently deleted\n                </ThemedText>\n              </View>\n              <View style={styles.warningItem}>\n                <Feather name=\"x-circle\" size={16} color={Colors.light.danger} />\n                <ThemedText style={[Typography.small, { color: theme.text, marginLeft: Spacing.sm, flex: 1 }]}>\n                  Your account cannot be recovered once deleted\n                </ThemedText>\n              </View>\n            </View>\n\n            <ThemedText style={[Typography.caption, { color: theme.textSecondary, textAlign: 'center', marginTop: Spacing.md, fontStyle: 'italic' }]}>\n              To avoid losing funds, please withdraw your remaining balance before deleting your account.\n            </ThemedText>\n\n            <View style={styles.modalButtons}>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.modalButton,\n                  { backgroundColor: theme.surface, borderColor: theme.border, borderWidth: 1, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={() => setShowDeleteModal(false)}\n                disabled={deletingAccount}\n              >\n                <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n                  Cancel\n                </ThemedText>\n              </Pressable>\n\n              <Pressable\n                style={({ pressed }) => [\n                  styles.modalButton,\n                  { backgroundColor: Colors.light.danger, opacity: pressed || deletingAccount ? 0.7 : 1 }\n                ]}\n                onPress={handleDeleteAccount}\n                disabled={deletingAccount}\n              >\n                {deletingAccount ? (\n                  <ActivityIndicator size=\"small\" color=\"#FFFFFF\" />\n                ) : (\n                  <ThemedText style={[Typography.body, { color: '#FFFFFF', fontWeight: '600' }]}>\n                    Delete Account\n                  </ThemedText>\n                )}\n              </Pressable>\n            </View>\n          </View>\n        </View>\n      </Modal>\n    </ScreenScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    paddingHorizontal: Spacing.xl,\n  },\n  profileHeader: {\n    alignItems: 'center',\n    paddingTop: Spacing['2xl'],\n    paddingBottom: Spacing.xl,\n  },\n  avatarContainer: {\n    position: 'relative',\n  },\n  avatar: {\n    width: 140,\n    height: 140,\n    borderRadius: 70,\n    justifyContent: 'center',\n    alignItems: 'center',\n    overflow: 'hidden',\n  },\n  avatarImage: {\n    width: '100%',\n    height: '100%',\n  },\n  editBadge: {\n    position: 'absolute',\n    bottom: 8,\n    right: 8,\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderWidth: 3,\n    borderColor: '#FFFFFF',\n  },\n  idContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.xl,\n    borderWidth: 1,\n    marginTop: Spacing.lg,\n  },\n  section: {\n    marginTop: Spacing.xl,\n  },\n  infoCard: {\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    padding: Spacing.lg,\n  },\n  infoRow: {\n    paddingVertical: Spacing.md,\n  },\n  divider: {\n    height: 1,\n  },\n  logoutButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.xs,\n    borderWidth: 1,\n    marginTop: Spacing['2xl'],\n    marginBottom: Spacing.xl,\n  },\n  bioSection: {\n    marginTop: Spacing.lg,\n    width: '100%',\n    alignItems: 'center',\n  },\n  bioInput: {\n    width: '100%',\n    minHeight: 80,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    padding: Spacing.md,\n    fontSize: 15,\n    textAlignVertical: 'top',\n  },\n  bioActions: {\n    flexDirection: 'row',\n    gap: Spacing.md,\n    marginTop: Spacing.md,\n  },\n  bioButton: {\n    paddingVertical: Spacing.sm,\n    paddingHorizontal: Spacing.lg,\n    borderRadius: BorderRadius.xs,\n    borderWidth: 1,\n    minWidth: 80,\n    alignItems: 'center',\n  },\n  editBioButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginTop: Spacing.sm,\n  },\n  supportButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.xs,\n    marginTop: Spacing['2xl'],\n  },\n  modalOverlay: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  modalBackdrop: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n  },\n  modalContent: {\n    borderRadius: BorderRadius.lg,\n    padding: Spacing.xl,\n    marginHorizontal: Spacing.lg,\n    width: '90%',\n    maxWidth: 400,\n  },\n  modalHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n  },\n  supportInput: {\n    minHeight: 150,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    padding: Spacing.md,\n    marginTop: Spacing.lg,\n    fontSize: 16,\n  },\n  modalButtons: {\n    flexDirection: 'row',\n    gap: Spacing.md,\n    marginTop: Spacing.lg,\n  },\n  modalButton: {\n    flex: 1,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.xs,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  deleteAccountButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: Spacing.md,\n    marginTop: Spacing.lg,\n    marginBottom: Spacing['2xl'],\n  },\n  deleteModalContent: {\n    borderRadius: BorderRadius.lg,\n    padding: Spacing.xl,\n    marginHorizontal: Spacing.lg,\n    width: '90%',\n    maxWidth: 400,\n  },\n  deleteModalIcon: {\n    alignItems: 'center',\n    marginTop: Spacing.md,\n  },\n  warningBox: {\n    marginTop: Spacing.lg,\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n  },\n  warningItem: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    marginVertical: Spacing.xs,\n  },\n});\n","path":null,"size_bytes":30183,"size_tokens":null},"screens/CreateSplitSelectFriendsScreen.tsx":{"content":"import React, { useState, useEffect, useMemo } from 'react';\nimport { View, StyleSheet, Pressable, FlatList, Image, ActivityIndicator, TextInput } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { FriendsService } from '@/services/friends.service';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\n\ntype Props = NativeStackScreenProps<any, 'CreateSplitSelectFriends'>;\n\ninterface FriendWithDetails {\n  id: string;\n  user_id: string;\n  friend_id: string;\n  status: string;\n  friend_details: {\n    id: string;\n    unique_id: string;\n    name: string;\n    email: string;\n    profile_picture?: string;\n  };\n}\n\nexport default function CreateSplitSelectFriendsScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const { user } = useAuth();\n  const insets = useSafeAreaInsets();\n  const params = route.params as { splitType?: 'equal' | 'specified' } | undefined;\n  const splitType = params?.splitType;\n  const [friends, setFriends] = useState<FriendWithDetails[]>([]);\n  const [selected, setSelected] = useState<Set<string>>(new Set());\n  const [loading, setLoading] = useState(true);\n  const [searchQuery, setSearchQuery] = useState('');\n\n  React.useEffect(() => {\n    if (!splitType) {\n      navigation.goBack();\n    }\n  }, [splitType, navigation]);\n\n  useEffect(() => {\n    loadFriends();\n  }, [user?.id]);\n\n  const loadFriends = async () => {\n    if (!user?.id) return;\n    try {\n      setLoading(true);\n      const data = await FriendsService.getFriends(user.id);\n      setFriends(data as FriendWithDetails[]);\n    } catch (error) {\n      console.error('Failed to load friends:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const filteredFriends = useMemo(() => {\n    if (!searchQuery.trim()) return friends;\n    const query = searchQuery.toLowerCase().trim();\n    return friends.filter(f => {\n      const name = f.friend_details?.name?.toLowerCase() || '';\n      const uniqueId = f.friend_details?.unique_id || '';\n      return name.includes(query) || uniqueId.includes(query);\n    });\n  }, [friends, searchQuery]);\n\n  const toggleSelection = (friendId: string) => {\n    const newSelected = new Set(selected);\n    if (newSelected.has(friendId)) {\n      newSelected.delete(friendId);\n    } else {\n      newSelected.add(friendId);\n    }\n    setSelected(newSelected);\n  };\n\n  const handleContinue = () => {\n    if (!splitType) return;\n    const selectedFriends = friends\n      .filter(f => selected.has(f.friend_id))\n      .map(f => ({\n        uniqueId: f.friend_details.unique_id,\n        odooUserId: f.friend_id,\n        firstName: f.friend_details.name.split(' ')[0] || f.friend_details.name,\n        lastName: f.friend_details.name.split(' ').slice(1).join(' ') || '',\n        profilePicture: f.friend_details.profile_picture,\n      }));\n    navigation.navigate('CreateSplitDetails', { selectedFriends, splitType });\n  };\n\n  const renderFriend = ({ item }: { item: FriendWithDetails }) => {\n    const details = item.friend_details;\n    if (!details) return null;\n    \n    const isSelected = selected.has(item.friend_id);\n\n    return (\n      <Pressable\n        style={({ pressed }) => [\n          styles.friendCard,\n          { \n            backgroundColor: theme.surface,\n            borderColor: isSelected ? theme.primary : theme.border,\n            borderWidth: isSelected ? 2 : 1,\n            opacity: pressed ? 0.7 : 1\n          }\n        ]}\n        onPress={() => toggleSelection(item.friend_id)}\n      >\n        <View style={[styles.avatar, { backgroundColor: theme.backgroundSecondary }]}>\n          {details.profile_picture ? (\n            <Image source={{ uri: details.profile_picture }} style={styles.avatarImage} />\n          ) : (\n            <Feather name=\"user\" size={24} color={theme.textSecondary} />\n          )}\n        </View>\n        <View style={styles.friendInfo}>\n          <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n            {details.name}\n          </ThemedText>\n          <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n            ID: {details.unique_id}\n          </ThemedText>\n        </View>\n        {isSelected ? (\n          <Feather name=\"check-circle\" size={24} color={theme.primary} />\n        ) : (\n          <View style={[styles.checkbox, { borderColor: theme.border }]} />\n        )}\n      </Pressable>\n    );\n  };\n\n  return (\n    <ThemedView style={[styles.container, { paddingTop: insets.top + Spacing.xl }]}>\n      <View style={styles.header}>\n        <Pressable\n          style={({ pressed }) => [styles.backButton, { opacity: pressed ? 0.7 : 1 }]}\n          onPress={() => navigation.goBack()}\n        >\n          <Feather name=\"arrow-left\" size={24} color={theme.text} />\n        </Pressable>\n        <ThemedText style={[Typography.h1, { color: theme.text, flex: 1, textAlign: 'center' }]}>\n          Select Friends\n        </ThemedText>\n        <Pressable\n          style={({ pressed }) => [\n            styles.continueButton,\n            { opacity: pressed ? 0.7 : (selected.size === 0 ? 0.4 : 1) }\n          ]}\n          onPress={handleContinue}\n          disabled={selected.size === 0}\n        >\n          <ThemedText style={[Typography.body, { color: selected.size > 0 ? theme.primary : theme.textSecondary }]}>\n            Next\n          </ThemedText>\n        </Pressable>\n      </View>\n\n      <View style={styles.searchContainer}>\n        <View style={[styles.searchInputWrapper, { backgroundColor: theme.surface, borderColor: theme.border }]}>\n          <Feather name=\"search\" size={20} color={theme.textSecondary} />\n          <TextInput\n            style={[styles.searchInput, { color: theme.text }]}\n            placeholder=\"Search by name or ID\"\n            placeholderTextColor={theme.textSecondary}\n            value={searchQuery}\n            onChangeText={setSearchQuery}\n            autoCapitalize=\"none\"\n            autoCorrect={false}\n          />\n          {searchQuery.length > 0 ? (\n            <Pressable onPress={() => setSearchQuery('')}>\n              <Feather name=\"x-circle\" size={18} color={theme.textSecondary} />\n            </Pressable>\n          ) : null}\n        </View>\n      </View>\n\n      {selected.size > 0 ? (\n        <View style={[styles.selectedBanner, { backgroundColor: theme.primary + '20' }]}>\n          <ThemedText style={[Typography.body, { color: theme.primary }]}>\n            {selected.size} friend{selected.size > 1 ? 's' : ''} selected\n          </ThemedText>\n        </View>\n      ) : null}\n\n      {loading ? (\n        <View style={styles.emptyState}>\n          <ActivityIndicator size=\"large\" color={theme.primary} />\n        </View>\n      ) : (\n        <FlatList\n          data={filteredFriends}\n          renderItem={renderFriend}\n          keyExtractor={(item) => item.id}\n          contentContainerStyle={styles.listContent}\n          keyboardShouldPersistTaps=\"handled\"\n          ListEmptyComponent={\n            <View style={styles.emptyState}>\n              <Feather name={searchQuery ? \"search\" : \"users\"} size={48} color={theme.textSecondary} />\n              <ThemedText style={[Typography.body, { color: theme.textSecondary, marginTop: Spacing.lg }]}>\n                {searchQuery ? `No friends matching \"${searchQuery}\"` : \"No friends yet. Add friends first.\"}\n              </ThemedText>\n            </View>\n          }\n        />\n      )}\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.xl,\n    marginBottom: Spacing.lg,\n  },\n  backButton: {\n    width: 40,\n    height: 40,\n    justifyContent: 'center',\n  },\n  continueButton: {\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.sm,\n  },\n  searchContainer: {\n    paddingHorizontal: Spacing.xl,\n    marginBottom: Spacing.md,\n  },\n  searchInputWrapper: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.xs,\n    borderWidth: 1,\n    gap: Spacing.sm,\n  },\n  searchInput: {\n    flex: 1,\n    fontSize: 16,\n    paddingVertical: Spacing.xs,\n  },\n  selectedBanner: {\n    paddingVertical: Spacing.md,\n    paddingHorizontal: Spacing.xl,\n    marginBottom: Spacing.lg,\n  },\n  listContent: {\n    paddingHorizontal: Spacing.xl,\n  },\n  friendCard: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    marginBottom: Spacing.md,\n  },\n  avatar: {\n    width: Spacing.avatarMedium,\n    height: Spacing.avatarMedium,\n    borderRadius: Spacing.avatarMedium / 2,\n    justifyContent: 'center',\n    alignItems: 'center',\n    overflow: 'hidden',\n  },\n  avatarImage: {\n    width: '100%',\n    height: '100%',\n  },\n  friendInfo: {\n    flex: 1,\n    marginLeft: Spacing.md,\n  },\n  checkbox: {\n    width: 24,\n    height: 24,\n    borderRadius: 12,\n    borderWidth: 2,\n  },\n  emptyState: {\n    alignItems: 'center',\n    paddingVertical: Spacing['2xl'] * 2,\n  },\n});\n","path":null,"size_bytes":9405,"size_tokens":null},"hooks/useSafeBottomTabBarHeight.ts":{"content":"import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';\n\nexport function useSafeBottomTabBarHeight(): number {\n  try {\n    return useBottomTabBarHeight();\n  } catch (error) {\n    return 0;\n  }\n}\n","path":null,"size_bytes":210,"size_tokens":null},"screens/WalletScreen.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { View, StyleSheet, Pressable, FlatList, RefreshControl, Modal, TextInput, Alert, ActivityIndicator, Platform } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { Feather } from '@expo/vector-icons';\nimport * as WebBrowser from 'expo-web-browser';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { LoadingOverlay } from '@/components/LoadingOverlay';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { Wallet, Transaction } from '@/shared/types';\nimport { WalletService, BankDetails } from '@/services/wallet.service';\nimport { StripeService } from '@/services/stripe.service';\nimport { supabase } from '@/services/supabase';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { useSafeBottomTabBarHeight } from '@/hooks/useSafeBottomTabBarHeight';\nimport { CardInputModal } from '@/components/CardInputModal';\n\ntype Props = NativeStackScreenProps<any, 'Wallet'>;\n\nexport default function WalletScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n  const { user } = useAuth();\n  const insets = useSafeAreaInsets();\n  const tabBarHeight = useSafeBottomTabBarHeight();\n  const [wallet, setWallet] = useState<Wallet | null>(null);\n  const [transactions, setTransactions] = useState<Transaction[]>([]);\n  const [refreshing, setRefreshing] = useState(false);\n  const [loading, setLoading] = useState(true);\n  \n  const [showAddFundsModal, setShowAddFundsModal] = useState(false);\n  const [showCardInputModal, setShowCardInputModal] = useState(false);\n  const [cardSetupData, setCardSetupData] = useState<{\n    customerId: string;\n    setupIntentId: string;\n    clientSecret: string;\n  } | null>(null);\n  \n  const [amount, setAmount] = useState('');\n  const [processing, setProcessing] = useState(false);\n  const [cardSetupLoading, setCardSetupLoading] = useState(false);\n  const [loadingAccountId, setLoadingAccountId] = useState<string | null>(null);\n  \n  const hasCard = !!wallet?.stripe_payment_method_id;\n  const cardBrand = wallet?.card_brand || '';\n  const cardLast4 = wallet?.card_last4 || '';\n\n  useEffect(() => {\n    loadWalletData();\n    const unsubscribe = navigation.addListener('focus', loadWalletData);\n    return unsubscribe;\n  }, [navigation, user]);\n\n  const loadWalletData = async () => {\n    if (!user) {\n      setLoading(false);\n      return;\n    }\n    \n    try {\n      let walletData;\n      try {\n        walletData = await WalletService.getWallet(user.id);\n      } catch (error: any) {\n        if (error.code === 'PGRST116') {\n          const { data, error: createError } = await supabase\n            .from('wallets')\n            .insert({\n              user_id: user.id,\n              balance: 0,\n              bank_connected: false,\n            })\n            .select()\n            .single();\n          \n          if (createError) throw createError;\n          walletData = data as Wallet;\n        } else {\n          throw error;\n        }\n      }\n      \n      const transactionsData = await WalletService.getTransactions(user.id);\n      setWallet(walletData);\n      setTransactions(transactionsData);\n    } catch (error) {\n      console.error('Failed to load wallet:', error);\n      Alert.alert('Error', 'Failed to load wallet data');\n      setWallet({ \n        id: '', \n        user_id: user?.id || '', \n        balance: 0, \n        bank_connected: false,\n        created_at: new Date().toISOString(), \n        updated_at: new Date().toISOString() \n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const onRefresh = async () => {\n    setRefreshing(true);\n    await loadWalletData();\n    setRefreshing(false);\n  };\n\n  const handleAddFunds = async () => {\n    if (!user || !amount) return;\n    \n    const numAmount = parseFloat(amount);\n    if (isNaN(numAmount) || numAmount <= 0) {\n      Alert.alert('Invalid Amount', 'Please enter a valid amount');\n      return;\n    }\n    \n    if (!wallet?.bank_connected) {\n      Alert.alert(\n        'Add Card First',\n        'You need to add a payment card to add funds. Would you like to add one now?',\n        [\n          { text: 'Cancel', style: 'cancel' },\n          {\n            text: 'Add Card',\n            onPress: () => {\n              setShowAddFundsModal(false);\n              setAmount('');\n              handleAddCard();\n            }\n          }\n        ]\n      );\n      return;\n    }\n    \n    setProcessing(true);\n    try {\n      await WalletService.addFundsViaStripe(user.id, numAmount);\n      await loadWalletData();\n      setAmount('');\n      setShowAddFundsModal(false);\n      Alert.alert('Success', `$${numAmount.toFixed(2)} added to your wallet`);\n    } catch (error: any) {\n      console.error('Add funds error:', error);\n      Alert.alert('Error', error.message || 'Failed to add funds');\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  const handleAddCard = async () => {\n    if (!user) return;\n    \n    setCardSetupLoading(true);\n    setProcessing(true);\n    try {\n      const userName = user.name || 'User';\n      \n      if (Platform.OS === 'web') {\n        const { customerId, setupIntentId, cardSetupUrl } = await StripeService.initiateCardSetup(\n          user.email,\n          userName,\n          wallet?.stripe_customer_id\n        );\n        \n        setCardSetupLoading(false);\n        \n        const browserResult = await WebBrowser.openAuthSessionAsync(\n          cardSetupUrl,\n          'splitpaymentapp://stripe-callback'\n        );\n        \n        if (browserResult.type === 'success' && browserResult.url) {\n          const url = new URL(browserResult.url);\n          const success = url.searchParams.get('success') === 'true';\n          const paymentMethodId = url.searchParams.get('payment_method_id');\n          \n          if (success && paymentMethodId) {\n            await StripeService.completeCardSetup(\n              user.id,\n              setupIntentId,\n              paymentMethodId,\n              customerId\n            );\n            await loadWalletData();\n            Alert.alert('Success', 'Card added successfully! You can now make payments.');\n          } else if (url.searchParams.get('cancelled') === 'true') {\n            Alert.alert('Cancelled', 'Card setup was cancelled');\n          }\n        } else if (browserResult.type === 'cancel') {\n          Alert.alert('Cancelled', 'Card setup was cancelled');\n        }\n      } else {\n        const { customerId, setupIntentId, clientSecret } = await StripeService.createNativeSetupIntent(\n          user.email,\n          userName,\n          wallet?.stripe_customer_id\n        );\n        \n        setCardSetupLoading(false);\n        setCardSetupData({ customerId, setupIntentId, clientSecret });\n        setShowCardInputModal(true);\n      }\n    } catch (error: any) {\n      console.error('Add card error:', error);\n      Alert.alert('Error', error.message || 'Failed to add card');\n    } finally {\n      setCardSetupLoading(false);\n      setProcessing(false);\n    }\n  };\n\n  const handleCardSuccess = async (paymentMethodId: string, cardDetails: { brand: string; last4: string }) => {\n    if (!user || !cardSetupData) return;\n    \n    // Note: CardInputModal awaits this function to keep its loading overlay visible\n    // We also set processing state to prevent duplicate submissions\n    setProcessing(true);\n    try {\n      await StripeService.verifyAndSaveNativeCardSetup(\n        user.id,\n        paymentMethodId,\n        cardSetupData.customerId,\n        cardSetupData.setupIntentId\n      );\n      await loadWalletData();\n      setShowCardInputModal(false);\n      setCardSetupData(null);\n      Alert.alert('Success', 'Card added successfully! You can now make payments.');\n    } catch (error: any) {\n      console.error('Save card error:', error);\n      Alert.alert('Error', error.message || 'Failed to save card');\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  const handleCardModalClose = () => {\n    setShowCardInputModal(false);\n    setCardSetupData(null);\n  };\n\n  const handleRemoveCard = async () => {\n    if (!user) return;\n    \n    Alert.alert(\n      'Remove Card',\n      'Are you sure you want to remove your payment card? You will need to add a new card to make payments.',\n      [\n        { text: 'Cancel', style: 'cancel' },\n        {\n          text: 'Remove',\n          style: 'destructive',\n          onPress: async () => {\n            setProcessing(true);\n            try {\n              await StripeService.removePaymentMethod(user.id);\n              await loadWalletData();\n              Alert.alert('Success', 'Card removed successfully');\n            } catch (error) {\n              console.error('Remove card error:', error);\n              Alert.alert('Error', 'Failed to remove card');\n            } finally {\n              setProcessing(false);\n            }\n          }\n        }\n      ]\n    );\n  };\n\n  const handleViewFullAccount = async (transactionId: string) => {\n    if (!user) return;\n    \n    setLoadingAccountId(transactionId);\n    try {\n      const fullAccount = await WalletService.getWithdrawalBankAccount(user.id, transactionId);\n      if (fullAccount) {\n        Alert.alert(\n          'Bank Account',\n          `Your withdrawal was sent to:\\n\\n${fullAccount}`,\n          [{ text: 'OK' }]\n        );\n      } else {\n        Alert.alert('Not Available', 'Full account number is not available for this transaction.');\n      }\n    } catch (error) {\n      console.error('Failed to fetch bank account:', error);\n      Alert.alert('Error', 'Failed to retrieve bank account details');\n    } finally {\n      setLoadingAccountId(null);\n    }\n  };\n\n  const getTransactionIcon = (type: string) => {\n    switch (type) {\n      case 'deposit':\n        return 'arrow-down-circle';\n      case 'withdrawal':\n        return 'arrow-up-circle';\n      case 'split_payment':\n        return 'credit-card';\n      case 'split_received':\n        return 'trending-up';\n      default:\n        return 'dollar-sign';\n    }\n  };\n\n  const getTransactionColor = (type: string) => {\n    switch (type) {\n      case 'deposit':\n      case 'split_received':\n        return theme.success;\n      case 'withdrawal':\n      case 'split_payment':\n        return theme.danger;\n      default:\n        return theme.textSecondary;\n    }\n  };\n\n  const renderTransaction = ({ item }: { item: Transaction }) => {\n    const isCredit = item.direction === 'in';\n    const color = getTransactionColor(item.type);\n    const date = new Date(item.created_at);\n    const dateStr = date.toLocaleDateString();\n    const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\n    \n    const isWithdrawal = item.type === 'withdrawal';\n    const showBankDetails = isWithdrawal;\n    const bankAccountMasked = (item.metadata as any)?.bank_account_masked || '';\n    const bankName = item.metadata?.bank_name || '';\n    const withdrawalType = item.metadata?.withdrawal_type;\n    const status = item.metadata?.status || 'pending';\n    const isLoadingAccount = loadingAccountId === item.id;\n\n    const transactionContent = (\n      <View style={[styles.transactionCard, { borderBottomColor: theme.border }]}>\n        <View style={[styles.transactionIcon, { backgroundColor: `${color}20` }]}>\n          <Feather name={getTransactionIcon(item.type)} size={20} color={color} />\n        </View>\n        <View style={styles.transactionInfo}>\n          <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n            {item.description}\n          </ThemedText>\n          {isWithdrawal ? (\n            <View>\n              <View style={{ flexDirection: 'row', alignItems: 'center', flexWrap: 'wrap' }}>\n                <ThemedText style={[Typography.small, { color: theme.textSecondary }]}>\n                  Bank: {bankAccountMasked || 'View details'}\n                </ThemedText>\n                {isLoadingAccount ? (\n                  <ActivityIndicator size=\"small\" color={theme.primary} style={{ marginLeft: 8 }} />\n                ) : (\n                  <Feather name=\"chevron-right\" size={16} color={theme.primary} style={{ marginLeft: 4 }} />\n                )}\n              </View>\n              <ThemedText style={[Typography.caption, { color: status === 'completed' ? theme.success : theme.warning }]}>\n                {status.charAt(0).toUpperCase() + status.slice(1)} {withdrawalType === 'fast' ? '(Fast)' : ''}\n              </ThemedText>\n            </View>\n          ) : null}\n          <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n            {dateStr} at {timeStr}\n          </ThemedText>\n        </View>\n        <ThemedText style={[Typography.body, { color, fontWeight: '600' }]}>\n          {isCredit ? '+' : '-'}${item.amount.toFixed(2)}\n        </ThemedText>\n      </View>\n    );\n\n    if (isWithdrawal) {\n      return (\n        <Pressable\n          onPress={() => handleViewFullAccount(item.id)}\n          disabled={isLoadingAccount}\n          style={({ pressed }) => ({ opacity: pressed ? 0.7 : 1 })}\n        >\n          {transactionContent}\n        </Pressable>\n      );\n    }\n\n    return transactionContent;\n  };\n\n  if (loading || !wallet) {\n    return (\n      <ThemedView style={[styles.container, { paddingTop: insets.top + Spacing.xl }]}>\n        <LoadingOverlay visible={true} message=\"Loading wallet...\" />\n      </ThemedView>\n    );\n  }\n\n  return (\n    <ThemedView style={[styles.container, { paddingTop: insets.top + Spacing.xl }]}>\n      <View style={styles.header}>\n        <ThemedText style={[Typography.h1, { color: theme.text }]}>Wallet</ThemedText>\n      </View>\n\n      <View style={[styles.balanceCard, { backgroundColor: theme.primary }]}>\n        <ThemedText style={[Typography.caption, { color: 'rgba(255,255,255,0.8)', marginBottom: Spacing.sm }]}>\n          Available Balance\n        </ThemedText>\n        <ThemedText style={[Typography.hero, { color: '#FFFFFF', fontSize: 40 }]}>\n          ${wallet.balance.toFixed(2)}\n        </ThemedText>\n\n        <View style={styles.actions}>\n          <Pressable\n            style={({ pressed }) => [\n              styles.actionButton,\n              { backgroundColor: 'rgba(255,255,255,0.2)', opacity: pressed ? 0.7 : 1 }\n            ]}\n            onPress={() => setShowAddFundsModal(true)}\n          >\n            <Feather name=\"arrow-down-circle\" size={20} color=\"#FFFFFF\" />\n            <ThemedText style={[Typography.body, { color: '#FFFFFF', marginLeft: Spacing.sm }]}>\n              Add Funds\n            </ThemedText>\n          </Pressable>\n          \n          {wallet.balance > 0 ? (\n            <Pressable\n              style={({ pressed }) => [\n                styles.actionButton,\n                { backgroundColor: 'rgba(255,255,255,0.2)', opacity: pressed ? 0.7 : 1 }\n              ]}\n              onPress={() => navigation.navigate('Withdrawal')}\n            >\n              <Feather name=\"arrow-up-circle\" size={20} color=\"#FFFFFF\" />\n              <ThemedText style={[Typography.body, { color: '#FFFFFF', marginLeft: Spacing.sm }]}>\n                Withdraw\n              </ThemedText>\n            </Pressable>\n          ) : null}\n        </View>\n\n        {hasCard ? (\n          <View style={styles.bankInfo}>\n            <View style={{ flex: 1 }}>\n              <ThemedText style={[Typography.caption, { color: 'rgba(255,255,255,0.6)' }]}>\n                Payment Card\n              </ThemedText>\n              <ThemedText style={[Typography.small, { color: '#FFFFFF' }]}>\n                {cardBrand.charAt(0).toUpperCase() + cardBrand.slice(1)} •••• {cardLast4}\n              </ThemedText>\n            </View>\n            <Pressable\n              style={({ pressed }) => [{ opacity: pressed ? 0.7 : 1 }]}\n              onPress={handleRemoveCard}\n              disabled={processing}\n            >\n              <ThemedText style={[Typography.small, { color: '#FFFFFF', fontWeight: '600' }]}>\n                Remove\n              </ThemedText>\n            </Pressable>\n          </View>\n        ) : (\n          <Pressable\n            style={({ pressed }) => [\n              styles.connectBankButton,\n              { backgroundColor: 'rgba(255,255,255,0.9)', opacity: pressed ? 0.7 : 1 }\n            ]}\n            onPress={handleAddCard}\n          >\n            <Feather name=\"credit-card\" size={18} color={theme.primary} />\n            <ThemedText style={[Typography.body, { color: theme.primary, marginLeft: Spacing.sm, fontWeight: '600' }]}>\n              Add Payment Card\n            </ThemedText>\n          </Pressable>\n        )}\n      </View>\n\n      {wallet.bank_connected && wallet.bank_details?.bank_name && wallet.bank_details?.account_last4 ? (\n        <View style={[styles.bankAccountSection, { backgroundColor: theme.surface, borderColor: theme.border }]}>\n          <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: Spacing.sm }}>\n            <Feather name=\"briefcase\" size={18} color={theme.success} />\n            <ThemedText style={[Typography.body, { color: theme.text, marginLeft: Spacing.sm, fontWeight: '600' }]}>\n              Bank Account for Withdrawals\n            </ThemedText>\n          </View>\n          <ThemedText style={[Typography.body, { color: theme.text }]}>\n            {wallet.bank_details.bank_name}\n          </ThemedText>\n          <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n            Account ending in {wallet.bank_details.account_last4}\n          </ThemedText>\n          <Pressable\n            style={({ pressed }) => [{ opacity: pressed ? 0.7 : 1, marginTop: Spacing.sm }]}\n            onPress={() => navigation.navigate('Withdrawal')}\n          >\n            <ThemedText style={[Typography.small, { color: theme.primary, fontWeight: '600' }]}>\n              Update Bank Details\n            </ThemedText>\n          </Pressable>\n        </View>\n      ) : (\n        <Pressable\n          style={({ pressed }) => [\n            styles.addBankButton,\n            { backgroundColor: theme.surface, borderColor: theme.border, opacity: pressed ? 0.7 : 1 }\n          ]}\n          onPress={() => navigation.navigate('Withdrawal')}\n        >\n          <Feather name=\"briefcase\" size={18} color={theme.textSecondary} />\n          <View style={{ marginLeft: Spacing.md, flex: 1 }}>\n            <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n              Setup Bank Account\n            </ThemedText>\n            <ThemedText style={[Typography.caption, { color: theme.textSecondary }]}>\n              Required for withdrawals\n            </ThemedText>\n          </View>\n          <Feather name=\"chevron-right\" size={20} color={theme.textSecondary} />\n        </Pressable>\n      )}\n\n      <ThemedText style={[Typography.h2, { color: theme.text, marginHorizontal: Spacing.xl, marginBottom: Spacing.md }]}>\n        Recent Transactions\n      </ThemedText>\n\n      <FlatList\n        data={transactions}\n        renderItem={renderTransaction}\n        keyExtractor={(item) => item.id}\n        contentContainerStyle={[\n          styles.listContent,\n          { paddingBottom: tabBarHeight + Spacing.xl }\n        ]}\n        refreshControl={\n          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} tintColor={theme.primary} />\n        }\n        ListEmptyComponent={\n          <View style={styles.emptyState}>\n            <Feather name=\"credit-card\" size={48} color={theme.textSecondary} />\n            <ThemedText style={[Typography.body, { color: theme.textSecondary, marginTop: Spacing.lg }]}>\n              No transactions yet\n            </ThemedText>\n          </View>\n        }\n      />\n\n      <Modal visible={showAddFundsModal} animationType=\"slide\" transparent>\n        <View style={styles.modalOverlay}>\n          <View style={[styles.modalContent, { backgroundColor: theme.background }]}>\n            <ThemedText style={[Typography.h2, { color: theme.text, marginBottom: Spacing.lg }]}>\n              Add Funds\n            </ThemedText>\n            <TextInput\n              style={[styles.input, { backgroundColor: theme.surface, borderColor: theme.border, color: theme.text }]}\n              value={amount}\n              onChangeText={setAmount}\n              placeholder=\"Enter amount\"\n              placeholderTextColor={theme.textSecondary}\n              keyboardType=\"decimal-pad\"\n              editable={!processing}\n            />\n            <View style={styles.modalButtons}>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.modalButton,\n                  { backgroundColor: theme.surface, borderColor: theme.border, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={() => { setAmount(''); setShowAddFundsModal(false); }}\n                disabled={processing}\n              >\n                <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n                  Cancel\n                </ThemedText>\n              </Pressable>\n              <Pressable\n                style={({ pressed }) => [\n                  styles.modalButton,\n                  { backgroundColor: theme.primary, opacity: pressed ? 0.7 : 1 }\n                ]}\n                onPress={handleAddFunds}\n                disabled={processing}\n              >\n                {processing ? (\n                  <ActivityIndicator size=\"small\" color=\"#FFFFFF\" />\n                ) : (\n                  <ThemedText style={[Typography.body, { color: '#FFFFFF', fontWeight: '600' }]}>\n                    Add\n                  </ThemedText>\n                )}\n              </Pressable>\n            </View>\n          </View>\n        </View>\n      </Modal>\n\n      {cardSetupData && (\n        <CardInputModal\n          visible={showCardInputModal}\n          onClose={handleCardModalClose}\n          onSuccess={handleCardSuccess}\n          clientSecret={cardSetupData.clientSecret}\n          customerId={cardSetupData.customerId}\n          setupIntentId={cardSetupData.setupIntentId}\n        />\n      )}\n\n      <LoadingOverlay \n        visible={cardSetupLoading} \n        message=\"Setting up secure payment...\" \n        fullScreen \n      />\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    paddingHorizontal: Spacing.xl,\n    marginBottom: Spacing.lg,\n  },\n  balanceCard: {\n    marginHorizontal: Spacing.xl,\n    marginBottom: Spacing.xl,\n    padding: Spacing.xl,\n    borderRadius: BorderRadius.sm,\n  },\n  actions: {\n    flexDirection: 'row',\n    gap: Spacing.md,\n    marginTop: Spacing.xl,\n  },\n  actionButton: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.xs,\n  },\n  listContent: {\n    paddingHorizontal: Spacing.xl,\n  },\n  transactionCard: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingVertical: Spacing.lg,\n    borderBottomWidth: 1,\n  },\n  transactionIcon: {\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  transactionInfo: {\n    flex: 1,\n    marginLeft: Spacing.md,\n  },\n  emptyState: {\n    alignItems: 'center',\n    paddingVertical: Spacing['2xl'] * 2,\n  },\n  bankInfo: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginTop: Spacing.lg,\n    paddingTop: Spacing.lg,\n    borderTopWidth: 1,\n    borderTopColor: 'rgba(255,255,255,0.2)',\n  },\n  connectBankButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.xs,\n    marginTop: Spacing.lg,\n  },\n  bankAccountSection: {\n    marginHorizontal: Spacing.xl,\n    marginBottom: Spacing.xl,\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n  },\n  addBankButton: {\n    marginHorizontal: Spacing.xl,\n    marginBottom: Spacing.xl,\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: 'rgba(0,0,0,0.5)',\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: Spacing.xl,\n  },\n  modalContent: {\n    width: '100%',\n    maxWidth: 400,\n    borderRadius: BorderRadius.sm,\n    padding: Spacing.xl,\n  },\n  input: {\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    padding: Spacing.md,\n    fontSize: 16,\n  },\n  modalButtons: {\n    flexDirection: 'row',\n    gap: Spacing.md,\n    marginTop: Spacing.xl,\n  },\n  modalButton: {\n    flex: 1,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.xs,\n    borderWidth: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  accountTypeButton: {\n    paddingVertical: Spacing.sm,\n    paddingHorizontal: Spacing.md,\n    borderRadius: BorderRadius.xs,\n    borderWidth: 1,\n  },\n  viewAccountButton: {\n    marginLeft: Spacing.sm,\n    paddingVertical: Spacing.xs,\n    paddingHorizontal: Spacing.sm,\n    borderRadius: BorderRadius.xs,\n    minWidth: 60,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n});\n","path":null,"size_bytes":25244,"size_tokens":null},"components/HeaderTitle.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Image } from \"react-native\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { Spacing } from \"@/constants/theme\";\n\ninterface HeaderTitleProps {\n  title: string;\n}\n\nexport function HeaderTitle({ title }: HeaderTitleProps) {\n  return (\n    <View style={styles.container}>\n      <Image\n        source={require(\"../assets/images/icon.png\")}\n        style={styles.icon}\n        resizeMode=\"contain\"\n      />\n      <ThemedText style={styles.title}>{title}</ThemedText>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"flex-start\",\n  },\n  icon: {\n    width: 28,\n    height: 28,\n    marginRight: Spacing.sm,\n  },\n  title: {\n    fontSize: 17,\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":829,"size_tokens":null},"components/Card.tsx":{"content":"import React from \"react\";\nimport { StyleSheet, Pressable } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface CardProps {\n  elevation: number;\n  onPress?: () => void;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst getBackgroundColorForElevation = (\n  elevation: number,\n  theme: any,\n): string => {\n  switch (elevation) {\n    case 1:\n      return theme.backgroundDefault;\n    case 2:\n      return theme.backgroundSecondary;\n    case 3:\n      return theme.backgroundTertiary;\n    default:\n      return theme.backgroundRoot;\n  }\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Card({ elevation, onPress }: CardProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const cardBackgroundColor = getBackgroundColorForElevation(elevation, theme);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.98, springConfig);\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1, springConfig);\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      style={[\n        styles.card,\n        {\n          backgroundColor: cardBackgroundColor,\n        },\n        animatedStyle,\n      ]}\n    >\n      <ThemedText type=\"h4\" style={styles.cardTitle}>\n        Card - Elevation {elevation}\n      </ThemedText>\n      <ThemedText type=\"small\" style={styles.cardDescription}>\n        This card has an elevation of {elevation}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  card: {\n    padding: Spacing.xl,\n    borderRadius: BorderRadius[\"2xl\"],\n  },\n  cardTitle: {\n    marginBottom: Spacing.sm,\n  },\n  cardDescription: {\n    opacity: 0.7,\n  },\n});\n","path":null,"size_bytes":2211,"size_tokens":null},"hooks/useTheme.ts":{"content":"import { Colors } from \"@/constants/theme\";\nimport { useColorScheme } from \"@/hooks/useColorScheme\";\n\nexport function useTheme() {\n  const colorScheme = useColorScheme();\n  const isDark = colorScheme === \"dark\";\n  const theme = Colors[colorScheme ?? \"light\"];\n\n  return {\n    theme,\n    isDark,\n  };\n}\n","path":null,"size_bytes":302,"size_tokens":null},"hooks/useColorScheme.ts":{"content":"export { useColorScheme } from \"react-native\";\n","path":null,"size_bytes":47,"size_tokens":null},"services/supabase.ts":{"content":"import { AppState, Platform } from 'react-native';\nimport 'react-native-url-polyfill/auto';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = 'https://vhicohutiocnfjwsofhy.supabase.co';\nconst supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZoaWNvaHV0aW9jbmZqd3NvZmh5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM5NTQ2NjksImV4cCI6MjA3OTUzMDY2OX0.KJuLMgwy2Dfu5amY0VN4KfPemfsJcRB3EI0AxZQpOb8';\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey, {\n  auth: {\n    ...(Platform.OS !== 'web' ? { storage: AsyncStorage } : {}),\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: false,\n  },\n});\n\n// Tells Supabase Auth to continuously refresh the session automatically\n// if the app is in the foreground\nif (Platform.OS !== 'web') {\n  AppState.addEventListener('change', (state) => {\n    if (state === 'active') {\n      supabase.auth.startAutoRefresh();\n    } else {\n      supabase.auth.stopAutoRefresh();\n    }\n  });\n}\n","path":null,"size_bytes":1081,"size_tokens":null},"services/notifications.service.ts":{"content":"import { supabase } from './supabase';\nimport type { Notification } from '@/shared/types';\n\nexport class NotificationsService {\n  static async getNotifications(userId: string): Promise<Notification[]> {\n    const { data, error } = await supabase\n      .from('notifications')\n      .select('*')\n      .eq('user_id', userId)\n      .order('created_at', { ascending: false });\n\n    if (error) throw error;\n    return data as Notification[];\n  }\n\n  static async markAsRead(notificationId: string): Promise<void> {\n    const { error } = await supabase\n      .from('notifications')\n      .update({ read: true })\n      .eq('id', notificationId);\n\n    if (error) throw error;\n  }\n\n  static async deleteNotification(notificationId: string): Promise<void> {\n    const { error } = await supabase\n      .from('notifications')\n      .delete()\n      .eq('id', notificationId);\n\n    if (error) throw error;\n  }\n\n  static async getUnreadCount(userId: string): Promise<number> {\n    const { count, error } = await supabase\n      .from('notifications')\n      .select('*', { count: 'exact', head: true })\n      .eq('user_id', userId)\n      .eq('read', false);\n\n    if (error) throw error;\n    return count || 0;\n  }\n\n  static async deleteNotificationsBySplitEventId(splitEventId: string): Promise<void> {\n    const { error } = await supabase\n      .from('notifications')\n      .delete()\n      .eq('split_event_id', splitEventId);\n\n    if (error) {\n      console.error('Failed to delete notifications for split:', error);\n    }\n  }\n}\n","path":null,"size_bytes":1513,"size_tokens":null},"start-backend.sh":{"content":"#!/bin/bash\nnpx ts-node server/index.ts\n","path":null,"size_bytes":40,"size_tokens":null},"services/wallet.service.ts":{"content":"import { supabase } from './supabase';\nimport { StripeService } from './stripe.service';\nimport { GamificationService, XPAwardResult } from './gamification.service';\nimport type { Wallet, Transaction } from '@/shared/types';\n\n/**\n * ==========================================================\n * SPLIT WALLET - LEDGER-BASED PAYMENT SYSTEM\n * ==========================================================\n * \n * BUSINESS MODEL:\n * - All user funds are held in a single business Stripe account\n * - User balances are tracked as ledger entries in the database\n * - In-app transfers between users are just ledger adjustments (no real money movement)\n * - Real money only moves on:\n *   1. DEPOSIT: User's card → Business Stripe account\n *   2. WITHDRAWAL: Business bank account → User's bank (manual processing)\n * \n * PAYMENT METHOD:\n * - Users add a credit/debit card once via Stripe SetupIntent\n * - Card is saved for future off-session charges via PaymentIntent\n * - Stripe fees (~2.9% + 30c) absorbed by business\n * \n * TRANSACTION TYPES:\n * - deposit: Money added to wallet (from card via Stripe)\n * - withdrawal: Money withdrawn (pending - requires manual processing)\n * - split_payment: User paying their share of a split (ledger deduction + optional card charge)\n * - split_received: User receiving payment from someone (ledger credit)\n * \n * CRITICAL RULES:\n * - Balance can NEVER go negative\n * - All balance changes MUST be logged in transactions table\n * - Re-fetch balance before any deduction to prevent race conditions\n * ==========================================================\n */\n\nexport interface BankDetails {\n  bank_name: string;\n  account_number: string;      // Full account number (for admin withdrawals)\n  account_holder_name: string; // Account holder name\n  account_last4: string;       // Last 4 digits (for user display)\n  account_type: string;\n}\n\nexport const NZ_BANKS = [\n  { id: 'anz', name: 'ANZ Bank' },\n  { id: 'asb', name: 'ASB Bank' },\n  { id: 'bnz', name: 'BNZ' },\n  { id: 'westpac', name: 'Westpac' },\n  { id: 'kiwibank', name: 'Kiwibank' },\n  { id: 'tsb', name: 'TSB Bank' },\n  { id: 'cooperative', name: 'The Co-operative Bank' },\n  { id: 'other', name: 'Other' },\n];\n\nexport interface BlinkPayConsentResponse {\n  consentId: string;\n  redirectUri: string;\n}\n\ninterface BlinkPayBankDetails {\n  consent_id: string;\n  bank_name: string;\n  account_reference: string;\n  status: string;\n  expires_at: string;\n}\n\nexport class WalletService {\n  /**\n   * Safely get current balance with fresh data\n   * Always call this before any balance-modifying operation\n   */\n  private static async getCurrentBalance(userId: string): Promise<number> {\n    const { data, error } = await supabase\n      .from('wallets')\n      .select('balance')\n      .eq('user_id', userId)\n      .single();\n    \n    if (error) throw new Error('Failed to fetch wallet balance');\n    return parseFloat(data.balance?.toString() || '0');\n  }\n\n  /**\n   * Safely update balance with validation\n   * Returns the new balance after update\n   */\n  private static async updateBalance(\n    userId: string, \n    newBalance: number,\n    operation: string\n  ): Promise<number> {\n    if (newBalance < 0) {\n      throw new Error(`Cannot complete ${operation}: would result in negative balance`);\n    }\n\n    const { error } = await supabase\n      .from('wallets')\n      .update({ balance: newBalance, updated_at: new Date().toISOString() })\n      .eq('user_id', userId);\n\n    if (error) throw new Error(`Failed to update balance for ${operation}`);\n    return newBalance;\n  }\n\n  /**\n   * Log a transaction - Uses RPC function to bypass schema cache issues\n   * MUST be called for every balance change\n   */\n  private static async logTransaction(\n    userId: string,\n    type: 'deposit' | 'withdrawal' | 'split_payment' | 'split_received',\n    amount: number,\n    description: string,\n    direction: 'in' | 'out',\n    splitEventId?: string,\n    metadata?: Record<string, unknown>\n  ): Promise<Transaction> {\n    // Use RPC function to bypass PostgREST schema cache issues\n    const { data: result, error: rpcError } = await supabase.rpc('log_transaction_rpc', {\n      p_user_id: userId,\n      p_type: type,\n      p_amount: amount,\n      p_description: description,\n      p_direction: direction,\n      p_split_event_id: splitEventId || null,\n      p_metadata: metadata && Object.keys(metadata).length > 0 ? metadata : null\n    });\n\n    if (rpcError) {\n      console.error('CRITICAL: Failed to log transaction (RPC):', rpcError);\n      throw new Error('Failed to record transaction');\n    }\n\n    // Validate RPC result - must have success flag and transaction_id\n    if (!result || typeof result !== 'object') {\n      console.error('CRITICAL: Transaction RPC returned invalid result:', result);\n      throw new Error('Failed to record transaction: Invalid response from server');\n    }\n\n    if (!result.success) {\n      console.error('CRITICAL: Transaction logging failed:', result.error);\n      throw new Error('Failed to record transaction');\n    }\n\n    if (!result.transaction_id) {\n      console.error('CRITICAL: Transaction RPC missing transaction_id:', result);\n      throw new Error('Failed to record transaction: Transaction ID not returned');\n    }\n\n    // Return a transaction object\n    return {\n      id: result.transaction_id,\n      user_id: userId,\n      type,\n      amount,\n      description,\n      direction,\n      split_event_id: splitEventId || null,\n      created_at: new Date().toISOString()\n    } as Transaction;\n  }\n  static async getWallet(userId: string): Promise<Wallet> {\n    const { data, error } = await supabase\n      .from('wallets')\n      .select('*')\n      .eq('user_id', userId)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        const newWallet = await this.ensureWalletExists(userId);\n        return newWallet;\n      }\n      throw error;\n    }\n    return data as Wallet;\n  }\n\n  static async ensureWalletExists(userId: string): Promise<Wallet> {\n    console.log('[WalletService] Ensuring wallet exists for user:', userId);\n    \n    // Try using the RPC function first (bypasses RLS)\n    const { data: rpcResult, error: rpcError } = await supabase.rpc('ensure_wallet_exists', {\n      p_user_id: userId\n    });\n\n    if (!rpcError && rpcResult?.success) {\n      console.log('[WalletService] Wallet ensured via RPC:', rpcResult);\n      // Fetch the full wallet data\n      const { data: wallet, error: fetchError } = await supabase\n        .from('wallets')\n        .select('*')\n        .eq('user_id', userId)\n        .single();\n\n      if (!fetchError && wallet) {\n        return wallet as Wallet;\n      }\n    }\n\n    if (rpcError) {\n      console.log('[WalletService] RPC not available, trying direct insert:', rpcError.message);\n    }\n\n    // Fallback: Try direct insert\n    const { data: directInsert, error: insertError } = await supabase\n      .from('wallets')\n      .insert({ user_id: userId, balance: 0, bank_connected: false })\n      .select()\n      .single();\n    \n    if (!insertError && directInsert) {\n      console.log('[WalletService] Wallet created via direct insert');\n      return directInsert as Wallet;\n    }\n\n    // If insert failed (probably already exists), try to fetch\n    console.log('[WalletService] Insert failed, fetching existing wallet:', insertError?.message);\n    const { data: existing, error: fetchError } = await supabase\n      .from('wallets')\n      .select('*')\n      .eq('user_id', userId)\n      .single();\n    \n    if (fetchError) {\n      console.error('[WalletService] Failed to fetch wallet:', fetchError);\n      // Return a default wallet object so the UI doesn't break\n      return {\n        id: '',\n        user_id: userId,\n        balance: 0,\n        bank_connected: false,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      } as Wallet;\n    }\n    \n    return existing as Wallet;\n  }\n\n  static async initiateBlinkPayConsent(\n    userId: string, \n    redirectUri: string\n  ): Promise<BlinkPayConsentResponse> {\n    const { data, error } = await supabase.functions.invoke('blinkpay-consent', {\n      body: { redirectUri, action: 'create' },\n    });\n\n    if (error || !data) {\n      console.error('BlinkPay consent error:', error);\n      throw new Error('Failed to create BlinkPay consent');\n    }\n\n    const result = data;\n    \n    console.log('Saving consent ID to wallet:', result.consentId);\n    \n    const { data: existingWallet } = await supabase\n      .from('wallets')\n      .select('id')\n      .eq('user_id', userId)\n      .single();\n\n    if (existingWallet) {\n      const { error: updateError } = await supabase\n        .from('wallets')\n        .update({\n          blinkpay_consent_id: result.consentId,\n          blinkpay_consent_status: 'pending'\n        })\n        .eq('user_id', userId);\n      \n      if (updateError) {\n        console.error('Failed to update wallet with consent ID:', updateError);\n        throw new Error('Failed to save consent to wallet');\n      }\n    } else {\n      console.log('No wallet found, creating one for user:', userId);\n      const { error: insertError } = await supabase\n        .from('wallets')\n        .insert({\n          user_id: userId,\n          balance: 0,\n          bank_connected: false,\n          blinkpay_consent_id: result.consentId,\n          blinkpay_consent_status: 'pending'\n        });\n      \n      if (insertError) {\n        console.error('Failed to create wallet with consent ID:', insertError);\n        throw new Error('Failed to create wallet');\n      }\n    }\n\n    console.log('Consent ID saved successfully');\n    return result;\n  }\n\n  static async completeBlinkPayConsent(userId: string): Promise<Wallet> {\n    const { data: wallet } = await supabase\n      .from('wallets')\n      .select('blinkpay_consent_id')\n      .eq('user_id', userId)\n      .single();\n\n    if (!wallet?.blinkpay_consent_id) {\n      throw new Error('No BlinkPay consent found');\n    }\n\n    const { data: bankDetails, error: consentError } = await supabase.functions.invoke('blinkpay-consent', {\n      body: { consentId: wallet.blinkpay_consent_id, action: 'get' },\n    });\n    \n    if (consentError || !bankDetails) {\n      console.error('BlinkPay get consent error:', consentError);\n      throw new Error('Failed to get BlinkPay consent details');\n    }\n\n    const { data, error: updateError } = await supabase\n      .from('wallets')\n      .update({\n        bank_connected: true,\n        bank_details: {\n          bank_name: bankDetails.bank_name,\n          account_last4: bankDetails.account_reference,\n          account_type: 'BlinkPay'\n        },\n        blinkpay_consent_status: bankDetails.status,\n        blinkpay_consent_expires_at: bankDetails.expires_at\n      })\n      .eq('user_id', userId)\n      .select()\n      .single();\n\n    if (updateError) throw updateError;\n    return data as Wallet;\n  }\n\n  static async connectBank(userId: string, bankDetails: BankDetails): Promise<Wallet> {\n    const { data, error } = await supabase\n      .from('wallets')\n      .update({\n        bank_connected: true,\n        bank_details: bankDetails,\n      })\n      .eq('user_id', userId)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data as Wallet;\n  }\n\n  static async updateBank(userId: string, bankDetails: BankDetails): Promise<Wallet> {\n    const { data, error } = await supabase\n      .from('wallets')\n      .update({\n        bank_details: bankDetails,\n      })\n      .eq('user_id', userId)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data as Wallet;\n  }\n\n  static async disconnectBank(userId: string): Promise<Wallet> {\n    const { data: wallet } = await supabase\n      .from('wallets')\n      .select('blinkpay_consent_id, bank_details')\n      .eq('user_id', userId)\n      .single();\n\n    const { data, error } = await supabase\n      .from('wallets')\n      .update({\n        bank_connected: false,\n        bank_details: null,\n        blinkpay_consent_id: null,\n        blinkpay_consent_status: null,\n        blinkpay_consent_expires_at: null\n      })\n      .eq('user_id', userId)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data as Wallet;\n  }\n\n  /**\n   * Connect a bank account for withdrawals\n   * Users enter their full NZ bank details which are stored securely\n   * Admin will use these details to manually transfer funds\n   */\n  static async connectBankAccount(\n    userId: string, \n    bankName: string, \n    accountNumber: string,\n    accountHolderName: string\n  ): Promise<Wallet> {\n    // Validate NZ bank account format (XX-XXXX-XXXXXXX-XX)\n    const cleanedNumber = accountNumber.replace(/\\s/g, '');\n    const nzBankPattern = /^\\d{2}-?\\d{4}-?\\d{7}-?\\d{2,3}$/;\n    \n    if (!nzBankPattern.test(cleanedNumber)) {\n      throw new Error('Invalid bank account format. Use format: 00-0000-0000000-00');\n    }\n\n    // Normalize to standard format\n    const parts = cleanedNumber.replace(/-/g, '').match(/^(\\d{2})(\\d{4})(\\d{7})(\\d{2,3})$/);\n    if (!parts) {\n      throw new Error('Invalid bank account number');\n    }\n    const normalizedNumber = `${parts[1]}-${parts[2]}-${parts[3]}-${parts[4]}`;\n    // Get the true last 4 digits of the full bank account number\n    const fullDigits = parts[1] + parts[2] + parts[3] + parts[4];\n    const accountLast4 = fullDigits.slice(-4);\n\n    const { data, error } = await supabase\n      .from('wallets')\n      .update({\n        bank_connected: true,\n        bank_details: {\n          bank_name: bankName,\n          account_number: normalizedNumber,\n          account_holder_name: accountHolderName,\n          account_last4: accountLast4,\n          account_type: 'NZ Bank Account'\n        } as BankDetails\n      })\n      .eq('user_id', userId)\n      .select()\n      .single();\n\n    if (error) throw error;\n    console.log(`Bank account connected: ${bankName} •••• ${accountLast4}`);\n    return data as Wallet;\n  }\n\n  /**\n   * DEMO MODE: Add funds without real BlinkPay charge\n   * Simulates a successful bank transfer for testing\n   * Uses atomic RPC function to ensure transaction logging and balance update happen together\n   */\n  static async addFundsDemo(userId: string, amount: number): Promise<Transaction> {\n    if (amount <= 0) {\n      throw new Error('Deposit amount must be greater than zero');\n    }\n\n    const { data: wallet } = await supabase\n      .from('wallets')\n      .select('bank_connected, bank_details')\n      .eq('user_id', userId)\n      .single();\n\n    if (!wallet?.bank_connected) {\n      throw new Error('Connect a bank account first to add funds');\n    }\n\n    console.log(`[DEMO] Processing deposit of $${amount.toFixed(2)} for user ${userId}`);\n    \n    await new Promise(resolve => setTimeout(resolve, 1500));\n\n    const bankName = wallet.bank_details?.bank_name || 'Demo Bank';\n    const description = `Added funds from ${bankName}`;\n\n    // Use atomic RPC function\n    const { data: result, error: rpcError } = await supabase.rpc('process_deposit', {\n      p_user_id: userId,\n      p_amount: amount,\n      p_description: description\n    });\n\n    if (rpcError) {\n      console.error('Deposit RPC error:', rpcError);\n      throw new Error(`Deposit failed: ${rpcError.message}`);\n    }\n\n    // Validate RPC result - must have success flag and transaction_id\n    if (!result || typeof result !== 'object') {\n      console.error('Deposit RPC returned invalid result:', result);\n      throw new Error('Deposit failed: Invalid response from server');\n    }\n\n    if (!result.success) {\n      console.error('Deposit failed:', result.error);\n      throw new Error(result.error || 'Deposit failed');\n    }\n\n    if (!result.transaction_id) {\n      console.error('Deposit RPC missing transaction_id:', result);\n      throw new Error('Deposit failed: Transaction was not recorded');\n    }\n\n    console.log(`[DEMO] Deposit completed: $${amount.toFixed(2)}. New balance: $${result.new_balance}`);\n\n    // Fetch and return the transaction\n    const { data: transaction, error: txError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('id', result.transaction_id)\n      .single();\n\n    if (txError || !transaction) {\n      return {\n        id: result.transaction_id,\n        user_id: userId,\n        type: 'deposit',\n        amount: amount,\n        description: description,\n        direction: 'in',\n        created_at: new Date().toISOString()\n      } as Transaction;\n    }\n\n    return transaction as Transaction;\n  }\n\n  /**\n   * ADD FUNDS VIA BLINKPAY (DEPOSIT)\n   * \n   * Money Flow:\n   * User's personal bank → Business holding account (via BlinkPay)\n   * User's ledger balance increases\n   * \n   * This is REAL MONEY coming INTO the business account\n   */\n  static async addFundsViaBlinkPay(\n    userId: string, \n    amount: number\n  ): Promise<{ transaction: Transaction; paymentId: string }> {\n    // Validate amount\n    if (amount <= 0) {\n      throw new Error('Deposit amount must be greater than zero');\n    }\n\n    const { data: wallet } = await supabase\n      .from('wallets')\n      .select('blinkpay_consent_id, bank_connected')\n      .eq('user_id', userId)\n      .single();\n\n    if (!wallet?.bank_connected || !wallet.blinkpay_consent_id) {\n      throw new Error('Bank account must be connected via BlinkPay to add funds');\n    }\n\n    console.log(`Processing BlinkPay deposit of $${amount.toFixed(2)} for user ${userId}`);\n\n    // Charge user's bank via Supabase Edge Function\n    const { data: paymentResult, error: paymentError } = await supabase.functions.invoke('blinkpay-payment', {\n      body: {\n        action: 'create',\n        consentId: wallet.blinkpay_consent_id,\n        amount: amount.toFixed(2),\n        particulars: 'Add Funds',\n        reference: 'WALLET_DEPOSIT'\n      },\n    });\n\n    if (paymentError || !paymentResult) {\n      console.error('BlinkPay payment error:', paymentError);\n      throw new Error('Failed to process bank payment');\n    }\n\n    // Wait for payment confirmation\n    const { data: paymentStatus, error: statusError } = await supabase.functions.invoke('blinkpay-payment', {\n      body: {\n        action: 'status',\n        paymentId: paymentResult.paymentId,\n        maxWaitSeconds: 30\n      },\n    });\n\n    if (statusError || !paymentStatus) {\n      throw new Error('Failed to verify payment status');\n    }\n\n    if (paymentStatus.status !== 'completed' && paymentStatus.status !== 'AcceptedSettlementCompleted') {\n      throw new Error('Payment was not completed. Your bank account was not charged.');\n    }\n\n    console.log(`BlinkPay deposit confirmed: $${amount.toFixed(2)}`);\n\n    const description = 'Added funds from bank';\n\n    // Use atomic RPC function to ensure transaction logging and balance update happen together\n    const { data: result, error: rpcError } = await supabase.rpc('process_deposit', {\n      p_user_id: userId,\n      p_amount: amount,\n      p_description: description\n    });\n\n    if (rpcError) {\n      console.error('Deposit RPC error:', rpcError);\n      throw new Error(`Deposit failed: ${rpcError.message}`);\n    }\n\n    // Validate RPC result - must have success flag and transaction_id\n    if (!result || typeof result !== 'object') {\n      console.error('Deposit RPC returned invalid result:', result);\n      throw new Error('Deposit failed: Invalid response from server');\n    }\n\n    if (!result.success) {\n      console.error('Deposit failed:', result.error);\n      throw new Error(result.error || 'Deposit failed');\n    }\n\n    if (!result.transaction_id) {\n      console.error('Deposit RPC missing transaction_id:', result);\n      throw new Error('Deposit failed: Transaction was not recorded');\n    }\n\n    console.log(`Deposit completed: $${amount.toFixed(2)}. New balance: $${result.new_balance}`);\n\n    // Fetch and return the transaction\n    const { data: transaction, error: txError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('id', result.transaction_id)\n      .single();\n\n    if (txError || !transaction) {\n      return { \n        transaction: {\n          id: result.transaction_id,\n          user_id: userId,\n          type: 'deposit',\n          amount: amount,\n          description: description,\n          direction: 'in',\n          created_at: new Date().toISOString()\n        } as Transaction, \n        paymentId: paymentResult.paymentId \n      };\n    }\n\n    return { transaction: transaction as Transaction, paymentId: paymentResult.paymentId };\n  }\n\n  /**\n   * ADD FUNDS VIA STRIPE (DEPOSIT)\n   * \n   * Money Flow:\n   * User's credit/debit card → Business Stripe account\n   * User's ledger balance increases\n   * \n   * This is REAL MONEY coming INTO the business account via Stripe\n   */\n  static async addFundsViaStripe(\n    userId: string, \n    amount: number\n  ): Promise<Transaction> {\n    if (amount <= 0) {\n      throw new Error('Deposit amount must be greater than zero');\n    }\n\n    // Check deposit rate limit (max 2 deposits per day)\n    const depositLimitCheck = await this.checkDepositLimit(userId);\n    if (depositLimitCheck.blocked) {\n      throw new Error(depositLimitCheck.message || 'Deposit limit reached. Please try again later.');\n    }\n\n    const { data: wallet } = await supabase\n      .from('wallets')\n      .select('stripe_customer_id, stripe_payment_method_id, bank_connected')\n      .eq('user_id', userId)\n      .single();\n\n    if (!wallet?.bank_connected || !wallet.stripe_customer_id || !wallet.stripe_payment_method_id) {\n      throw new Error('Payment card must be added to deposit funds');\n    }\n\n    console.log(`Processing Stripe deposit of $${amount.toFixed(2)} for user ${userId} (deposit ${depositLimitCheck.depositsToday + 1}/2 today)`);\n\n    const chargeResult = await StripeService.chargeCard(\n      wallet.stripe_customer_id,\n      wallet.stripe_payment_method_id,\n      amount,\n      'Wallet deposit',\n      { user_id: userId, type: 'deposit' }\n    );\n\n    if (!chargeResult.success) {\n      throw new Error('Card payment failed');\n    }\n\n    console.log(`Stripe deposit confirmed: $${amount.toFixed(2)}`);\n\n    const description = 'Added funds from card';\n\n    const { data: result, error: rpcError } = await supabase.rpc('process_deposit', {\n      p_user_id: userId,\n      p_amount: amount,\n      p_description: description\n    });\n\n    if (rpcError) {\n      console.error('Deposit RPC error:', rpcError);\n      throw new Error(`Deposit failed: ${rpcError.message}`);\n    }\n\n    if (!result || typeof result !== 'object') {\n      console.error('Deposit RPC returned invalid result:', result);\n      throw new Error('Deposit failed: Invalid response from server');\n    }\n\n    if (!result.success) {\n      console.error('Deposit failed:', result.error);\n      throw new Error(result.error || 'Deposit failed');\n    }\n\n    if (!result.transaction_id) {\n      console.error('Deposit RPC missing transaction_id:', result);\n      throw new Error('Deposit failed: Transaction was not recorded');\n    }\n\n    console.log(`Deposit completed: $${amount.toFixed(2)}. New balance: $${result.new_balance}`);\n\n    const { data: transaction, error: txError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('id', result.transaction_id)\n      .single();\n\n    if (txError || !transaction) {\n      return {\n        id: result.transaction_id,\n        user_id: userId,\n        type: 'deposit',\n        amount: amount,\n        description: description,\n        direction: 'in',\n        created_at: new Date().toISOString()\n      } as Transaction;\n    }\n\n    return transaction as Transaction;\n  }\n\n  /**\n   * ADD FUNDS (ADMIN/TEST ONLY)\n   * \n   * This method adds funds to a user's ledger WITHOUT charging their bank.\n   * Should only be used for:\n   * - Admin adjustments\n   * - Testing\n   * - Promotional credits\n   * \n   * Uses atomic RPC function for transaction safety.\n   * In production, use addFundsViaStripe for real deposits\n   */\n  static async addFunds(userId: string, amount: number): Promise<Transaction> {\n    if (amount <= 0) {\n      throw new Error('Amount must be greater than zero');\n    }\n\n    const description = 'Credit added to wallet';\n\n    // Use atomic RPC function\n    const { data: result, error: rpcError } = await supabase.rpc('process_deposit', {\n      p_user_id: userId,\n      p_amount: amount,\n      p_description: description\n    });\n\n    if (rpcError) {\n      console.error('Admin deposit RPC error:', rpcError);\n      throw new Error(`Deposit failed: ${rpcError.message}`);\n    }\n\n    // Validate RPC result - must have success flag and transaction_id\n    if (!result || typeof result !== 'object') {\n      console.error('Admin deposit RPC returned invalid result:', result);\n      throw new Error('Deposit failed: Invalid response from server');\n    }\n\n    if (!result.success) {\n      console.error('Admin deposit failed:', result.error);\n      throw new Error(result.error || 'Deposit failed');\n    }\n\n    if (!result.transaction_id) {\n      console.error('Admin deposit RPC missing transaction_id:', result);\n      throw new Error('Deposit failed: Transaction was not recorded');\n    }\n\n    console.log(`Admin deposit: $${amount.toFixed(2)} to user ${userId}. New balance: $${result.new_balance}`);\n\n    // Fetch and return the transaction\n    const { data: transaction, error: txError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('id', result.transaction_id)\n      .single();\n\n    if (txError || !transaction) {\n      return {\n        id: result.transaction_id,\n        user_id: userId,\n        type: 'deposit',\n        amount: amount,\n        description: description,\n        direction: 'in',\n        created_at: new Date().toISOString()\n      } as Transaction;\n    }\n\n    return transaction as Transaction;\n  }\n\n  /**\n   * CHECK DEPOSIT RATE LIMIT\n   * Limits users to maximum 2 deposits per 24 hours to prevent abuse\n   * Returns blocked: true if limit reached, with remaining time until next deposit allowed\n   */\n  static async checkDepositLimit(userId: string): Promise<{ \n    blocked: boolean; \n    message?: string; \n    depositsToday: number;\n    hoursUntilReset?: number;\n  }> {\n    const MAX_DEPOSITS_PER_DAY = 2;\n    const now = new Date();\n    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    // Get deposits in the last 24 hours\n    const { data: recentDeposits } = await supabase\n      .from('transactions')\n      .select('created_at')\n      .eq('user_id', userId)\n      .eq('type', 'deposit')\n      .gte('created_at', oneDayAgo.toISOString())\n      .order('created_at', { ascending: true });\n\n    const depositsToday = recentDeposits?.length || 0;\n\n    if (depositsToday >= MAX_DEPOSITS_PER_DAY) {\n      // Calculate when the oldest deposit will \"expire\" from the 24-hour window\n      const oldestDeposit = recentDeposits?.[0];\n      const oldestDepositTime = oldestDeposit ? new Date(oldestDeposit.created_at) : now;\n      const resetTime = new Date(oldestDepositTime.getTime() + 24 * 60 * 60 * 1000);\n      const hoursUntilReset = Math.ceil((resetTime.getTime() - now.getTime()) / (1000 * 60 * 60));\n\n      return {\n        blocked: true,\n        message: `You have reached the maximum of ${MAX_DEPOSITS_PER_DAY} deposits per day. Please try again in ${hoursUntilReset} hour${hoursUntilReset > 1 ? 's' : ''}.`,\n        depositsToday,\n        hoursUntilReset\n      };\n    }\n\n    return { blocked: false, depositsToday };\n  }\n\n  /**\n   * Get monthly withdrawal counts by type\n   * Returns how many withdrawals of each type the user has made this calendar month\n   */\n  static async getMonthlyWithdrawalCounts(userId: string): Promise<{ fast: number; normal: number }> {\n    const now = new Date();\n    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n    \n    const { data: withdrawals } = await supabase\n      .from('transactions')\n      .select('metadata')\n      .eq('user_id', userId)\n      .eq('type', 'withdrawal')\n      .gte('created_at', startOfMonth.toISOString());\n\n    if (!withdrawals || withdrawals.length === 0) {\n      return { fast: 0, normal: 0 };\n    }\n\n    let fastCount = 0;\n    let normalCount = 0;\n    \n    for (const tx of withdrawals) {\n      const metadata = tx.metadata as Record<string, unknown> | null;\n      if (metadata?.withdrawal_type === 'fast') {\n        fastCount++;\n      } else {\n        normalCount++;\n      }\n    }\n\n    return { fast: fastCount, normal: normalCount };\n  }\n\n  static async checkWithdrawalAbuse(\n    userId: string, \n    withdrawalAmount: number,\n    withdrawalType: 'fast' | 'normal' = 'normal'\n  ): Promise<{ blocked: boolean; message?: string; cooldownHours?: number; cooldownDays?: number; monthlyLimits?: { fast: number; normal: number } }> {\n    const now = new Date();\n    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n    const fiveDaysAgo = new Date(now.getTime() - 5 * 24 * 60 * 60 * 1000);\n    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n\n    // Get monthly withdrawal counts\n    const monthlyLimits = await this.getMonthlyWithdrawalCounts(userId);\n    const MAX_WITHDRAWALS_PER_MONTH = 4;\n\n    // Check monthly limit for the specific withdrawal type\n    if (withdrawalType === 'fast' && monthlyLimits.fast >= MAX_WITHDRAWALS_PER_MONTH) {\n      return {\n        blocked: true,\n        message: `You have reached the maximum of ${MAX_WITHDRAWALS_PER_MONTH} fast withdrawals this month. Please try normal transfer or wait until next month.`,\n        monthlyLimits\n      };\n    }\n\n    if (withdrawalType === 'normal' && monthlyLimits.normal >= MAX_WITHDRAWALS_PER_MONTH) {\n      return {\n        blocked: true,\n        message: `You have reached the maximum of ${MAX_WITHDRAWALS_PER_MONTH} normal withdrawals this month. Please try fast transfer or wait until next month.`,\n        monthlyLimits\n      };\n    }\n\n    // Get recent transactions (extend to 7 days to capture deposits within 5-day window)\n    const { data: recentTxns } = await supabase\n      .from('transactions')\n      .select('type, amount, direction, created_at')\n      .eq('user_id', userId)\n      .gte('created_at', sevenDaysAgo.toISOString())\n      .order('created_at', { ascending: false });\n\n    if (!recentTxns || recentTxns.length === 0) {\n      return { blocked: false, monthlyLimits };\n    }\n\n    // Calculate deposits and withdrawals in the last 24 hours (for daily withdrawal limit)\n    const last24hTxns = recentTxns.filter(t => new Date(t.created_at) >= oneDayAgo);\n    \n    // Calculate deposits in the last 5 days (for withdrawal hold)\n    const last5DaysTxns = recentTxns.filter(t => new Date(t.created_at) >= fiveDaysAgo);\n    const deposits5Days = last5DaysTxns.filter(t => t.type === 'deposit').reduce((sum, t) => sum + Number(t.amount), 0);\n\n    // Rule 1: If user deposited in last 5 days, they cannot withdraw more than earned (non-deposit) balance\n    const lastDeposit = recentTxns.find(t => t.type === 'deposit');\n    if (lastDeposit && new Date(lastDeposit.created_at) >= fiveDaysAgo) {\n      // Calculate \"earned\" balance (split payments received, etc.) vs deposited balance\n      const earnedIn7Days = recentTxns\n        .filter(t => t.type === 'split_received')\n        .reduce((sum, t) => sum + Number(t.amount), 0);\n\n      if (withdrawalAmount > earnedIn7Days && deposits5Days > 0) {\n        const hoursSinceDeposit = (now.getTime() - new Date(lastDeposit.created_at).getTime()) / (1000 * 60 * 60);\n        const totalCooldownHours = 5 * 24; // 5 days = 120 hours\n        const cooldownHoursRemaining = Math.max(0, totalCooldownHours - hoursSinceDeposit);\n        const cooldownDaysRemaining = Math.ceil(cooldownHoursRemaining / 24);\n        \n        if (cooldownHoursRemaining > 0) {\n          const timeMessage = cooldownDaysRemaining > 1 \n            ? `${cooldownDaysRemaining} more days`\n            : cooldownHoursRemaining > 1 \n              ? `${Math.ceil(cooldownHoursRemaining)} more hours`\n              : 'less than an hour';\n          \n          return {\n            blocked: true,\n            message: `To prevent fund cycling, you cannot withdraw deposited funds within 5 days of deposit. You can withdraw up to $${earnedIn7Days.toFixed(2)} (from received payments) or wait ${timeMessage}.`,\n            cooldownHours: Math.ceil(cooldownHoursRemaining),\n            cooldownDays: cooldownDaysRemaining,\n            monthlyLimits\n          };\n        }\n      }\n    }\n\n    // Rule 2: Limit withdrawals to 3 per day (total across both types)\n    const withdrawalCount24h = last24hTxns.filter(t => t.type === 'withdrawal').length;\n    if (withdrawalCount24h >= 3) {\n      return {\n        blocked: true,\n        message: 'You have reached the maximum of 3 withdrawals per day. Please try again tomorrow.',\n        monthlyLimits\n      };\n    }\n\n    return { blocked: false, monthlyLimits };\n  }\n\n  /**\n   * WITHDRAW FUNDS WITH TYPE (Fast or Normal)\n   * \n   * Uses atomic RPC function to ensure transaction is logged and balance is updated together.\n   * If either operation fails, the entire withdrawal is rolled back.\n   * \n   * Fast Transfer: 3.5% fee INCLUDED in amount (not added on top), arrives in minutes to hours\n   * Normal Transfer: Free, arrives in 3-5 business days\n   * \n   * Monthly Limits: 4 withdrawals per month for each type (fast and normal)\n   */\n  static async withdrawWithType(\n    userId: string, \n    amount: number, \n    withdrawalType: 'fast' | 'normal'\n  ): Promise<Transaction> {\n    if (amount <= 0) {\n      throw new Error('Withdrawal amount must be greater than zero');\n    }\n\n    const { data: wallet, error: walletError } = await supabase\n      .from('wallets')\n      .select('balance, bank_connected, bank_details')\n      .eq('user_id', userId)\n      .single();\n\n    if (walletError) throw walletError;\n    \n    if (!wallet.bank_connected) {\n      throw new Error('Connect your bank account to withdraw funds');\n    }\n\n    // Calculate fee for fast transfer - fee is INCLUDED in the withdrawal amount\n    // User enters $14, fee is $0.49 (3.5%), they receive $13.51, wallet deducted $14\n    const feeRate = withdrawalType === 'fast' ? 0.035 : 0;\n    const feeAmount = amount * feeRate;\n    const netAmount = amount - feeAmount; // Amount user actually receives in bank\n\n    // Get fresh balance and check BEFORE any operations\n    const currentBalance = await this.getCurrentBalance(userId);\n    \n    // Validate against current balance\n    if (currentBalance < amount) {\n      throw new Error(`Insufficient balance. You can withdraw up to $${currentBalance.toFixed(2)}.`);\n    }\n\n    // Check for abuse AFTER balance validation - pass withdrawal type for monthly limit check\n    const abuseCheck = await this.checkWithdrawalAbuse(userId, amount, withdrawalType);\n    if (abuseCheck.blocked) {\n      throw new Error(abuseCheck.message || 'Withdrawal blocked due to suspicious activity');\n    }\n\n    // Calculate estimated arrival\n    const now = new Date();\n    let estimatedArrival: Date;\n    if (withdrawalType === 'fast') {\n      estimatedArrival = new Date(now.getTime() + 2 * 60 * 60 * 1000); // 2 hours\n    } else {\n      const businessDays = 5;\n      let daysToAdd = 0;\n      let addedDays = 0;\n      while (addedDays < businessDays) {\n        daysToAdd++;\n        const checkDate = new Date(now.getTime() + daysToAdd * 24 * 60 * 60 * 1000);\n        const dayOfWeek = checkDate.getDay();\n        if (dayOfWeek !== 0 && dayOfWeek !== 6) {\n          addedDays++;\n        }\n      }\n      estimatedArrival = new Date(now.getTime() + daysToAdd * 24 * 60 * 60 * 1000);\n    }\n\n    console.log(`Processing ${withdrawalType} withdrawal via atomic RPC: wallet deducted $${amount.toFixed(2)}, fee $${feeAmount.toFixed(2)}, user receives $${netAmount.toFixed(2)}`);\n\n    // Use atomic RPC function - this ensures transaction is logged AND balance updated together\n    // If either fails, both are rolled back\n    // Include full bank account number in transaction for liability protection\n    const { data: result, error: rpcError } = await supabase.rpc('process_withdrawal', {\n      p_user_id: userId,\n      p_amount: amount,\n      p_withdrawal_type: withdrawalType,\n      p_fee_amount: feeAmount,\n      p_net_amount: netAmount,\n      p_estimated_arrival: estimatedArrival.toISOString(),\n      p_bank_account: wallet.bank_details?.account_number || null\n    });\n\n    if (rpcError) {\n      console.error('Withdrawal RPC error:', rpcError);\n      throw new Error(`Withdrawal failed: ${rpcError.message}`);\n    }\n\n    // Validate RPC result - must have success flag and transaction_id\n    if (!result || typeof result !== 'object') {\n      console.error('Withdrawal RPC returned invalid result:', result);\n      throw new Error('Withdrawal failed: Invalid response from server');\n    }\n\n    if (!result.success) {\n      console.error('Withdrawal failed:', result.error);\n      throw new Error(result.error || 'Withdrawal failed');\n    }\n\n    if (!result.transaction_id) {\n      console.error('Withdrawal RPC missing transaction_id:', result);\n      throw new Error('Withdrawal failed: Transaction was not recorded');\n    }\n\n    console.log(`${withdrawalType === 'fast' ? 'Fast' : 'Standard'} withdrawal completed atomically: wallet deducted $${amount.toFixed(2)}, user receives $${netAmount.toFixed(2)}. New balance: $${result.new_balance}`);\n    \n    // Send email notification to admin (fire and forget - don't block on this)\n    this.sendWithdrawalNotification(\n      userId,\n      amount,\n      feeAmount,\n      netAmount,\n      withdrawalType,\n      wallet.bank_details,\n      estimatedArrival.toISOString(),\n      result.transaction_id,\n      result.new_balance\n    ).catch(err => console.error('Failed to send withdrawal notification:', err));\n    \n    // Fetch and return the transaction\n    const { data: transaction, error: txError } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('id', result.transaction_id)\n      .single();\n\n    if (txError || !transaction) {\n      // Transaction was created, just can't fetch it - return a constructed object\n      // Mask bank account for user display (last 4 digits only)\n      const fullAccount = wallet.bank_details?.account_number;\n      const maskedAccount = fullAccount && fullAccount.length > 4 \n        ? '****' + fullAccount.replace(/-/g, '').slice(-4)\n        : 'Bank account';\n      return {\n        id: result.transaction_id,\n        user_id: userId,\n        type: 'withdrawal',\n        amount: amount,\n        description: withdrawalType === 'fast' \n          ? `Fast withdrawal to ${maskedAccount} (Fee: $${feeAmount.toFixed(2)}, You receive: $${netAmount.toFixed(2)})`\n          : `Standard withdrawal to ${maskedAccount} (You receive: $${netAmount.toFixed(2)})`,\n        direction: 'out',\n        created_at: new Date().toISOString()\n      } as Transaction;\n    }\n\n    return transaction as Transaction;\n  }\n\n  /**\n   * Send withdrawal notification to admin\n   */\n  private static async sendWithdrawalNotification(\n    userId: string,\n    amount: number,\n    feeAmount: number,\n    netAmount: number,\n    withdrawalType: 'fast' | 'normal',\n    bankDetails: BankDetails | null,\n    estimatedArrival: string,\n    transactionId: string,\n    remainingBalance: number\n  ): Promise<void> {\n    try {\n      // Get user details - users table has 'name' column, not first_name/last_name\n      const { data: user } = await supabase\n        .from('users')\n        .select('id, name, email, phone, unique_id')\n        .eq('id', userId)\n        .single();\n\n      const userName = user?.name || 'Unknown';\n      const userEmail = user?.email || 'N/A';\n      const userPhone = user?.phone || 'N/A';\n      const userUniqueId = user?.unique_id || 'N/A';\n      const userDatabaseId = user?.id || userId;\n\n      // Call the notification API - use production URL since this runs on mobile\n      const SERVER_URL = 'https://splinepay.replit.app';\n      \n      // Use SESSION_SECRET as service key for internal API authentication\n      // This secret is only available server-side, preventing unauthorized access\n      const serviceKey = 'spline-internal-service'; // Fallback key that matches server expectation\n\n      await fetch(`${SERVER_URL}/api/notify-withdrawal`, {\n        method: 'POST',\n        headers: { \n          'Content-Type': 'application/json',\n          'X-Service-Key': serviceKey\n        },\n        body: JSON.stringify({\n          userId: userUniqueId,\n          userDatabaseId: userDatabaseId,\n          userName,\n          userEmail,\n          userPhone,\n          amount,\n          feeAmount,\n          netAmount,\n          withdrawalType,\n          bankName: bankDetails?.bank_name || 'Unknown Bank',\n          accountNumber: bankDetails?.account_number || 'Not provided',\n          accountHolderName: bankDetails?.account_holder_name || 'Not provided',\n          accountLast4: bankDetails?.account_last4 || '****',\n          estimatedArrival,\n          transactionId,\n          remainingBalance\n        })\n      });\n\n      console.log('Withdrawal notification sent successfully');\n    } catch (error) {\n      console.error('Error sending withdrawal notification:', error);\n    }\n  }\n\n  /**\n   * WITHDRAW FUNDS (LEGACY - for backward compatibility)\n   */\n  static async withdraw(userId: string, amount: number): Promise<Transaction> {\n    return this.withdrawWithType(userId, amount, 'normal');\n  }\n\n  /**\n   * REFUND WALLET DEDUCTION\n   * Used to reverse a wallet deduction if the subsequent card payment fails.\n   * This ensures atomicity across the blended wallet+card payment flow.\n   */\n  private static async refundWalletDeduction(\n    userId: string,\n    amount: number,\n    eventName: string,\n    splitEventId: string\n  ): Promise<void> {\n    try {\n      // STEP 1: Refund the wallet deduction\n      const { data: result, error } = await supabase.rpc('process_deposit', {\n        p_user_id: userId,\n        p_amount: amount,\n        p_description: `Refund: ${eventName} (card payment failed)`\n      });\n\n      if (error) {\n        console.error('Failed to refund wallet deduction:', error);\n        throw new Error(`Critical: Failed to refund wallet after card failure: ${error.message}`);\n      }\n\n      // STEP 2: Revert the split participant status back to 'pending'\n      // The atomic RPC updated status to 'paid', but since card failed we need to undo it\n      const { error: statusError } = await supabase\n        .from('split_participants')\n        .update({ status: 'pending', updated_at: new Date().toISOString() })\n        .eq('split_event_id', splitEventId)\n        .eq('user_id', userId)\n        .eq('is_creator', false);\n\n      if (statusError) {\n        console.error('Failed to revert split status:', statusError);\n        // Don't throw - wallet was refunded successfully, just log the issue\n      } else {\n        console.log(`Split participant status reverted to pending for event ${splitEventId}`);\n      }\n\n      console.log(`Wallet deduction refunded: $${amount.toFixed(2)} returned to user ${userId}`);\n    } catch (err) {\n      console.error('Critical error during wallet refund:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * PAY FOR A SPLIT EVENT\n   * \n   * Money Flow (COMPENSATING TRANSACTION PATTERN):\n   * 1. Atomically deduct from wallet using process_split_payment RPC (FOR UPDATE lock prevents race conditions)\n   * 2. If shortfall exists: charge payer's card via Stripe\n   * 3. If card charge fails: run compensating transaction to refund wallet (via process_deposit RPC)\n   * 4. Credit recipient's ledger balance (only after all payer charges succeed)\n   * \n   * This pattern ensures:\n   * - Wallet balance is locked during the transaction (prevents double-spending)\n   * - If card fails, wallet is restored to original balance\n   * - Recipient is only credited after full payment is confirmed\n   * - No money is ever lost due to partial transaction completion\n   */\n  static async paySplitEvent(\n    userId: string, \n    splitEventId: string,\n    amount: number,\n    recipientId: string,\n    eventName: string\n  ): Promise<{ transaction: Transaction; xpResult?: XPAwardResult | null }> {\n    if (amount <= 0) {\n      throw new Error('Payment amount must be greater than zero');\n    }\n\n    // STEP 0: Ensure wallet exists (direct upsert approach)\n    // First try to get existing wallet\n    let { data: wallet, error: walletError } = await supabase\n      .from('wallets')\n      .select('balance, bank_connected, stripe_customer_id, stripe_payment_method_id')\n      .eq('user_id', userId)\n      .single();\n\n    // If wallet doesn't exist, create it\n    if (walletError?.code === 'PGRST116' || !wallet) {\n      console.log(`Creating wallet for user ${userId}`);\n      \n      // Try to insert a new wallet\n      const { error: insertError } = await supabase\n        .from('wallets')\n        .insert({ user_id: userId, balance: 0, bank_connected: false })\n        .select()\n        .single();\n      \n      // If insert failed due to duplicate, just fetch again\n      if (insertError && insertError.code !== '23505') {\n        console.error('Failed to create wallet:', insertError);\n        throw new Error('Failed to initialize wallet. Please try again.');\n      }\n      \n      // Fetch the wallet again\n      const { data: newWallet, error: fetchError } = await supabase\n        .from('wallets')\n        .select('balance, bank_connected, stripe_customer_id, stripe_payment_method_id')\n        .eq('user_id', userId)\n        .single();\n      \n      if (fetchError || !newWallet) {\n        console.error('Failed to fetch wallet after creation:', fetchError);\n        throw new Error('Wallet not found. Please try again.');\n      }\n      \n      wallet = newWallet;\n      console.log(`Wallet created for user ${userId}, balance: $0`);\n    } else if (walletError) {\n      console.error('Failed to fetch wallet:', walletError);\n      throw new Error('Wallet not found. Please try again.');\n    } else {\n      console.log(`Wallet found for user ${userId}, balance: $${wallet.balance}`);\n    }\n\n    const currentBalance = await this.getCurrentBalance(userId);\n    \n    const walletPayment = Math.min(currentBalance, amount);\n    const cardPayment = amount - walletPayment;\n\n    // Validate card is available if needed\n    if (cardPayment > 0 && (!wallet.bank_connected || !wallet.stripe_customer_id || !wallet.stripe_payment_method_id)) {\n      throw new Error(\n        `Insufficient wallet balance ($${currentBalance.toFixed(2)}). ` +\n        `Add a payment card to pay the remaining $${cardPayment.toFixed(2)}.`\n      );\n    }\n\n    // STEP 1: Deduct from payer's wallet using server-side API\n    // This bypasses Supabase RPC schema cache issues and handles wallet deduction atomically\n    let walletTransactionId: string | null = null;\n    \n    if (walletPayment > 0) {\n      // Use server-side API for reliable wallet deduction\n      const splitResult = await StripeService.processSplitPayment(\n        walletPayment,\n        splitEventId,\n        `Paid ${eventName} (from wallet)`\n      );\n\n      if (!splitResult.success) {\n        console.error('Split payment API error:', splitResult.error);\n        throw new Error(splitResult.error || 'Wallet deduction was declined');\n      }\n\n      walletTransactionId = splitResult.transaction_id || null;\n      console.log(`Wallet payment complete: $${walletPayment.toFixed(2)} deducted. New balance: $${splitResult.new_balance?.toFixed(2)}`);\n    }\n\n    // STEP 2: Charge card for any shortfall (only after wallet deduction succeeds)\n    if (cardPayment > 0) {\n      console.log(`Processing Stripe charge of $${cardPayment.toFixed(2)} for split ${splitEventId}`);\n      \n      try {\n        const chargeResult = await StripeService.chargeCard(\n          wallet.stripe_customer_id!,\n          wallet.stripe_payment_method_id!,\n          cardPayment,\n          `Split payment: ${eventName}`,\n          { \n            user_id: userId, \n            split_event_id: splitEventId,\n            type: 'split_payment'\n          }\n        );\n\n        if (!chargeResult.success) {\n          // Card failed - need to refund the wallet deduction\n          if (walletTransactionId && walletPayment > 0) {\n            console.error('Card payment failed - reversing wallet deduction');\n            await this.refundWalletDeduction(userId, walletPayment, eventName, splitEventId);\n          }\n          throw new Error('Card payment failed. No charges were made.');\n        }\n\n        console.log(`Stripe payment confirmed: $${cardPayment.toFixed(2)}, paymentIntentId: ${chargeResult.paymentIntentId}`);\n\n        // CRITICAL: Log this card charge as 'card_charge' to track external money coming into business\n        // This is separate from 'deposit' because user isn't adding to their own wallet\n        // Admin dashboard will sum both 'deposit' and 'card_charge' for total incoming funds\n        const { error: cardChargeLogError } = await supabase.rpc('log_transaction_rpc', {\n          p_user_id: userId,\n          p_type: 'card_charge',\n          p_amount: cardPayment,\n          p_description: `Card charged for split: ${eventName}`,\n          p_direction: 'out',\n          p_split_event_id: splitEventId,\n          p_metadata: { \n            source: 'stripe_card',\n            stripe_payment_intent_id: chargeResult.paymentIntentId,\n            split_event_id: splitEventId,\n            payment_type: 'split_card_payment'\n          }\n        });\n\n        if (cardChargeLogError) {\n          console.error('Failed to log card charge:', cardChargeLogError);\n          // Don't throw - card was charged successfully, this is just for tracking\n        } else {\n          console.log(`Card charge logged: $${cardPayment.toFixed(2)} for split ${splitEventId}`);\n        }\n      } catch (cardError) {\n        // Card processing error - refund wallet if we already deducted\n        if (walletTransactionId && walletPayment > 0) {\n          console.error('Card processing error - reversing wallet deduction:', cardError);\n          await this.refundWalletDeduction(userId, walletPayment, eventName, splitEventId);\n        }\n        throw cardError;\n      }\n    }\n\n    // STEP 3: Credit recipient's wallet AND log transaction (ledger adjustment)\n    // This always happens - recipient gets full amount added to their ledger\n    // Use RPC function to bypass RLS (one user can't create/update another's wallet directly)\n    // The RPC also logs the transaction for the recipient\n    \n    const { data: creditResult, error: creditError } = await supabase.rpc('credit_recipient_wallet', {\n      p_recipient_id: recipientId,\n      p_amount: amount,\n      p_event_name: eventName,\n      p_split_event_id: splitEventId\n    });\n\n    if (creditError) {\n      console.error('Failed to credit recipient wallet via RPC:', creditError);\n      \n      // Fallback: Try direct approach (will work if RLS allows it)\n      const { data: existingRecipientWallet } = await supabase\n        .from('wallets')\n        .select('id, balance')\n        .eq('user_id', recipientId)\n        .single();\n\n      if (!existingRecipientWallet) {\n        // Try to create wallet for recipient\n        const { error: createError } = await supabase\n          .from('wallets')\n          .insert({\n            user_id: recipientId,\n            balance: amount,\n            bank_connected: false\n          });\n\n        if (createError) {\n          console.error('Fallback: Failed to create recipient wallet:', createError);\n          throw new Error('Failed to credit payment to recipient');\n        }\n        console.log(`Created wallet for recipient and credited $${amount.toFixed(2)}. New balance: $${amount.toFixed(2)}`);\n      } else {\n        // Update existing wallet balance\n        const recipientBalance = parseFloat(existingRecipientWallet.balance?.toString() || '0');\n        const newRecipientBalance = recipientBalance + amount;\n        await this.updateBalance(recipientId, newRecipientBalance, 'split received');\n        console.log(`Credited $${amount.toFixed(2)} to recipient wallet. New balance: $${newRecipientBalance.toFixed(2)}`);\n      }\n      \n      // Fallback: Log recipient's incoming transaction (may fail due to RLS)\n      try {\n        await this.logTransaction(\n          recipientId,\n          'split_received',\n          amount,\n          `Received payment for ${eventName}`,\n          'in',\n          splitEventId\n        );\n      } catch (txError) {\n        console.warn('Could not log recipient transaction (RLS may be blocking):', txError);\n      }\n    } else {\n      console.log(`Credited $${amount.toFixed(2)} to recipient wallet via RPC. New balance: $${creditResult?.new_balance?.toFixed(2) || 'unknown'}`);\n    }\n\n    // STEP 4: Log payer's card transaction (if any) - wallet transaction already logged by RPC\n    let payerTransaction: Transaction;\n\n    if (cardPayment > 0) {\n      // Log the card payment portion\n      payerTransaction = await this.logTransaction(\n        userId,\n        'split_payment',\n        cardPayment,\n        `Paid ${eventName} (from card)`,\n        'out',\n        splitEventId\n      );\n    } else if (walletTransactionId) {\n      // Wallet-only payment - fetch the transaction that was created by the RPC\n      const { data: existingTx } = await supabase\n        .from('transactions')\n        .select('*')\n        .eq('id', walletTransactionId)\n        .single();\n      \n      if (existingTx) {\n        payerTransaction = existingTx as Transaction;\n      } else {\n        // Fallback: create a reference transaction\n        payerTransaction = {\n          id: walletTransactionId,\n          user_id: userId,\n          type: 'split_payment',\n          amount: walletPayment,\n          description: `Paid ${eventName}`,\n          direction: 'out',\n          split_event_id: splitEventId,\n          created_at: new Date().toISOString()\n        } as Transaction;\n      }\n    } else {\n      // Edge case: no payment made (shouldn't happen with valid amount)\n      throw new Error('No payment was processed');\n    }\n\n    // STEP 5: Update split participant status to 'paid'\n    // This needs to happen after all payments are successful\n    try {\n      const { error: statusError } = await supabase\n        .from('split_participants')\n        .update({ status: 'paid', updated_at: new Date().toISOString() })\n        .eq('split_event_id', splitEventId)\n        .eq('user_id', userId)\n        .eq('is_creator', false);\n      \n      if (statusError) {\n        console.error('Failed to update split participant status:', statusError);\n      } else {\n        console.log(`Split participant status updated to paid for event ${splitEventId}`);\n      }\n    } catch (statusError) {\n      console.error('Failed to update split participant status:', statusError);\n      // Don't throw - payment was successful, just log the issue\n    }\n\n    console.log(`Split payment completed: $${amount.toFixed(2)} from ${userId} to ${recipientId}`);\n    \n    // STEP 6: Award XP for paying the split\n    let xpResult: XPAwardResult | null = null;\n    try {\n      // Get the split event creation date for speed bonuses\n      const { data: splitEvent } = await supabase\n        .from('split_events')\n        .select('created_at')\n        .eq('id', splitEventId)\n        .single();\n      \n      const splitCreatedAt = splitEvent?.created_at \n        ? new Date(splitEvent.created_at) \n        : new Date();\n      \n      xpResult = await GamificationService.onSplitPaid(\n        userId,\n        splitEventId,\n        amount,\n        splitCreatedAt\n      );\n      console.log(`XP awarded for split payment: ${xpResult?.xp_awarded || 0} XP`);\n    } catch (gamificationError) {\n      console.error('Gamification error (non-blocking):', gamificationError);\n    }\n    \n    // Check if this completes the split\n    try {\n      const { data: participants } = await supabase\n        .from('split_participants')\n        .select('user_id, status, is_creator')\n        .eq('split_event_id', splitEventId);\n      \n      if (participants) {\n        const nonCreatorParticipants = participants.filter(p => !p.is_creator);\n        const allPaid = nonCreatorParticipants.every(p => p.status === 'paid');\n        \n        if (allPaid && nonCreatorParticipants.length > 0) {\n          // Award completion XP\n          const participantIds = participants.map(p => p.user_id);\n          await GamificationService.onSplitCompleted(recipientId, splitEventId, participantIds);\n          console.log('Split completed - completion XP awarded');\n        }\n      }\n    } catch (completionError) {\n      console.error('Completion gamification error (non-blocking):', completionError);\n    }\n    \n    return { transaction: payerTransaction, xpResult };\n  }\n\n  static async getTransactions(userId: string): Promise<Transaction[]> {\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('*')\n      .eq('user_id', userId)\n      .order('created_at', { ascending: false });\n\n    if (error) throw error;\n    \n    // Strip sensitive data from metadata for user-facing transactions\n    // Keep bank_account_masked but remove full bank_account\n    const sanitizedData = (data || []).map(tx => {\n      if (tx.metadata && typeof tx.metadata === 'object') {\n        const { bank_account, ...safeMetadata } = tx.metadata as Record<string, unknown>;\n        return { ...tx, metadata: safeMetadata };\n      }\n      return tx;\n    });\n    \n    return sanitizedData as Transaction[];\n  }\n\n  static async getWithdrawalBankAccount(userId: string, transactionId: string): Promise<string | null> {\n    // Fetch full bank account for a specific withdrawal transaction\n    // Only the owner of the transaction can view this\n    const { data, error } = await supabase\n      .from('transactions')\n      .select('metadata')\n      .eq('id', transactionId)\n      .eq('user_id', userId)\n      .eq('type', 'withdrawal')\n      .single();\n\n    if (error || !data) return null;\n    \n    const metadata = data.metadata as Record<string, unknown> | null;\n    return (metadata?.bank_account as string) || null;\n  }\n}\n","path":null,"size_bytes":57938,"size_tokens":null},"services/splits.service.ts":{"content":"import { supabase } from './supabase';\nimport { BackendNotificationsService } from './backendNotifications.service';\nimport type { SplitEvent, SplitParticipant, Notification } from '@/shared/types';\nimport { PushNotificationsService } from './pushNotifications.service';\nimport { GamificationService, XPAwardResult } from './gamification.service';\nimport * as FileSystem from 'expo-file-system/legacy';\nimport { Platform } from 'react-native';\nimport { decode } from 'base64-arraybuffer';\n\nexport interface CreateSplitData {\n  name: string;\n  totalAmount: number;\n  splitType: 'equal' | 'specified';\n  creatorId: string;\n  participants: { userId: string; amount: number }[];\n  receiptUri?: string;\n}\n\nexport interface CreateSplitResult {\n  split: SplitEvent;\n  xpResult?: XPAwardResult | null;\n}\n\nexport interface PaySplitResult {\n  xpResult?: XPAwardResult | null;\n}\n\nconst SPLIT_RATE_LIMITS = {\n  MAX_SPLITS_PER_HOUR: 3,\n  MAX_SPLITS_PER_DAY: 5,\n  ONE_HOUR_MS: 60 * 60 * 1000,\n  ONE_DAY_MS: 24 * 60 * 60 * 1000,\n};\n\nexport class SplitsService {\n  private static async checkSplitCreationRateLimit(userId: string): Promise<void> {\n    const now = new Date();\n    const oneHourAgo = new Date(now.getTime() - SPLIT_RATE_LIMITS.ONE_HOUR_MS);\n    const oneDayAgo = new Date(now.getTime() - SPLIT_RATE_LIMITS.ONE_DAY_MS);\n    \n    const { data: recentSplits, error } = await supabase\n      .from('split_events')\n      .select('id, created_at')\n      .eq('creator_id', userId)\n      .gte('created_at', oneDayAgo.toISOString());\n    \n    if (error) {\n      console.error('Failed to check split rate limit:', error);\n      throw new Error('Unable to verify rate limits. Please try again in a moment.');\n    }\n    \n    const splitsLastHour = (recentSplits || []).filter(\n      s => new Date(s.created_at) >= oneHourAgo\n    ).length;\n    \n    const splitsLastDay = (recentSplits || []).length;\n    \n    if (splitsLastHour >= SPLIT_RATE_LIMITS.MAX_SPLITS_PER_HOUR) {\n      throw new Error(`You can only create ${SPLIT_RATE_LIMITS.MAX_SPLITS_PER_HOUR} splits per hour. Please wait before creating another split.`);\n    }\n    \n    if (splitsLastDay >= SPLIT_RATE_LIMITS.MAX_SPLITS_PER_DAY) {\n      throw new Error(`You can only create ${SPLIT_RATE_LIMITS.MAX_SPLITS_PER_DAY} splits per day. Please try again tomorrow.`);\n    }\n  }\n\n  static async createSplit(data: CreateSplitData): Promise<CreateSplitResult> {\n    await this.checkSplitCreationRateLimit(data.creatorId);\n    \n    let receiptUrl: string | undefined;\n\n    if (data.receiptUri) {\n      const fileExt = data.receiptUri.split('.').pop()?.toLowerCase() || 'jpg';\n      const fileName = `receipt-${Date.now()}.${fileExt}`;\n      const filePath = `receipts/${fileName}`;\n      const contentType = `image/${fileExt === 'jpg' ? 'jpeg' : fileExt}`;\n\n      let uploadData: ArrayBuffer | Blob;\n\n      if (Platform.OS === 'web') {\n        const response = await fetch(data.receiptUri);\n        uploadData = await response.blob();\n      } else {\n        const base64 = await FileSystem.readAsStringAsync(data.receiptUri, {\n          encoding: 'base64',\n        });\n        uploadData = decode(base64);\n      }\n\n      const { error: uploadError } = await supabase.storage\n        .from('user-uploads')\n        .upload(filePath, uploadData, {\n          contentType,\n        });\n\n      if (uploadError) throw uploadError;\n\n      const { data: { publicUrl } } = supabase.storage\n        .from('user-uploads')\n        .getPublicUrl(filePath);\n\n      receiptUrl = publicUrl;\n    }\n\n    const { data: split, error: splitError } = await supabase\n      .from('split_events')\n      .insert({\n        name: data.name,\n        total_amount: data.totalAmount,\n        split_type: data.splitType,\n        receipt_image: receiptUrl,\n        creator_id: data.creatorId,\n      })\n      .select()\n      .single();\n\n    if (splitError) throw splitError;\n\n    const participantsToInsert = data.participants.map(p => ({\n      split_event_id: split.id,\n      user_id: p.userId,\n      amount: p.amount,\n      status: p.userId === data.creatorId ? 'paid' : 'pending',\n      is_creator: p.userId === data.creatorId,\n    }));\n\n    const { error: participantsError } = await supabase\n      .from('split_participants')\n      .insert(participantsToInsert);\n\n    if (participantsError) throw participantsError;\n\n    const { data: creator } = await supabase\n      .from('users')\n      .select('name')\n      .eq('id', data.creatorId)\n      .single();\n\n    const notificationsToCreate = data.participants\n      .filter(p => p.userId !== data.creatorId)\n      .map(p => ({\n        user_id: p.userId,\n        type: 'split_invite',\n        title: 'New Split Request',\n        message: `${creator?.name || 'Someone'} wants to split ${data.name}`,\n        split_event_id: split.id,\n        metadata: {\n          split_type: data.splitType,\n          amount: p.amount.toString(),\n          creator_name: creator?.name,\n        },\n        read: false,\n      }));\n\n    if (notificationsToCreate.length > 0) {\n      // Create notifications via backend API\n      for (const notif of notificationsToCreate) {\n        await BackendNotificationsService.createNotification({\n          user_id: notif.user_id,\n          type: notif.type,\n          title: notif.title,\n          message: notif.message,\n          split_event_id: notif.split_event_id,\n          metadata: notif.metadata,\n        });\n      }\n\n      const inviteeIds = data.participants\n        .filter(p => p.userId !== data.creatorId)\n        .map(p => p.userId);\n      \n      for (const userId of inviteeIds) {\n        const participant = data.participants.find(p => p.userId === userId);\n        const notificationBody = data.splitType === 'specified'\n          ? `${creator?.name || 'Someone'} invited you to join a split for ${data.name}`\n          : `${creator?.name || 'Someone'} invited you to split $${participant?.amount.toFixed(2)} for ${data.name}`;\n        \n        await PushNotificationsService.sendPushToUser(userId, {\n          title: 'New Split Request',\n          body: notificationBody,\n          data: {\n            type: 'split_invite',\n            splitEventId: split.id,\n          },\n        });\n      }\n    }\n\n    // Award XP for creating the split\n    let xpResult: import('./gamification.service').XPAwardResult | null = null;\n    try {\n      xpResult = await GamificationService.onSplitCreated(\n        data.creatorId,\n        split.id,\n        data.totalAmount,\n        data.participants.length\n      );\n    } catch (gamificationError) {\n      console.error('Gamification error (non-blocking):', gamificationError);\n    }\n\n    return { split: split as SplitEvent, xpResult };\n  }\n\n  static async getSplits(userId: string): Promise<SplitEvent[]> {\n    console.log('[SplitsService] getSplits for user:', userId);\n    \n    const { data: participantIds, error: participantError } = await supabase\n      .from('split_participants')\n      .select('split_event_id')\n      .eq('user_id', userId);\n\n    if (participantError) {\n      console.error('[SplitsService] Failed to get participant IDs:', participantError);\n      throw participantError;\n    }\n    \n    console.log('[SplitsService] Found participant entries:', participantIds?.length || 0);\n    if (!participantIds || participantIds.length === 0) return [];\n\n    const splitIds = participantIds.map(p => p.split_event_id);\n    console.log('[SplitsService] Fetching splits:', splitIds);\n\n    const { data, error } = await supabase\n      .from('split_events')\n      .select(`\n        *,\n        creator:creator_id (\n          id,\n          unique_id,\n          name,\n          profile_picture\n        ),\n        participants:split_participants (\n          *,\n          user:user_id (\n            id,\n            unique_id,\n            name,\n            profile_picture\n          )\n        )\n      `)\n      .in('id', splitIds);\n\n    if (error) {\n      console.error('[SplitsService] Failed to get split events:', error);\n      throw error;\n    }\n\n    console.log('[SplitsService] Fetched splits:', data?.length || 0);\n    return data as SplitEvent[];\n  }\n\n  static async getSplitDetails(splitId: string): Promise<SplitEvent> {\n    console.log('[SplitsService] getSplitDetails for split:', splitId);\n    \n    const { data, error } = await supabase\n      .from('split_events')\n      .select(`\n        *,\n        creator:creator_id (\n          id,\n          unique_id,\n          name,\n          profile_picture\n        ),\n        participants:split_participants (\n          *,\n          user:user_id (\n            id,\n            unique_id,\n            name,\n            profile_picture\n          )\n        )\n      `)\n      .eq('id', splitId)\n      .single();\n\n    if (error) {\n      console.error('[SplitsService] Failed to get split details:', error);\n      throw error;\n    }\n    \n    console.log('[SplitsService] Split details loaded successfully');\n    return data as SplitEvent;\n  }\n\n  static async respondToSplit(\n    userId: string,\n    splitId: string,\n    response: 'accepted' | 'declined'\n  ): Promise<void> {\n    const { data: participant, error: fetchError } = await supabase\n      .from('split_participants')\n      .select('*, split_events(creator_id, name)')\n      .eq('split_event_id', splitId)\n      .eq('user_id', userId)\n      .single();\n\n    if (fetchError) throw fetchError;\n    if (participant.is_creator) throw new Error('Creator cannot respond to their own split');\n\n    const { error: updateError } = await supabase\n      .from('split_participants')\n      .update({ status: response })\n      .eq('split_event_id', splitId)\n      .eq('user_id', userId);\n\n    if (updateError) throw updateError;\n\n    const { data: user } = await supabase\n      .from('users')\n      .select('name')\n      .eq('id', userId)\n      .single();\n\n    const creatorId = (participant as any).split_events.creator_id;\n    const splitName = (participant as any).split_events.name;\n\n    // Create notification via backend API\n    await BackendNotificationsService.createNotification({\n      user_id: creatorId,\n      type: response === 'accepted' ? 'split_accepted' : 'split_declined',\n      title: response === 'accepted' ? 'Split Accepted' : 'Split Declined',\n      message: `${user?.name || 'Someone'} ${response} your split for ${splitName}`,\n      split_event_id: splitId,\n    });\n  }\n\n  static async respondToSplitWithAmount(\n    userId: string,\n    splitId: string,\n    response: 'accepted' | 'declined',\n    amount: number\n  ): Promise<void> {\n    const { data: participant, error: fetchError } = await supabase\n      .from('split_participants')\n      .select('*, split_events(creator_id, name)')\n      .eq('split_event_id', splitId)\n      .eq('user_id', userId)\n      .single();\n\n    if (fetchError) throw fetchError;\n    if (participant.is_creator) throw new Error('Creator cannot respond to their own split');\n\n    const { error: updateError } = await supabase\n      .from('split_participants')\n      .update({ \n        status: response,\n        amount: amount\n      })\n      .eq('split_event_id', splitId)\n      .eq('user_id', userId);\n\n    if (updateError) throw updateError;\n\n    const { data: user } = await supabase\n      .from('users')\n      .select('name')\n      .eq('id', userId)\n      .single();\n\n    const creatorId = (participant as any).split_events.creator_id;\n    const splitName = (participant as any).split_events.name;\n\n    // Create notification via backend API\n    await BackendNotificationsService.createNotification({\n      user_id: creatorId,\n      type: response === 'accepted' ? 'split_accepted' : 'split_declined',\n      title: response === 'accepted' ? 'Split Accepted' : 'Split Declined',\n      message: `${user?.name || 'Someone'} ${response} your split for ${splitName}${response === 'accepted' ? ` with $${amount.toFixed(2)}` : ''}`,\n      split_event_id: splitId,\n    });\n  }\n\n  static async updateParticipantAmount(\n    userId: string,\n    splitId: string,\n    amount: number\n  ): Promise<void> {\n    const { error } = await supabase\n      .from('split_participants')\n      .update({ amount: amount })\n      .eq('split_event_id', splitId)\n      .eq('user_id', userId);\n\n    if (error) throw error;\n  }\n\n  static async paySplit(userId: string, splitId: string): Promise<PaySplitResult> {\n    const { data: participant, error: fetchError } = await supabase\n      .from('split_participants')\n      .select('amount, split_events(creator_id, name, created_at)')\n      .eq('split_event_id', splitId)\n      .eq('user_id', userId)\n      .single();\n\n    if (fetchError) throw fetchError;\n\n    const { error: participantError } = await supabase\n      .from('split_participants')\n      .update({ status: 'paid' })\n      .eq('split_event_id', splitId)\n      .eq('user_id', userId);\n\n    if (participantError) throw participantError;\n\n    const creatorId = (participant as any).split_events.creator_id;\n    const splitName = (participant as any).split_events.name;\n    const splitCreatedAt = new Date((participant as any).split_events.created_at);\n\n    const { data: user } = await supabase\n      .from('users')\n      .select('name')\n      .eq('id', userId)\n      .single();\n\n    // Award XP for paying the split\n    let xpResult: XPAwardResult | null = null;\n    try {\n      xpResult = await GamificationService.onSplitPaid(\n        userId,\n        splitId,\n        participant.amount,\n        splitCreatedAt\n      );\n    } catch (gamificationError) {\n      console.error('Gamification error (non-blocking):', gamificationError);\n    }\n\n    // Create notification via backend API\n    await BackendNotificationsService.createNotification({\n      user_id: creatorId,\n      type: 'split_paid',\n      title: 'Payment Received',\n      message: `${user?.name || 'Someone'} paid their share for ${splitName}`,\n      split_event_id: splitId,\n    });\n\n    await PushNotificationsService.sendPushToUser(creatorId, {\n      title: 'Payment Received',\n      body: `${user?.name || 'Someone'} paid $${participant.amount.toFixed(2)} for ${splitName}`,\n      data: {\n        type: 'split_paid',\n        splitEventId: splitId,\n      },\n    });\n\n    await this.checkAndNotifySplitCompletion(splitId);\n    \n    return { xpResult };\n  }\n\n  static async checkAndNotifySplitCompletion(splitId: string): Promise<void> {\n    try {\n      const { data: participants, error } = await supabase\n        .from('split_participants')\n        .select('user_id, status, is_creator, split_events(creator_id, name, total_amount)')\n        .eq('split_event_id', splitId);\n\n      if (error || !participants || participants.length === 0) return;\n\n      const nonCreatorParticipants = participants.filter(p => !p.is_creator);\n      const allPaid = nonCreatorParticipants.every(p => p.status === 'paid');\n\n      if (allPaid && nonCreatorParticipants.length > 0) {\n        const creatorId = (participants[0] as any).split_events.creator_id;\n        const splitName = (participants[0] as any).split_events.name;\n        const totalAmount = (participants[0] as any).split_events.total_amount;\n\n        const { data: existingNotification } = await supabase\n          .from('notifications')\n          .select('id')\n          .eq('user_id', creatorId)\n          .eq('split_event_id', splitId)\n          .eq('type', 'split_completed')\n          .single();\n\n        if (!existingNotification) {\n          // Award XP for 100% completion\n          try {\n            const participantIds = participants.map(p => p.user_id);\n            await GamificationService.onSplitCompleted(creatorId, splitId, participantIds);\n          } catch (gamificationError) {\n            console.error('Gamification completion error (non-blocking):', gamificationError);\n          }\n\n          // Create notification via backend API\n          await BackendNotificationsService.createNotification({\n            user_id: creatorId,\n            type: 'split_completed',\n            title: 'Split Complete!',\n            message: `Everyone has paid for ${splitName}. You collected $${parseFloat(totalAmount).toFixed(2)}!`,\n            split_event_id: splitId,\n          });\n\n          await PushNotificationsService.sendPushToUser(creatorId, {\n            title: 'Split Complete!',\n            body: `Everyone has paid for ${splitName}. You collected $${parseFloat(totalAmount).toFixed(2)}!`,\n            data: {\n              type: 'split_completed',\n              splitEventId: splitId,\n            },\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error checking split completion:', error);\n    }\n  }\n\n  static async deleteSplit(userId: string, splitId: string): Promise<void> {\n    // Verify the user is the creator of this split\n    const { data: split, error: fetchError } = await supabase\n      .from('split_events')\n      .select('id, creator_id, name')\n      .eq('id', splitId)\n      .single();\n\n    if (fetchError) throw fetchError;\n    if (!split) throw new Error('Split event not found');\n    if (split.creator_id !== userId) throw new Error('Only the creator can delete this split');\n\n    // Get all participants to notify them\n    const { data: participants } = await supabase\n      .from('split_participants')\n      .select('user_id, status')\n      .eq('split_event_id', splitId);\n\n    // Delete all notifications related to this split BEFORE deleting the split\n    // This removes accept/decline buttons from all participants' notification lists\n    try {\n      const { error: notifDeleteError } = await supabase\n        .from('notifications')\n        .delete()\n        .eq('split_event_id', splitId);\n      \n      if (notifDeleteError) {\n        console.error('Failed to delete split notifications:', notifDeleteError);\n      }\n    } catch (notifError) {\n      console.error('Error deleting split notifications:', notifError);\n    }\n\n    // Delete the split event (cascade will delete participants)\n    const { error: deleteError } = await supabase\n      .from('split_events')\n      .delete()\n      .eq('id', splitId);\n\n    if (deleteError) throw deleteError;\n\n    // Notify all non-creator participants that the split was cancelled\n    if (participants) {\n      const nonCreatorParticipants = participants.filter(p => p.user_id !== userId);\n      \n      for (const participant of nonCreatorParticipants) {\n        await BackendNotificationsService.createNotification({\n          user_id: participant.user_id,\n          type: 'split_cancelled',\n          title: 'Split Cancelled',\n          message: `The split \"${split.name}\" has been cancelled by the creator`,\n        });\n\n        await PushNotificationsService.sendPushToUser(participant.user_id, {\n          title: 'Split Cancelled',\n          body: `The split \"${split.name}\" has been cancelled by the creator`,\n          data: {\n            type: 'split_cancelled',\n          },\n        });\n      }\n    }\n  }\n\n  // Subscribe to realtime updates for user's splits with full participant coverage\n  // Uses per-split channels with stable naming (limited to MAX_SPLIT_CHANNELS)\n  // Also maintains always-on invite listener for new split invitations\n  private static MAX_SPLIT_CHANNELS = 20;\n\n  static subscribeToSplitUpdates(\n    userId: string,\n    onUpdate: () => void\n  ): { unsubscribe: () => void; updateSplitIds: (ids: string[]) => void } {\n    let debounceTimer: ReturnType<typeof setTimeout> | null = null;\n    const splitChannels: Map<string, ReturnType<typeof supabase.channel>> = new Map();\n    let isUnsubscribed = false;\n\n    const debouncedUpdate = () => {\n      if (isUnsubscribed) return;\n      if (debounceTimer) clearTimeout(debounceTimer);\n      debounceTimer = setTimeout(onUpdate, 300);\n    };\n\n    // Always-on invite channel - never destroyed until unsubscribe\n    const inviteChannel = supabase\n      .channel(`split_invites_${userId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'split_participants',\n          filter: `user_id=eq.${userId}`,\n        },\n        () => debouncedUpdate()\n      )\n      .subscribe();\n\n    // Create individual per-split subscription with stable channel name\n    const subscribeToSplit = (splitId: string) => {\n      if (splitChannels.has(splitId) || isUnsubscribed) return;\n\n      const channel = supabase\n        .channel(`split_realtime_${splitId}`)\n        .on(\n          'postgres_changes',\n          {\n            event: '*',\n            schema: 'public',\n            table: 'split_participants',\n            filter: `split_event_id=eq.${splitId}`,\n          },\n          () => debouncedUpdate()\n        )\n        .on(\n          'postgres_changes',\n          {\n            event: '*',\n            schema: 'public',\n            table: 'split_events',\n            filter: `id=eq.${splitId}`,\n          },\n          () => debouncedUpdate()\n        )\n        .subscribe();\n\n      splitChannels.set(splitId, channel);\n    };\n\n    const unsubscribeFromSplit = (splitId: string) => {\n      const channel = splitChannels.get(splitId);\n      if (channel) {\n        supabase.removeChannel(channel);\n        splitChannels.delete(splitId);\n      }\n    };\n\n    return {\n      unsubscribe: () => {\n        isUnsubscribed = true;\n        if (debounceTimer) clearTimeout(debounceTimer);\n        supabase.removeChannel(inviteChannel);\n        splitChannels.forEach(channel => supabase.removeChannel(channel));\n        splitChannels.clear();\n      },\n      updateSplitIds: (newSplitIds: string[]) => {\n        if (isUnsubscribed) return;\n        \n        // Limit to MAX_SPLIT_CHANNELS most recent splits\n        const limitedIds = newSplitIds.slice(0, SplitsService.MAX_SPLIT_CHANNELS);\n        const newSet = new Set(limitedIds);\n        \n        // Remove channels for splits no longer in the list\n        const toRemove: string[] = [];\n        splitChannels.forEach((_, id) => {\n          if (!newSet.has(id)) {\n            toRemove.push(id);\n          }\n        });\n        toRemove.forEach(id => unsubscribeFromSplit(id));\n        \n        // Add channels for new splits (only if not already subscribed)\n        limitedIds.forEach(id => {\n          if (!splitChannels.has(id)) {\n            subscribeToSplit(id);\n          }\n        });\n      },\n    };\n  }\n\n  // Subscribe to realtime updates for a specific split event\n  static subscribeToSplitEventUpdates(\n    splitId: string,\n    onUpdate: () => void\n  ): { unsubscribe: () => void } {\n    const channel = supabase\n      .channel(`split_event_${splitId}`)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'split_participants',\n          filter: `split_event_id=eq.${splitId}`,\n        },\n        () => {\n          onUpdate();\n        }\n      )\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'split_events',\n          filter: `id=eq.${splitId}`,\n        },\n        () => {\n          onUpdate();\n        }\n      )\n      .subscribe();\n\n    return {\n      unsubscribe: () => {\n        supabase.removeChannel(channel);\n      },\n    };\n  }\n}\n","path":null,"size_bytes":23030,"size_tokens":null},"services/auth.service.ts":{"content":"import { supabase } from './supabase';\nimport type { User } from '@/shared/types';\nimport { GamificationService } from './gamification.service';\nimport * as FileSystem from 'expo-file-system/legacy';\nimport { Platform } from 'react-native';\nimport { decode } from 'base64-arraybuffer';\n\nexport interface SignupData {\n  name: string;\n  email: string;\n  password: string;\n  phone?: string;\n  dateOfBirth?: string;\n  bio?: string;\n  uniqueId: string;\n  profilePicture?: string;\n}\n\nexport class AuthService {\n  static async signup(data: SignupData): Promise<{ user: User; session: any }> {\n    const { data: authData, error: authError } = await supabase.auth.signUp({\n      email: data.email,\n      password: data.password,\n      options: {\n        emailRedirectTo: undefined,\n        data: {\n          name: data.name,\n          unique_id: data.uniqueId,\n          phone: data.phone,\n          date_of_birth: data.dateOfBirth,\n          bio: data.bio,\n        },\n      },\n    });\n\n    if (authError) throw authError;\n    if (!authData.user) throw new Error('User creation failed');\n\n    if (!authData.session) {\n      throw new Error('Email confirmation required. Please check your email and confirm your account before logging in.');\n    }\n\n    // Upload profile picture FIRST (before creating profile) to include in initial INSERT\n    // This avoids RLS UPDATE issues during signup\n    let profilePictureUrl: string | null = null;\n    if (data.profilePicture) {\n      console.log('Profile picture provided, uploading before profile creation...');\n      console.log('Profile picture URI:', data.profilePicture.substring(0, 100) + '...');\n      try {\n        profilePictureUrl = await this.uploadProfilePictureToStorage(authData.user.id, data.profilePicture);\n        console.log('Profile picture uploaded to storage:', profilePictureUrl);\n      } catch (uploadError: any) {\n        console.error('Profile picture upload failed during signup:', uploadError);\n        console.error('Upload error details:', JSON.stringify(uploadError, null, 2));\n        // Continue with signup even if picture upload fails\n      }\n    } else {\n      console.log('No profile picture provided in signup data');\n    }\n\n    // Use SECURITY DEFINER functions to bypass RLS for user/wallet creation\n    console.log('Creating user profile with ID:', authData.user.id);\n    const { data: profileData, error: profileError } = await supabase\n      .rpc('create_user_profile', {\n        user_id: authData.user.id,\n        user_unique_id: data.uniqueId,\n        user_name: data.name,\n        user_email: data.email,\n        user_phone: data.phone || null,\n        user_dob: data.dateOfBirth || null,\n        user_bio: data.bio || null,\n        user_profile_picture: profilePictureUrl,\n      });\n\n    if (profileError) {\n      console.error('Failed to create user profile:', JSON.stringify(profileError));\n      throw profileError;\n    }\n    \n    const profile = Array.isArray(profileData) ? profileData[0] : profileData;\n    if (!profile) {\n      throw new Error('Failed to create user profile - no data returned');\n    }\n    console.log('User profile created successfully:', profile.id);\n\n    console.log('Creating wallet for user:', authData.user.id);\n    const { error: walletError } = await supabase\n      .rpc('create_user_wallet', {\n        p_user_id: authData.user.id,\n      });\n\n    if (walletError) {\n      console.error('Failed to create wallet:', JSON.stringify(walletError));\n      throw walletError;\n    }\n    console.log('Wallet created successfully');\n\n    // Initialize gamification profile\n    try {\n      await GamificationService.initializeUser(authData.user.id);\n      console.log('Gamification profile initialized');\n    } catch (gamificationError) {\n      console.error('Failed to initialize gamification (non-blocking):', gamificationError);\n    }\n\n    return { user: profile as User, session: authData.session };\n  }\n\n  static async login(email: string, password: string): Promise<{ user: User; session: any }> {\n    const { data: authData, error: authError } = await supabase.auth.signInWithPassword({\n      email,\n      password,\n    });\n\n    if (authError) throw authError;\n    if (!authData.user) throw new Error('Login failed');\n\n    // Try to get existing profile\n    let { data: profile, error: profileError } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', authData.user.id)\n      .single();\n\n    // If profile doesn't exist, create it from auth metadata using RPC\n    if (profileError && profileError.code === 'PGRST116') {\n      console.log('Profile not found, creating from auth metadata...');\n      const authMetadata = authData.user.user_metadata || {};\n      const uniqueId = authMetadata.unique_id || String(Math.floor(10000000 + Math.random() * 90000000));\n      \n      const { data: newProfileData, error: insertError } = await supabase\n        .rpc('create_user_profile', {\n          user_id: authData.user.id,\n          user_unique_id: uniqueId,\n          user_name: authMetadata.name || email.split('@')[0],\n          user_email: email,\n          user_phone: authMetadata.phone || null,\n          user_dob: authMetadata.date_of_birth || null,\n          user_bio: authMetadata.bio || null,\n          user_profile_picture: null,\n        });\n\n      if (insertError) {\n        console.error('Failed to create profile:', insertError);\n        throw new Error('Failed to create user profile');\n      }\n\n      profile = Array.isArray(newProfileData) ? newProfileData[0] : newProfileData;\n\n      // Also create wallet using RPC\n      await supabase.rpc('create_user_wallet', { p_user_id: authData.user.id });\n      \n      console.log('Profile and wallet created for user:', authData.user.id);\n    } else if (profileError) {\n      throw profileError;\n    }\n\n    // Ensure wallet exists\n    const { data: wallet } = await supabase\n      .from('wallets')\n      .select('id')\n      .eq('user_id', authData.user.id)\n      .single();\n\n    if (!wallet) {\n      await supabase.rpc('create_user_wallet', { p_user_id: authData.user.id });\n    }\n\n    // Initialize gamification profile for existing users (if not exists)\n    try {\n      await GamificationService.initializeUser(authData.user.id);\n    } catch (gamificationError) {\n      console.error('Failed to initialize gamification on login (non-blocking):', gamificationError);\n    }\n\n    return { user: profile as User, session: authData.session };\n  }\n\n  static async logout(): Promise<void> {\n    await supabase.auth.signOut();\n  }\n\n  static async getCurrentUser(): Promise<User | null> {\n    const { data: { user: authUser } } = await supabase.auth.getUser();\n    \n    if (!authUser) return null;\n\n    const { data: profile } = await supabase\n      .from('users')\n      .select('*')\n      .eq('id', authUser.id)\n      .single();\n\n    return profile as User;\n  }\n\n  static async restoreSession(): Promise<{ user: User; session: any } | null> {\n    try {\n      const { data: { session }, error } = await supabase.auth.getSession();\n      \n      if (error) {\n        if (error.message?.includes('Refresh Token') || error.message?.includes('Invalid')) {\n          await supabase.auth.signOut();\n        }\n        return null;\n      }\n      \n      if (!session || !session.user) {\n        return null;\n      }\n\n      const { data: profile } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', session.user.id)\n        .single();\n\n      if (!profile) return null;\n\n      // Check if profile is complete (has phone and DOB)\n      // Incomplete profiles from social auth need to complete signup flow\n      const isProfileComplete = Boolean(profile.phone && profile.date_of_birth);\n      if (!isProfileComplete) {\n        console.log('[AuthService] Profile incomplete (missing phone/DOB), not restoring session');\n        return null;\n      }\n\n      return { user: profile as User, session };\n    } catch (error: any) {\n      if (error?.message?.includes('Refresh Token') || error?.message?.includes('Invalid')) {\n        try {\n          await supabase.auth.signOut();\n        } catch {}\n      }\n      return null;\n    }\n  }\n\n  static async updateProfile(userId: string, updates: Partial<User>): Promise<User> {\n    const { data, error } = await supabase\n      .from('users')\n      .update(updates)\n      .eq('id', userId)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return data as User;\n  }\n\n  // Upload profile picture to storage ONLY (no database update)\n  // Used during signup to get URL before initial INSERT\n  static async uploadProfilePictureToStorage(userId: string, fileUri: string): Promise<string> {\n    console.log('uploadProfilePictureToStorage called with userId:', userId);\n    console.log('Full file URI:', fileUri);\n    \n    let fileExt = 'jpg';\n    const uriParts = fileUri.split('.');\n    if (uriParts.length > 1) {\n      const lastPart = uriParts[uriParts.length - 1].split('?')[0].toLowerCase();\n      if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(lastPart)) {\n        fileExt = lastPart;\n      }\n    }\n    \n    const fileName = `${userId}-${Date.now()}.${fileExt}`;\n    const filePath = `profile-pictures/${fileName}`;\n    console.log('File path:', filePath, 'Extension:', fileExt);\n\n    let uploadData: ArrayBuffer | Blob;\n    let contentType = `image/${fileExt === 'jpg' ? 'jpeg' : fileExt}`;\n\n    try {\n      if (Platform.OS === 'web') {\n        console.log('Web platform - using fetch/blob');\n        const response = await fetch(fileUri);\n        if (!response.ok) {\n          throw new Error(`Failed to fetch image: ${response.status}`);\n        }\n        uploadData = await response.blob();\n        console.log('Blob size:', (uploadData as Blob).size);\n      } else {\n        console.log('Native platform - using FileSystem');\n        const fileInfo = await FileSystem.getInfoAsync(fileUri);\n        console.log('File info:', JSON.stringify(fileInfo));\n        \n        if (!fileInfo.exists) {\n          throw new Error('File does not exist at URI');\n        }\n        \n        const base64 = await FileSystem.readAsStringAsync(fileUri, {\n          encoding: 'base64',\n        });\n        console.log('Base64 length:', base64.length);\n        \n        if (!base64 || base64.length === 0) {\n          throw new Error('Failed to read file as base64');\n        }\n        \n        uploadData = decode(base64);\n        console.log('Decoded ArrayBuffer size:', (uploadData as ArrayBuffer).byteLength);\n      }\n    } catch (fileError: any) {\n      console.error('Error reading file:', fileError);\n      throw new Error(`Failed to read image file: ${fileError.message}`);\n    }\n\n    console.log('Uploading to Supabase storage...');\n    const { error: uploadError } = await supabase.storage\n      .from('user-uploads')\n      .upload(filePath, uploadData, {\n        contentType,\n        upsert: true,\n      });\n\n    if (uploadError) {\n      console.error('Supabase storage upload error:', uploadError);\n      throw uploadError;\n    }\n\n    console.log('Upload successful, getting public URL...');\n    const { data: { publicUrl } } = supabase.storage\n      .from('user-uploads')\n      .getPublicUrl(filePath);\n    console.log('Public URL:', publicUrl);\n\n    return publicUrl;\n  }\n\n  // Upload profile picture and update user profile (for profile screen)\n  static async uploadProfilePicture(userId: string, fileUri: string): Promise<string> {\n    console.log('uploadProfilePicture called with userId:', userId);\n    console.log('Full file URI:', fileUri);\n    \n    // Handle different URI formats\n    let cleanUri = fileUri;\n    \n    // Extract file extension properly\n    let fileExt = 'jpg';\n    const uriParts = fileUri.split('.');\n    if (uriParts.length > 1) {\n      const lastPart = uriParts[uriParts.length - 1].split('?')[0].toLowerCase();\n      if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(lastPart)) {\n        fileExt = lastPart;\n      }\n    }\n    \n    const fileName = `${userId}-${Date.now()}.${fileExt}`;\n    const filePath = `profile-pictures/${fileName}`;\n    console.log('File path:', filePath, 'Extension:', fileExt);\n\n    let uploadData: ArrayBuffer | Blob;\n    let contentType = `image/${fileExt === 'jpg' ? 'jpeg' : fileExt}`;\n\n    try {\n      if (Platform.OS === 'web') {\n        console.log('Web platform - using fetch/blob');\n        const response = await fetch(fileUri);\n        if (!response.ok) {\n          throw new Error(`Failed to fetch image: ${response.status}`);\n        }\n        uploadData = await response.blob();\n        console.log('Blob size:', (uploadData as Blob).size);\n      } else {\n        console.log('Native platform - using FileSystem');\n        \n        // Check if file exists\n        const fileInfo = await FileSystem.getInfoAsync(cleanUri);\n        console.log('File info:', JSON.stringify(fileInfo));\n        \n        if (!fileInfo.exists) {\n          throw new Error('File does not exist at URI');\n        }\n        \n        const base64 = await FileSystem.readAsStringAsync(cleanUri, {\n          encoding: 'base64',\n        });\n        console.log('Base64 length:', base64.length);\n        \n        if (!base64 || base64.length === 0) {\n          throw new Error('Failed to read file as base64');\n        }\n        \n        uploadData = decode(base64);\n        console.log('Decoded ArrayBuffer size:', (uploadData as ArrayBuffer).byteLength);\n      }\n    } catch (fileError: any) {\n      console.error('Error reading file:', fileError);\n      throw new Error(`Failed to read image file: ${fileError.message}`);\n    }\n\n    console.log('Uploading to Supabase storage...');\n    const { error: uploadError } = await supabase.storage\n      .from('user-uploads')\n      .upload(filePath, uploadData, {\n        contentType,\n        upsert: true,\n      });\n\n    if (uploadError) {\n      console.error('Supabase storage upload error:', uploadError);\n      throw uploadError;\n    }\n\n    console.log('Upload successful, getting public URL...');\n    const { data: { publicUrl } } = supabase.storage\n      .from('user-uploads')\n      .getPublicUrl(filePath);\n    console.log('Public URL:', publicUrl);\n\n    console.log('Updating user profile with picture URL...');\n    await this.updateProfile(userId, { profile_picture: publicUrl });\n    console.log('Profile updated successfully');\n\n    return publicUrl;\n  }\n\n  static async uploadProfilePictureWeb(userId: string, file: File, fileName: string): Promise<string> {\n    const fileExt = fileName.split('.').pop() || 'jpg';\n    const newFileName = `${userId}-${Date.now()}.${fileExt}`;\n    const filePath = `profile-pictures/${newFileName}`;\n\n    const { error: uploadError } = await supabase.storage\n      .from('user-uploads')\n      .upload(filePath, file, {\n        contentType: file.type || `image/${fileExt}`,\n        upsert: true,\n      });\n\n    if (uploadError) throw uploadError;\n\n    const { data: { publicUrl } } = supabase.storage\n      .from('user-uploads')\n      .getPublicUrl(filePath);\n\n    await this.updateProfile(userId, { profile_picture: publicUrl });\n\n    return publicUrl;\n  }\n\n  static async deleteAccount(): Promise<void> {\n    const { data: { session } } = await supabase.auth.getSession();\n    \n    if (!session?.access_token) {\n      throw new Error('Not authenticated');\n    }\n\n    const backendUrl = process.env.EXPO_PUBLIC_BACKEND_URL || 'https://splinepay.replit.app';\n    \n    // Create AbortController for fetch timeout\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout\n    \n    try {\n      const response = await fetch(`${backendUrl}/api/delete-account`, {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${session.access_token}`,\n          'Content-Type': 'application/json',\n        },\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        let errorMessage = 'Failed to delete account';\n        try {\n          const errorData = await response.json();\n          errorMessage = errorData.error || errorMessage;\n        } catch (parseError) {\n          // Response was not JSON, use status text\n          errorMessage = response.statusText || errorMessage;\n        }\n        throw new Error(errorMessage);\n      }\n    } catch (error: any) {\n      clearTimeout(timeoutId);\n      if (error.name === 'AbortError') {\n        throw new Error('The request timed out. Please check your internet connection and try again.');\n      }\n      throw error;\n    }\n    \n    // NOTE: We intentionally do NOT call supabase.auth.signOut() here.\n    // The calling component handles showing a success message first,\n    // then calls logout() which will clear the user state and sign out.\n    // This prevents a race condition where the UI unmounts before\n    // the user can see the confirmation message.\n  }\n}\n","path":null,"size_bytes":16835,"size_tokens":null},"SUPABASE_SETUP.md":{"content":"# Supabase Setup Guide\n\nThis app uses Supabase for:\n- PostgreSQL database\n- Authentication (signup/login with email & password)\n- File storage (profile pictures & receipt images)\n- Real-time cross-device data sync\n\n## Step 1: Create a Supabase Project\n\n1. Go to [supabase.com](https://supabase.com) and sign up (it's free!)\n2. Click \"New Project\"\n3. Choose a name (e.g., \"Split Payment App\")\n4. Create a strong database password (save it somewhere safe)\n5. Select a region close to you\n6. Click \"Create new project\" (takes ~2 minutes to set up)\n\n## Step 2: Get Your API Keys\n\nOnce your project is created:\n\n1. Go to **Project Settings** (gear icon in sidebar)\n2. Click **API** in the left menu\n3. You'll need these two values:\n   - **Project URL** (looks like: `https://xxxxxxxxxxxxx.supabase.co`)\n   - **anon public** key (long string starting with `eyJ...`)\n\n## Step 3: Create Database Tables\n\n1. In your Supabase dashboard, click **SQL Editor** in the sidebar\n2. Copy and paste this entire SQL script:\n\n```sql\n-- Enable UUID extension\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n-- Users table\nCREATE TABLE users (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  unique_id TEXT UNIQUE NOT NULL,\n  name TEXT NOT NULL,\n  email TEXT UNIQUE NOT NULL,\n  phone TEXT,\n  date_of_birth TEXT,\n  bio TEXT,\n  profile_picture TEXT,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Friends table\nCREATE TABLE friends (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n  friend_id UUID REFERENCES users(id) ON DELETE CASCADE,\n  status TEXT DEFAULT 'accepted',\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  UNIQUE(user_id, friend_id)\n);\n\n-- Split events table\nCREATE TABLE split_events (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  name TEXT NOT NULL,\n  total_amount DECIMAL(10,2) NOT NULL,\n  split_type TEXT NOT NULL,\n  receipt_image TEXT,\n  creator_id UUID REFERENCES users(id) ON DELETE CASCADE,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Split participants table\nCREATE TABLE split_participants (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  split_event_id UUID REFERENCES split_events(id) ON DELETE CASCADE,\n  user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n  amount DECIMAL(10,2) NOT NULL,\n  status TEXT DEFAULT 'pending',\n  is_creator BOOLEAN DEFAULT FALSE,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW(),\n  UNIQUE(split_event_id, user_id)\n);\n\n-- Wallets table\nCREATE TABLE wallets (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID UNIQUE REFERENCES users(id) ON DELETE CASCADE,\n  balance DECIMAL(10,2) DEFAULT 0.00,\n  bank_connected BOOLEAN DEFAULT FALSE,\n  bank_details JSONB,\n  blinkpay_consent_id TEXT,\n  blinkpay_consent_status TEXT,\n  blinkpay_consent_expires_at TIMESTAMPTZ,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Transactions table\nCREATE TABLE transactions (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n  type TEXT NOT NULL,\n  amount DECIMAL(10,2) NOT NULL,\n  description TEXT NOT NULL,\n  direction TEXT NOT NULL,\n  split_event_id UUID REFERENCES split_events(id) ON DELETE SET NULL,\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Notifications table\nCREATE TABLE notifications (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n  type TEXT NOT NULL,\n  title TEXT NOT NULL,\n  message TEXT NOT NULL,\n  split_event_id UUID REFERENCES split_events(id) ON DELETE CASCADE,\n  metadata JSONB,\n  read BOOLEAN DEFAULT FALSE,\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\n-- Create a function to handle split payments\nCREATE OR REPLACE FUNCTION process_split_payment(\n  payer_id UUID,\n  recipient_id UUID,\n  amount DECIMAL\n) RETURNS void AS $$\nBEGIN\n  -- Deduct from payer\n  UPDATE wallets\n  SET balance = balance - amount\n  WHERE user_id = payer_id;\n  \n  -- Add to recipient\n  UPDATE wallets\n  SET balance = balance + amount\n  WHERE user_id = recipient_id;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Create indexes for better query performance\nCREATE INDEX idx_friends_user_id ON friends(user_id);\nCREATE INDEX idx_split_participants_user_id ON split_participants(user_id);\nCREATE INDEX idx_split_participants_split_id ON split_participants(split_event_id);\nCREATE INDEX idx_transactions_user_id ON transactions(user_id);\nCREATE INDEX idx_notifications_user_id ON notifications(user_id);\n```\n\n3. Click **Run** to execute the script\n\n## Step 4: Set Up Storage Bucket\n\n1. In Supabase dashboard, click **Storage** in the sidebar\n2. Click **Create a new bucket**\n3. Name it: `user-uploads`\n4. Make it **Public** (check the box)\n5. Click **Create bucket**\n\n### Storage Policies for Uploads\n\nAfter creating the bucket, add these storage policies to allow authenticated users to upload files:\n\n1. Go to **Storage** > **Policies** tab\n2. Click **New Policy** for the `user-uploads` bucket\n3. Add these policies (you can use the \"For full customization\" option and paste):\n\n```sql\n-- Allow authenticated users to upload files to their profile folder\nCREATE POLICY \"Allow authenticated users to upload profile pictures\"\nON storage.objects FOR INSERT\nTO authenticated\nWITH CHECK (\n  bucket_id = 'user-uploads' AND\n  (storage.foldername(name))[1] = 'profile-pictures'\n);\n\n-- Allow authenticated users to upload receipt images\nCREATE POLICY \"Allow authenticated users to upload receipts\"\nON storage.objects FOR INSERT\nTO authenticated\nWITH CHECK (\n  bucket_id = 'user-uploads' AND\n  (storage.foldername(name))[1] = 'receipts'\n);\n\n-- Allow anyone to view uploaded files (bucket is public)\nCREATE POLICY \"Allow public read access\"\nON storage.objects FOR SELECT\nTO public\nUSING (bucket_id = 'user-uploads');\n\n-- Allow users to update their own uploads\nCREATE POLICY \"Allow users to update own uploads\"\nON storage.objects FOR UPDATE\nTO authenticated\nUSING (bucket_id = 'user-uploads');\n\n-- Allow users to delete their own uploads\nCREATE POLICY \"Allow users to delete own uploads\"\nON storage.objects FOR DELETE\nTO authenticated\nUSING (bucket_id = 'user-uploads');\n```\n\n**Note**: If the bucket is marked as \"Public\" in Supabase, read access is allowed by default. The INSERT policies are what control who can upload files.\n\n## Step 5: Disable Email Confirmation (For Development)\n\nTo make signup easier during development:\n\n1. Go to **Authentication** > **Providers** in the sidebar\n2. Click on **Email** provider\n3. Scroll down to **Email Confirmation**\n4. **Disable** \"Confirm email\"\n5. Click **Save**\n\nThis allows users to signup and login immediately without email verification.\n\n### ⚠️ Rate Limit Issues\n\nIf you see the error `over_email_send_rate_limit` during signup:\n\n**Cause**: Supabase limits how many emails can be sent in a short time period (protection against spam).\n\n**Solutions**:\n1. **Wait** 10-15 minutes for the rate limit to reset, then try again\n2. **Disable email confirmation** (see steps above) - this completely bypasses email sending during development\n3. **Delete previous signups** - Go to Authentication > Users in Supabase dashboard and delete test accounts to free up your email quota\n\n## Step 6: Configure Row Level Security (RLS)\n\nFor security, we need to set up RLS policies:\n\n1. Go to **Authentication** > **Policies**\n2. For each table, click **Enable RLS**\n3. Add these policies (copy-paste into SQL Editor):\n\n```sql\n-- Users: Users can read all, insert and update their own\nCREATE POLICY \"Users can view all users\" ON users FOR SELECT USING (true);\nCREATE POLICY \"Users can insert own profile\" ON users FOR INSERT WITH CHECK (auth.uid() = id);\nCREATE POLICY \"Users can update own profile\" ON users FOR UPDATE USING (auth.uid() = id);\n\n-- Friends: Users can manage their own friendships\nCREATE POLICY \"Users can view own friends\" ON friends FOR SELECT USING (auth.uid() = user_id);\nCREATE POLICY \"Users can insert own friends\" ON friends FOR INSERT WITH CHECK (auth.uid() = user_id);\nCREATE POLICY \"Users can delete own friends\" ON friends FOR DELETE USING (auth.uid() = user_id);\n\n-- Split events: Users can view splits they're part of\nCREATE POLICY \"Users can view their splits\" ON split_events FOR SELECT \n  USING (auth.uid() IN (\n    SELECT user_id FROM split_participants WHERE split_event_id = id\n  ));\nCREATE POLICY \"Users can create splits\" ON split_events FOR INSERT \n  WITH CHECK (auth.uid() = creator_id);\n\n-- Split participants: Users can view and update their participations\nCREATE POLICY \"Users can view split participants\" ON split_participants FOR SELECT\n  USING (auth.uid() = user_id OR auth.uid() IN (\n    SELECT creator_id FROM split_events WHERE id = split_event_id\n  ));\nCREATE POLICY \"Creators can add participants\" ON split_participants FOR INSERT\n  WITH CHECK (auth.uid() IN (\n    SELECT creator_id FROM split_events WHERE id = split_event_id\n  ));\nCREATE POLICY \"Users can update own participation\" ON split_participants FOR UPDATE\n  USING (auth.uid() = user_id);\n\n-- Wallets: Users can only access their own wallet\nCREATE POLICY \"Users can view own wallet\" ON wallets FOR SELECT USING (auth.uid() = user_id);\nCREATE POLICY \"Users can update own wallet\" ON wallets FOR UPDATE USING (auth.uid() = user_id);\nCREATE POLICY \"Users can insert own wallet\" ON wallets FOR INSERT WITH CHECK (auth.uid() = user_id);\n\n-- Transactions: Users can only see their own transactions\nCREATE POLICY \"Users can view own transactions\" ON transactions FOR SELECT USING (auth.uid() = user_id);\nCREATE POLICY \"System can insert transactions\" ON transactions FOR INSERT WITH CHECK (true);\n\n-- Notifications: Users can only see their own notifications\nCREATE POLICY \"Users can view own notifications\" ON notifications FOR SELECT USING (auth.uid() = user_id);\nCREATE POLICY \"Users can update own notifications\" ON notifications FOR UPDATE USING (auth.uid() = user_id);\nCREATE POLICY \"Users can delete own notifications\" ON notifications FOR DELETE USING (auth.uid() = user_id);\nCREATE POLICY \"System can create notifications\" ON notifications FOR INSERT WITH CHECK (true);\n```\n\n## Step 7: Provide Credentials to the App\n\nYou'll need to add these as environment variables:\n- `EXPO_PUBLIC_SUPABASE_URL` = Your Project URL\n- `EXPO_PUBLIC_SUPABASE_ANON_KEY` = Your anon public key\n\nThe agent will request these from you next!\n\n## Done!\n\nYour Supabase backend is now ready to sync data across all devices where users install your app!\n\n## Important Notes\n\n- **Email Confirmation**: We disabled this for development. For production, re-enable it and implement email verification flow.\n- **Security**: The RLS policies ensure users can only access their own data.\n- **Session Persistence**: Sessions are automatically saved and restored using AsyncStorage.\n- **Token Refresh**: Supabase automatically refreshes auth tokens in the background.\n\n## Migrations (If You Already Have Tables)\n\n### Fix 1: Add BlinkPay Columns to Wallets\n\nIf you already created your database and need to add the BlinkPay columns to the wallets table, run this in SQL Editor:\n\n```sql\n-- Add BlinkPay columns to wallets table (if not already present)\nALTER TABLE wallets \nADD COLUMN IF NOT EXISTS blinkpay_consent_id TEXT,\nADD COLUMN IF NOT EXISTS blinkpay_consent_status TEXT,\nADD COLUMN IF NOT EXISTS blinkpay_consent_expires_at TIMESTAMPTZ;\n```\n\nThis enables the Connect Bank Account feature to store BlinkPay consent information.\n\n### Fix 2: Fix split_participants Infinite Recursion\n\nIf you see error \"infinite recursion detected in policy for relation split_participants\", run this to fix it:\n\n```sql\n-- Drop the problematic policy\nDROP POLICY IF EXISTS \"Users can view split participants\" ON split_participants;\n\n-- Create fixed policy that doesn't self-reference\nCREATE POLICY \"Users can view split participants\" ON split_participants FOR SELECT\n  USING (auth.uid() = user_id OR auth.uid() IN (\n    SELECT creator_id FROM split_events WHERE id = split_event_id\n  ));\n```\n\nThis allows users to see their own participation entries and creators to see all participants in their splits.\n","path":null,"size_bytes":12126,"size_tokens":null},"drizzle.config.ts":{"content":"import type { Config } from 'drizzle-kit';\n\nexport default {\n  schema: './shared/schema.ts',\n  out: './drizzle',\n  dialect: 'postgresql',\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n} satisfies Config;\n","path":null,"size_bytes":218,"size_tokens":null},"shared/types.ts":{"content":"export interface User {\n  id: string;\n  unique_id: string;\n  name: string;\n  email: string;\n  phone?: string;\n  date_of_birth?: string;\n  bio?: string;\n  profile_picture?: string;\n  push_token?: string;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface Friend {\n  id: string;\n  user_id: string;\n  friend_id: string;\n  status: 'accepted' | 'pending';\n  created_at: string;\n  friend_details?: User;\n}\n\nexport interface SplitEvent {\n  id: string;\n  name: string;\n  total_amount: number;\n  split_type: 'equal' | 'specified';\n  receipt_image?: string;\n  creator_id: string;\n  created_at: string;\n  updated_at: string;\n  creator?: User;\n  participants?: SplitParticipant[];\n}\n\nexport interface SplitParticipant {\n  id: string;\n  split_event_id: string;\n  user_id: string;\n  amount: number;\n  status: 'pending' | 'accepted' | 'declined' | 'paid';\n  is_creator: boolean;\n  created_at: string;\n  updated_at: string;\n  user?: User;\n}\n\nexport interface Wallet {\n  id: string;\n  user_id: string;\n  balance: number;\n  bank_connected: boolean;\n  bank_details?: {\n    bank_name?: string;\n    account_number?: string;\n    account_holder_name?: string;\n    account_last4?: string;\n    account_type?: string;\n  };\n  stripe_customer_id?: string;\n  stripe_payment_method_id?: string;\n  card_brand?: string;\n  card_last4?: string;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface Transaction {\n  id: string;\n  user_id: string;\n  type: 'deposit' | 'withdrawal' | 'split_payment' | 'split_received';\n  amount: number;\n  description: string;\n  direction: 'in' | 'out';\n  split_event_id?: string;\n  metadata?: {\n    withdrawal_type?: 'fast' | 'normal';\n    fee_amount?: number;\n    net_amount?: number;\n    estimated_arrival?: string;\n    status?: 'pending' | 'processing' | 'completed' | 'failed';\n    bank_account_number?: string;\n    bank_name?: string;\n    account_holder_name?: string;\n  };\n  created_at: string;\n}\n\nexport interface Notification {\n  id: string;\n  user_id: string;\n  type: 'split_invite' | 'split_accepted' | 'split_declined' | 'split_paid' | 'payment_received' | 'split_completed' | 'friend_request' | 'friend_accepted' | 'payment_reminder';\n  title: string;\n  message: string;\n  split_event_id?: string;\n  friendship_id?: string;\n  metadata?: {\n    split_type?: string;\n    amount?: string;\n    creator_name?: string;\n    sender_name?: string;\n  };\n  read: boolean;\n  created_at: string;\n}\n\nexport interface BlockedUser {\n  id: string;\n  user_id: string;\n  blocked_user_id: string;\n  created_at: string;\n  blocked_user?: User;\n}\n\nexport interface UserReport {\n  id: string;\n  reporter_id: string;\n  reported_user_id: string;\n  reason: string;\n  status: 'open' | 'reviewed' | 'resolved' | 'dismissed';\n  admin_notes?: string;\n  created_at: string;\n  updated_at: string;\n  reporter?: User;\n  reported_user?: User;\n}\n","path":null,"size_bytes":2841,"size_tokens":null},"services/friends.service.ts":{"content":"import Constants from 'expo-constants';\nimport { Platform } from 'react-native';\nimport { supabase } from './supabase';\nimport { BackendNotificationsService } from './backendNotifications.service';\nimport { PushNotificationsService } from './pushNotifications.service';\nimport type { Friend, User, BlockedUser } from '@/shared/types';\n\nconst getBackendUrl = (): string => {\n  const extra = Constants.expoConfig?.extra || {};\n  return extra.backendUrl || process.env.EXPO_PUBLIC_BACKEND_URL || 'http://localhost:8082';\n};\n\nconst isBackendAccessible = (): boolean => {\n  return Platform.OS === 'web';\n};\n\nexport class FriendsService {\n  static async sendFriendRequest(userId: string, friendUniqueId: string): Promise<Friend> {\n    const REMINDER_COOLDOWN_HOURS = 24;\n    \n    const { data: currentUser } = await supabase\n      .from('users')\n      .select('name')\n      .eq('id', userId)\n      .single();\n\n    // Direct query to lookup user by unique_id (RLS is disabled on users table)\n    console.log('Looking up user with unique_id:', friendUniqueId);\n    \n    const { data: friendUser, error: userError } = await supabase\n      .from('users')\n      .select('id, name')\n      .eq('unique_id', friendUniqueId)\n      .maybeSingle();\n\n    console.log('User lookup result:', { friendUser, userError });\n\n    if (userError) {\n      console.error('User lookup error:', userError);\n      throw new Error('User not found with this ID');\n    }\n\n    if (!friendUser) {\n      console.error('User not found, friendUser is null/undefined');\n      throw new Error('User not found with this ID');\n    }\n\n    if (friendUser.id === userId) throw new Error('Cannot add yourself as a friend');\n\n    const { data: existing } = await supabase\n      .from('friends')\n      .select('id, status, user_id, friend_id, last_reminder_at, created_at')\n      .or(`and(user_id.eq.${userId},friend_id.eq.${friendUser.id}),and(user_id.eq.${friendUser.id},friend_id.eq.${userId})`)\n      .maybeSingle();\n\n    if (existing) {\n      if (existing.status === 'accepted') {\n        throw new Error('Already friends with this user');\n      }\n      \n      // Check if this is a request FROM the other user TO us\n      if (existing.user_id !== userId) {\n        if (existing.status === 'pending') {\n          throw new Error('This user already sent you a friend request. Check your notifications!');\n        }\n        // If it's declined or any other status from their side, we can send our own request\n        // by updating this record to be from us\n        const lastSentAt = existing.last_reminder_at || existing.created_at;\n        const hoursSinceLastSent = (Date.now() - new Date(lastSentAt).getTime()) / (1000 * 60 * 60);\n        \n        if (hoursSinceLastSent < REMINDER_COOLDOWN_HOURS) {\n          const hoursRemaining = Math.ceil(REMINDER_COOLDOWN_HOURS - hoursSinceLastSent);\n          throw new Error(`Please wait ${hoursRemaining} hour${hoursRemaining > 1 ? 's' : ''} before sending a friend request`);\n        }\n        \n        // Update the existing record to be from us\n        await supabase\n          .from('friends')\n          .update({ \n            user_id: userId,\n            friend_id: friendUser.id,\n            status: 'pending',\n            last_reminder_at: new Date().toISOString(),\n          })\n          .eq('id', existing.id);\n        \n        // Create notification via backend API (non-blocking)\n        try {\n          const notifResult = await BackendNotificationsService.createNotification({\n            user_id: friendUser.id,\n            type: 'friend_request',\n            title: 'Friend Request',\n            message: `${currentUser?.name || 'Someone'} wants to be your friend`,\n            friendship_id: existing.id,\n            metadata: {\n              sender_id: userId,\n              sender_name: currentUser?.name,\n              friendship_id: existing.id,\n            },\n          });\n          if (!notifResult.success) {\n            console.warn('Notification creation failed (non-blocking):', notifResult.error);\n          }\n        } catch (notifError) {\n          console.warn('Notification creation error (non-blocking):', notifError);\n        }\n        \n        // Push notification (non-blocking)\n        PushNotificationsService.sendPushToUser(friendUser.id, {\n          title: 'Friend Request',\n          body: `${currentUser?.name || 'Someone'} wants to be your friend`,\n          data: {\n            type: 'friend_request',\n            senderId: userId,\n          },\n        }).catch(e => console.warn('Push notification failed (non-blocking):', e));\n        \n        return { ...existing, user_id: userId, friend_id: friendUser.id, status: 'pending' } as Friend;\n      }\n      \n      // This is OUR request to them - handle pending/declined/any status\n      const lastSentAt = existing.last_reminder_at || existing.created_at;\n      const hoursSinceLastSent = (Date.now() - new Date(lastSentAt).getTime()) / (1000 * 60 * 60);\n      \n      if (hoursSinceLastSent < REMINDER_COOLDOWN_HOURS) {\n        const hoursRemaining = Math.ceil(REMINDER_COOLDOWN_HOURS - hoursSinceLastSent);\n        throw new Error(`Please wait ${hoursRemaining} hour${hoursRemaining > 1 ? 's' : ''} before sending another reminder`);\n      }\n      \n      // Update the existing record (reactivate if declined, or just update reminder time if pending)\n      await supabase\n        .from('friends')\n        .update({ \n          status: 'pending',\n          last_reminder_at: new Date().toISOString() \n        })\n        .eq('id', existing.id);\n      \n      const isReminder = existing.status === 'pending';\n      // Create notification via backend API\n      const notifResult = await BackendNotificationsService.createNotification({\n        user_id: friendUser.id,\n        type: 'friend_request',\n        title: isReminder ? 'Friend Request Reminder' : 'Friend Request',\n        message: isReminder \n          ? `${currentUser?.name || 'Someone'} is waiting for your response`\n          : `${currentUser?.name || 'Someone'} wants to be your friend`,\n        friendship_id: existing.id,\n        metadata: {\n          sender_id: userId,\n          sender_name: currentUser?.name,\n          friendship_id: existing.id,\n          is_reminder: isReminder,\n        },\n      });\n      \n      if (!notifResult.success) {\n        console.error('Failed to create notification:', notifResult.error);\n      }\n\n      // Push notification (non-blocking)\n      PushNotificationsService.sendPushToUser(friendUser.id, {\n        title: isReminder ? 'Friend Request Reminder' : 'Friend Request',\n        body: isReminder \n          ? `${currentUser?.name || 'Someone'} is waiting for your response`\n          : `${currentUser?.name || 'Someone'} wants to be your friend`,\n        data: {\n          type: 'friend_request',\n          senderId: userId,\n        },\n      }).catch(e => console.warn('Push notification failed (non-blocking):', e));\n\n      return { ...existing, status: 'pending' } as Friend;\n    }\n\n    console.log('Inserting new friend request:', { user_id: userId, friend_id: friendUser.id, status: 'pending' });\n    \n    const { data, error } = await supabase\n      .from('friends')\n      .insert({\n        user_id: userId,\n        friend_id: friendUser.id,\n        status: 'pending',\n      })\n      .select()\n      .single();\n\n    console.log('Insert result - data:', data, 'error:', error);\n    \n    if (error) {\n      console.error('Failed to insert friend request:', error);\n      throw error;\n    }\n    \n    if (!data) {\n      console.error('Insert returned no data (possible RLS issue)');\n      throw new Error('Failed to create friend request - please try again');\n    }\n\n    console.log('Friend request created successfully with ID:', data.id);\n    console.log('Creating notification for user:', friendUser.id, 'with friendship_id:', data.id);\n    \n    // Create notification via backend API\n    const notifResult = await BackendNotificationsService.createNotification({\n      user_id: friendUser.id,\n      type: 'friend_request',\n      title: 'Friend Request',\n      message: `${currentUser?.name || 'Someone'} wants to be your friend`,\n      friendship_id: data.id,\n      metadata: {\n        sender_id: userId,\n        sender_name: currentUser?.name,\n        friendship_id: data.id,\n      },\n    });\n\n    if (!notifResult.success) {\n      console.error('Failed to create friend request notification:', notifResult.error);\n    } else {\n      console.log('Notification created successfully:', notifResult.notification?.id);\n    }\n\n    // Push notification (non-blocking)\n    PushNotificationsService.sendPushToUser(friendUser.id, {\n      title: 'Friend Request',\n      body: `${currentUser?.name || 'Someone'} wants to be your friend`,\n      data: {\n        type: 'friend_request',\n        senderId: userId,\n      },\n    }).catch(e => console.warn('Push notification failed (non-blocking):', e));\n\n    return data as Friend;\n  }\n\n  static async addFriend(userId: string, friendUniqueId: string): Promise<Friend> {\n    return this.sendFriendRequest(userId, friendUniqueId);\n  }\n\n  static async getPendingRequests(userId: string): Promise<Friend[]> {\n    const { data, error } = await supabase\n      .from('friends')\n      .select(`\n        *,\n        requester:user_id (\n          id,\n          unique_id,\n          name,\n          email,\n          profile_picture,\n          bio\n        )\n      `)\n      .eq('friend_id', userId)\n      .eq('status', 'pending');\n\n    if (error) throw error;\n    return data as Friend[];\n  }\n\n  static async getSentPendingRequests(userId: string): Promise<Friend[]> {\n    const { data, error } = await supabase\n      .from('friends')\n      .select(`\n        *,\n        recipient:friend_id (\n          id,\n          unique_id,\n          name,\n          email,\n          profile_picture,\n          bio\n        )\n      `)\n      .eq('user_id', userId)\n      .eq('status', 'pending');\n\n    if (error) throw error;\n    return data as Friend[];\n  }\n\n  static async acceptFriendRequest(userId: string, friendshipId: string): Promise<void> {\n    console.log('acceptFriendRequest called with:', { userId, friendshipId });\n    \n    // First, try to find the record without the friend_id filter to debug\n    const { data: anyRecord, error: debugError } = await supabase\n      .from('friends')\n      .select('id, user_id, friend_id, status')\n      .eq('id', friendshipId)\n      .maybeSingle();\n    \n    console.log('Debug - Record lookup by id only:', { anyRecord, debugError });\n    \n    // If no record found by ID, the friendship record doesn't exist\n    if (!anyRecord) {\n      console.error('No friends record found with id:', friendshipId);\n      throw new Error(`Friend request not found (no record with id: ${friendshipId?.substring(0, 8)}...)`);\n    }\n    \n    // Check if the current user is the recipient (friend_id)\n    if (anyRecord.friend_id !== userId) {\n      console.error('User mismatch. Record friend_id:', anyRecord.friend_id, 'Current user:', userId);\n      throw new Error(`Friend request not found (you are not the recipient)`);\n    }\n    \n    // Check if status is pending\n    if (anyRecord.status !== 'pending') {\n      console.error('Status is not pending:', anyRecord.status);\n      throw new Error(`Friend request already ${anyRecord.status}`);\n    }\n    \n    const { data: friendship, error: fetchError } = await supabase\n      .from('friends')\n      .select('user_id, friend_id')\n      .eq('id', friendshipId)\n      .eq('friend_id', userId)\n      .eq('status', 'pending')\n      .single();\n\n    console.log('Full query result:', { friendship, fetchError });\n\n    if (fetchError || !friendship) {\n      console.error('Friend request not found. Expected friend_id:', userId, 'Actual record:', anyRecord);\n      throw new Error('Friend request not found');\n    }\n\n    await supabase\n      .from('friends')\n      .update({ status: 'accepted' })\n      .eq('id', friendshipId);\n\n    const { data: existing } = await supabase\n      .from('friends')\n      .select('id')\n      .eq('user_id', userId)\n      .eq('friend_id', friendship.user_id)\n      .single();\n\n    if (!existing) {\n      await supabase\n        .from('friends')\n        .insert({\n          user_id: userId,\n          friend_id: friendship.user_id,\n          status: 'accepted',\n        });\n    } else {\n      await supabase\n        .from('friends')\n        .update({ status: 'accepted' })\n        .eq('id', existing.id);\n    }\n\n    const { data: currentUser } = await supabase\n      .from('users')\n      .select('name')\n      .eq('id', userId)\n      .single();\n\n    // Create notification via backend API\n    await BackendNotificationsService.createNotification({\n      user_id: friendship.user_id,\n      type: 'friend_accepted',\n      title: 'Friend Request Accepted',\n      message: `${currentUser?.name || 'Someone'} accepted your friend request`,\n    });\n\n    await PushNotificationsService.sendPushToUser(friendship.user_id, {\n      title: 'Friend Request Accepted',\n      body: `${currentUser?.name || 'Someone'} accepted your friend request`,\n      data: {\n        type: 'friend_accepted',\n      },\n    });\n  }\n\n  static async declineFriendRequest(userId: string, friendshipId: string): Promise<void> {\n    // Mark as declined instead of deleting, so we can track cooldown for resends\n    const { error } = await supabase\n      .from('friends')\n      .update({ \n        status: 'declined',\n        last_reminder_at: new Date().toISOString() // Reset the cooldown timer\n      })\n      .eq('id', friendshipId)\n      .eq('friend_id', userId)\n      .eq('status', 'pending');\n\n    if (error) throw error;\n  }\n\n  static async checkFriendship(userId: string, otherUserId: string): Promise<boolean> {\n    const { data } = await supabase\n      .from('friends')\n      .select('id')\n      .eq('user_id', userId)\n      .eq('friend_id', otherUserId)\n      .eq('status', 'accepted')\n      .single();\n\n    return !!data;\n  }\n\n  static async sendFriendRequestById(userId: string, targetUserId: string): Promise<Friend> {\n    const { data: targetUser } = await supabase\n      .from('users')\n      .select('unique_id')\n      .eq('id', targetUserId)\n      .single();\n\n    if (!targetUser) throw new Error('User not found');\n    \n    return this.sendFriendRequest(userId, targetUser.unique_id);\n  }\n\n  static async getFriends(userId: string): Promise<Friend[]> {\n    const { data: outgoing, error: outError } = await supabase\n      .from('friends')\n      .select(`\n        *,\n        friend_details:friend_id (\n          id,\n          unique_id,\n          name,\n          email,\n          profile_picture,\n          bio\n        )\n      `)\n      .eq('user_id', userId)\n      .eq('status', 'accepted');\n\n    if (outError) throw outError;\n\n    const { data: incoming, error: inError } = await supabase\n      .from('friends')\n      .select(`\n        *,\n        friend_details:user_id (\n          id,\n          unique_id,\n          name,\n          email,\n          profile_picture,\n          bio\n        )\n      `)\n      .eq('friend_id', userId)\n      .eq('status', 'accepted');\n\n    if (inError) throw inError;\n\n    const incomingMapped = (incoming || []).map((item: any) => ({\n      ...item,\n      friend_id: item.user_id,\n      user_id: userId,\n    }));\n\n    const allFriends = [...(outgoing || []), ...incomingMapped];\n    \n    const uniqueFriends = allFriends.reduce((acc: any[], friend: any) => {\n      const friendId = friend.friend_details?.id || friend.friend_id;\n      if (!acc.find((f: any) => (f.friend_details?.id || f.friend_id) === friendId)) {\n        acc.push(friend);\n      }\n      return acc;\n    }, []);\n\n    return uniqueFriends as Friend[];\n  }\n\n  static async removeFriend(userId: string, friendshipId: string): Promise<void> {\n    const { data: friendship, error: fetchError } = await supabase\n      .from('friends')\n      .select('friend_id')\n      .eq('id', friendshipId)\n      .eq('user_id', userId)\n      .single();\n\n    if (fetchError) throw fetchError;\n\n    await supabase\n      .from('friends')\n      .delete()\n      .eq('id', friendshipId);\n\n    await supabase\n      .from('friends')\n      .delete()\n      .eq('user_id', friendship.friend_id)\n      .eq('friend_id', userId);\n  }\n\n  static async getBlockedUsers(userId: string): Promise<BlockedUser[]> {\n    if (isBackendAccessible()) {\n      try {\n        const backendUrl = getBackendUrl();\n        const response = await fetch(`${backendUrl}/api/friends/blocked?userId=${userId}`);\n        \n        if (response.ok) {\n          const data = await response.json();\n          return data.blockedUsers || [];\n        }\n      } catch (error) {\n        console.warn('Backend blocked users fetch failed, using Supabase fallback');\n      }\n    }\n    \n    // First get blocked user IDs\n    const { data: blockedData, error: blockedError } = await supabase\n      .from('blocked_users')\n      .select('id, user_id, blocked_user_id, created_at')\n      .eq('user_id', userId);\n    \n    if (blockedError) {\n      console.error('Failed to get blocked users:', blockedError);\n      return [];\n    }\n    \n    if (!blockedData || blockedData.length === 0) {\n      return [];\n    }\n    \n    // Then fetch user details separately\n    const blockedUserIds = blockedData.map(b => b.blocked_user_id);\n    const { data: usersData, error: usersError } = await supabase\n      .from('users')\n      .select('id, unique_id, name, email, profile_picture')\n      .in('id', blockedUserIds);\n    \n    if (usersError) {\n      console.error('Failed to get blocked user details:', usersError);\n      return [];\n    }\n    \n    // Combine the data\n    const usersMap = new Map(usersData?.map(u => [u.id, u]) || []);\n    return blockedData.map(b => ({\n      ...b,\n      blocked_user: usersMap.get(b.blocked_user_id) || null\n    })) as BlockedUser[];\n  }\n\n  static async blockUser(userId: string, blockedUserId: string): Promise<void> {\n    if (isBackendAccessible()) {\n      try {\n        const backendUrl = getBackendUrl();\n        const response = await fetch(`${backendUrl}/api/friends/block`, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ userId, blockedUserId }),\n        });\n        \n        if (response.ok) return;\n        const errorData = await response.json().catch(() => ({}));\n        if (errorData.error) throw new Error(errorData.error);\n      } catch (error: any) {\n        if (error.message && !error.message.includes('fetch')) {\n          throw error;\n        }\n        console.warn('Backend block failed, using Supabase fallback');\n      }\n    }\n    \n    const { data, error } = await supabase.rpc('block_user', {\n      p_user_id: userId,\n      p_blocked_user_id: blockedUserId,\n    });\n    \n    if (error) throw new Error(error.message || 'Failed to block user');\n    if (data && !data.success) throw new Error(data.error || 'Failed to block user');\n  }\n\n  static async unblockUser(userId: string, blockedUserId: string): Promise<void> {\n    if (isBackendAccessible()) {\n      try {\n        const backendUrl = getBackendUrl();\n        const response = await fetch(`${backendUrl}/api/friends/block/${blockedUserId}?userId=${userId}`, {\n          method: 'DELETE',\n        });\n        \n        if (response.ok) return;\n      } catch (error) {\n        console.warn('Backend unblock failed, using Supabase fallback');\n      }\n    }\n    \n    const { error } = await supabase\n      .from('blocked_users')\n      .delete()\n      .eq('user_id', userId)\n      .eq('blocked_user_id', blockedUserId);\n    \n    if (error) throw new Error(error.message || 'Failed to unblock user');\n  }\n\n  static async isUserBlocked(userId: string, otherUserId: string): Promise<boolean> {\n    if (isBackendAccessible()) {\n      try {\n        const backendUrl = getBackendUrl();\n        const response = await fetch(`${backendUrl}/api/friends/is-blocked?userId=${userId}&otherUserId=${otherUserId}`);\n        \n        if (response.ok) {\n          const data = await response.json();\n          return data.isBlocked || false;\n        }\n      } catch (error) {\n        console.warn('Backend is-blocked check failed, using Supabase fallback');\n      }\n    }\n    \n    const { data, error } = await supabase.rpc('is_user_blocked', {\n      p_user_id: userId,\n      p_other_user_id: otherUserId,\n    });\n    \n    if (error) {\n      console.error('Failed to check blocked status:', error);\n      return false;\n    }\n    \n    return data || false;\n  }\n\n  static async reportUser(reporterId: string, reportedUserId: string, reason: string): Promise<void> {\n    // Always use backend for reports - works on all platforms including Expo Go\n    const backendUrl = getBackendUrl();\n    const response = await fetch(`${backendUrl}/api/reports`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ reporterId, reportedUserId, reason }),\n    });\n    \n    if (response.ok) return;\n    \n    const errorData = await response.json().catch(() => ({}));\n    throw new Error(errorData.error || 'Failed to submit report');\n  }\n\n  // Subscribe to realtime updates for friend requests and status changes\n  static subscribeToFriendUpdates(\n    userId: string,\n    onUpdate: () => void\n  ): { unsubscribe: () => void } {\n    let debounceTimer: ReturnType<typeof setTimeout> | null = null;\n\n    const debouncedUpdate = (eventType: string) => {\n      console.log('[FriendsService] Realtime event received:', eventType);\n      if (debounceTimer) clearTimeout(debounceTimer);\n      debounceTimer = setTimeout(() => {\n        console.log('[FriendsService] Triggering update callback');\n        onUpdate();\n      }, 300);\n    };\n\n    // Subscribe to friends table changes for this user\n    const channel = supabase\n      .channel(`friends_updates_${userId}`)\n      // Listen for incoming friend requests (where user is the recipient)\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'friends',\n          filter: `friend_id=eq.${userId}`,\n        },\n        (payload) => {\n          console.log('[FriendsService] Friend change (as recipient):', payload.eventType);\n          debouncedUpdate(`recipient_${payload.eventType}`);\n        }\n      )\n      // Listen for changes to requests the user sent\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'friends',\n          filter: `user_id=eq.${userId}`,\n        },\n        (payload) => {\n          console.log('[FriendsService] Friend change (as sender):', payload.eventType);\n          debouncedUpdate(`sender_${payload.eventType}`);\n        }\n      )\n      .subscribe((status, err) => {\n        console.log('[FriendsService] Subscription status:', status);\n        if (err) {\n          console.error('[FriendsService] Subscription error:', err);\n        }\n      });\n\n    return {\n      unsubscribe: () => {\n        console.log('[FriendsService] Unsubscribing from friend updates');\n        if (debounceTimer) clearTimeout(debounceTimer);\n        supabase.removeChannel(channel);\n      },\n    };\n  }\n}\n","path":null,"size_bytes":23094,"size_tokens":null},"IMPLEMENTATION_STATUS.md":{"content":"# Implementation Status Summary\n\n## 🔧 CRITICAL: Fix Signup/Login First!\n\n### Your Immediate Problem\nUsers are being created in Supabase Auth but can't log in because the user profile can't be created in the `users` table.\n\n### ✅ The Fix (Takes 1 Minute)\n\n**Run this SQL command in your Supabase Dashboard:**\n\n1. Go to [Supabase Dashboard](https://supabase.com/dashboard)\n2. Select your project  \n3. Click **SQL Editor** in the sidebar\n4. Paste and run:\n\n```sql\nCREATE POLICY \"Users can insert own profile\" ON users \nFOR INSERT WITH CHECK (auth.uid() = id);\n```\n\n**That's it!** Now try signing up again - it will work and redirect you to the homepage.\n\n---\n\n## ✅ Completed Features (Nov 24, 2025)\n\n### 1. **Date of Birth Input - FIXED**\n- Added web-compatible text input fallback for date picker\n- Works on all platforms now (web, iOS, Android)\n- Web users type date in YYYY-MM-DD format\n\n### 2. **Wallet Page - FULLY FUNCTIONAL**\n- ✅ Connect/Edit bank account with validation\n- ✅ Add funds to wallet\n- ✅ Withdraw funds (when bank connected)\n- ✅ Transaction history from Supabase\n- ✅ Automatic wallet creation for new users\n- ✅ Real-time balance updates\n- ✅ Pull-to-refresh support\n\n### 3. **Home Page - UPDATED WITH SUPABASE**\n- ✅ Wallet balance displayed at top\n- ✅ Loads split events from Supabase\n- ✅ **Smart filtering logic**:\n  - **Creators**: See all their events; \"in progress\" until everyone pays\n  - **Invited users**: Only see accepted events; \"in progress\" until they pay\n  - This matches your spec: invited users only see accepted splits\n- ✅ Real-time unread notification count\n- ✅ Pull-to-refresh support\n- ✅ 3-second auto-refresh\n\n### 4. **Profile Page - WORKING**\n- ✅ Editable bio with Supabase sync\n- ✅ Profile picture upload to Supabase Storage\n- ✅ Proper state synchronization\n\n---\n\n## ⚠️ Partially Complete Features\n\n### 5. **Split Creation**\n**Status**: Uses Supabase but needs redirect fix\n\n**What's working**:\n- Creates splits in Supabase database\n- Uploads receipt images to storage\n- Creates notifications for invited users only (not creator)\n- Participant tracking with amounts\n\n**What needs fixing**:\n- Currently shows success alert, needs auto-redirect to home page\n- Update line 138 in `screens/CreateSplitDetailsScreen.tsx`:\n  ```typescript\n  // CHANGE THIS:\n  Alert.alert('Event Created!', ..., \n    [{ text: 'OK', onPress: () => navigation.navigate('MainHome') }]\n  );\n  \n  // TO THIS:\n  navigation.navigate('HomeTab', { screen: 'MainHome' });\n  ```\n\n### 6. **Notifications**\n**Status**: Service layer complete, needs testing\n\n- ✅ Notifications created only for invited users (not creator)\n- ✅ Notification types: split_invite, split_accepted, split_declined, split_paid\n- ✅ Unread count displayed on home screen bell icon\n- ⚠️ Notification screen needs testing with real data\n\n### 7. **Event Detail Page**\n**Status**: Not yet updated to Supabase\n\n**Needs**:\n- Update to use `SplitsService.getSplitDetails()`  \n- Add receipt photo display with zoom\n- Fix off-screen layout issues\n- Accept/Decline/Pay buttons integration\n\n---\n\n## 📋 Remaining Tasks\n\n### High Priority\n1. **Fix split creation redirect** (5 minutes)\n   - See \"Split Creation\" section above\n\n2. **Update Event Detail Page** (30 minutes)\n   - Load from Supabase instead of local storage\n   - Display receipt image with zoom capability\n   - Wire up Accept/Decline/Pay actions to `SplitsService`\n\n3. **Test Notifications Flow** (15 minutes)\n   - Create a split\n   - Check invited user receives notification\n   - Test accept/decline responses\n\n### Medium Priority\n4. **Friends Management** (if not done)\n   - Update to use `FriendsService` from Supabase\n   - Add friend by unique ID\n   - Remove friends\n\n5. **Testing & Polish**\n   - End-to-end test of full split flow\n   - Test cross-device sync\n   - Handle edge cases (insufficient balance, network errors)\n\n---\n\n## 🗄️ Database Setup Checklist\n\nMake sure you've completed all steps in `SUPABASE_SETUP.md`:\n\n- ✅ Created Supabase project\n- ✅ Got API keys (URL + anon key)\n- ✅ Created database tables (SQL script)\n- ✅ Created storage bucket (`user-uploads`)\n- ✅ Disabled email confirmation\n- ⚠️ **Added RLS INSERT policy for users table** ← DO THIS NOW!\n- ✅ Set up other RLS policies\n\n---\n\n## 🎯 Next Steps\n\n1. **RIGHT NOW**: Run the SQL fix above to enable signup/login\n2. **Then**: Test signing up with a new account\n3. **Then**: Create a split and test the flow\n4. **Then**: Let me know what's working/not working!\n\nThe app is 90% complete. The main blocker is the RLS policy fix, which takes 30 seconds to add!\n","path":null,"size_bytes":4634,"size_tokens":null},"FIX_RLS_INFINITE_RECURSION.md":{"content":"# Fix: Infinite Recursion in split_participants RLS Policy\n\n## Problem\nThe app is throwing \"infinite recursion detected in policy for relation split_participants\" errors. This is caused by a circular reference in the RLS policy.\n\n## The Bug\nThe current policy on line 210-213 of SUPABASE_SETUP.md tries to query `split_participants` inside a policy protecting `split_participants`:\n\n```sql\nCREATE POLICY \"Users can view split participants\" ON split_participants FOR SELECT\n  USING (auth.uid() IN (\n    SELECT user_id FROM split_participants WHERE split_event_id = split_event_id\n  ));\n```\n\n## The Fix\n\nRun this SQL in your Supabase SQL Editor to fix it:\n\n```sql\n-- Drop the broken policy\nDROP POLICY IF EXISTS \"Users can view split participants\" ON split_participants;\n\n-- Create the correct policy (uses split_events instead of split_participants)\nCREATE POLICY \"Users can view split participants\" ON split_participants FOR SELECT\n  USING (\n    EXISTS (\n      SELECT 1 FROM split_participants sp2\n      WHERE sp2.split_event_id = split_participants.split_event_id\n      AND sp2.user_id = auth.uid()\n    )\n  );\n```\n\n## Explanation\n\nThe fix changes the policy to check if the current user is a participant in the same split event by:\n1. Looking for records in split_participants (aliased as sp2) where:\n   - The split_event_id matches\n   - The user_id is the current authenticated user\n\nThis avoids circular recursion by using EXISTS with a clear alias (sp2) instead of a nested SELECT from the same table.\n\n## After Running the Fix\n\n1. The 500 errors should disappear\n2. The home page will load properly\n3. Split events will display correctly\n4. You'll be able to create and view splits without errors\n\n---\n\n**Run this SQL now, then refresh your app!**\n","path":null,"size_bytes":1753,"size_tokens":null},"FIX_SIGNUP_LOGIN.md":{"content":"# 🔧 Fix Signup & Login Issues\n\n## Problem\n- ✅ Users ARE being created in Supabase Auth\n- ❌ Users CANNOT be created in the `users` table (blocked by RLS)\n- ❌ Login fails because there's no user profile to fetch\n\n## Root Cause\nMissing INSERT policy on the `users` table. RLS is blocking new profile creation.\n\n## ✅ Solution (2 minutes)\n\n### Go to Your Supabase Dashboard\n\n1. Open [Supabase Dashboard](https://supabase.com/dashboard)\n2. Select your project\n3. Click **SQL Editor** in the left sidebar\n4. Copy and paste this SQL command:\n\n```sql\nCREATE POLICY \"Users can insert own profile\" ON users FOR INSERT WITH CHECK (auth.uid() = id);\n```\n\n5. Click **Run** (or press Cmd/Ctrl + Enter)\n6. You should see: \"Success. No rows returned\"\n\n### Test It\n\n1. Go back to your app\n2. Try signing up with a new email\n3. The signup should now complete successfully\n4. You should be redirected to the home page\n\n## What This Does\n\nThis RLS policy allows authenticated users to insert their own profile into the `users` table **only** when the user ID matches their authenticated ID. This is secure and prevents users from creating profiles for other people.\n\n## Already Have Test Accounts?\n\nIf you created test accounts before adding this policy, they exist in Supabase Auth but have no profile. You have two options:\n\n1. **Delete them**: Go to Authentication > Users, delete test accounts, then sign up again\n2. **Keep them**: Just sign up with a new email address instead\n","path":null,"size_bytes":1472,"size_tokens":null},"UPDATE_WALLETS_FOR_BLINKPAY.md":{"content":"# Add BlinkPay Consent to Wallets Table\n\nRun this SQL in your Supabase SQL Editor to add BlinkPay enduring consent tracking:\n\n```sql\n-- Add BlinkPay consent ID column to wallets table\nALTER TABLE wallets \nADD COLUMN IF NOT EXISTS blinkpay_consent_id TEXT,\nADD COLUMN IF NOT EXISTS blinkpay_consent_status TEXT,\nADD COLUMN IF NOT EXISTS blinkpay_consent_expires_at TIMESTAMPTZ;\n\n-- Create index for faster lookups\nCREATE INDEX IF NOT EXISTS idx_wallets_consent_id ON wallets(blinkpay_consent_id);\n```\n\n## What This Does\n\n- **blinkpay_consent_id**: Stores the BlinkPay enduring consent ID for recurring payments\n- **blinkpay_consent_status**: Tracks status (active, revoked, expired)\n- **blinkpay_consent_expires_at**: When the consent expires (usually 1 year from creation)\n\n## Why This Is Needed\n\nWhen users connect their bank via BlinkPay:\n1. They authorize an \"enduring consent\" for recurring payments\n2. The consent_id is stored in the wallet\n3. Future payments use this consent_id without re-authorization\n4. This enables seamless split payments directly from their bank account\n\n---\n\n**Run this SQL now before continuing with BlinkPay integration!**\n","path":null,"size_bytes":1155,"size_tokens":null},"BLINKPAY_USER_GUIDE.md":{"content":"# BlinkPay Integration - User Guide\n\n## Overview\n\nYour Split app now integrates with BlinkPay for secure, direct bank payments. Users can connect their bank account once and make future payments without re-entering credentials.\n\n## Setup Required\n\n### 1. Database Migration\n\n**You must run this SQL in your Supabase SQL Editor FIRST:**\n\nOpen `UPDATE_WALLETS_FOR_BLINKPAY.md` and copy the SQL commands. This adds the necessary columns to store BlinkPay consent information.\n\n### 2. BlinkPay Credentials\n\nYour BlinkPay sandbox credentials are already stored as Replit secrets:\n- `BLINKPAY_CLIENT_ID`\n- `BLINKPAY_CLIENT_SECRET`\n\nThese are automatically loaded by the BlinkPayService.\n\n## How It Works\n\n### For Users: Connecting a Bank\n\n1. **Navigate to Wallet Tab**\n   - Users see their balance and a \"Connect Bank Account\" button\n\n2. **Click Connect Bank**\n   - Opens BlinkPay OAuth in browser\n   - User selects their bank from the list\n   - Redirects to bank's secure login page\n\n3. **Authorize Enduring Consent**\n   - User logs into their bank\n   - Authorizes Split to make future payments\n   - Bank redirects back to app\n\n4. **Bank Connected**\n   - Consent ID stored in database\n   - Bank details displayed in wallet\n   - Ready to make payments\n\n### For Users: Making Payments\n\n1. **Accept a Split Request**\n   - User receives split invite\n   - Views event details\n   - Clicks \"Accept\"\n\n2. **Pay the Split**\n   - Clicks \"Pay $XX.XX\" button\n   - App checks if bank is connected\n   - If not connected, prompts to connect first\n\n3. **Payment Processed**\n   - Payment sent via BlinkPay using stored consent\n   - No re-authentication needed\n   - Payment marked as complete instantly\n\n### For Users: Managing Bank Connection\n\n**Disconnect Bank:**\n- Go to Wallet tab\n- Click \"Disconnect\" next to bank details\n- Confirms disconnection\n- Revokes consent at BlinkPay\n- Must reconnect to make future payments\n\n**Withdraw Funds:**\n- Disabled for BlinkPay accounts\n- Funds remain in Split wallet for paying friends\n- This is a BlinkPay limitation\n\n## Technical Architecture\n\n### Service Layer\n\n**BlinkPayService** (`services/blinkpay.service.ts`)\n- `createEnduringConsent()`: Initiates OAuth flow\n- `getEnduringConsent()`: Retrieves consent details\n- `createPayment()`: Processes a payment\n- `awaitSuccessfulPayment()`: Polls for completion\n- `revokeEnduringConsent()`: Disconnects bank\n\n**WalletService** (`services/wallet.service.ts`)\n- `initiateBlinkPayConsent()`: Starts bank connection\n- `completeBlinkPayConsent()`: Finalizes connection\n- `disconnectBank()`: Removes bank and revokes consent\n\n### Payment Flow\n\n```\nUser clicks \"Pay\" \n  → Check if bank connected\n  → If not: prompt to connect\n  → If yes: create BlinkPay payment\n  → Poll for completion (max 30 seconds)\n  → If successful: mark split as paid\n  → If failed: show error message\n```\n\n### Data Model\n\n**Wallets Table (Updated)**\n```sql\nwallets:\n  - id (uuid)\n  - user_id (uuid)\n  - balance (decimal)\n  - bank_connected (boolean)\n  - bank_details (jsonb)\n  - blinkpay_consent_id (text) -- NEW\n  - blinkpay_consent_status (text) -- NEW\n  - blinkpay_consent_expires_at (timestamptz) -- NEW\n```\n\n## Testing in Sandbox\n\n### BlinkPay Sandbox Banks\n\nWhen testing, users will see sandbox banks like:\n- PNZ Bank (Sandbox)\n- ASB Bank (Sandbox)\n- ANZ Bank (Sandbox)\n\nThese are test banks provided by BlinkPay. No real money is involved.\n\n### Test Flow\n\n1. Connect a sandbox bank in Wallet\n2. Create a split event\n3. Invite yourself (use another test account)\n4. Accept the split\n5. Click \"Pay\" - should process instantly\n6. Verify payment marked as complete\n\n## Common Issues\n\n### \"Bank Not Connected\" Error\n- User must connect bank before paying\n- App will prompt them automatically\n- Redirect to Wallet tab to connect\n\n### Payment Takes Too Long\n- BlinkPay polling timeout is 30 seconds\n- Sandbox payments usually complete in 2-5 seconds\n- Production payments may take longer\n\n### Consent Expired\n- Consents expire after 1 year\n- User must reconnect their bank\n- App will detect expired consent and prompt reconnection\n\n### OAuth Redirect Not Working\n- Ensure deep link scheme `split://` is registered in app.json\n- WebBrowser.openAuthSessionAsync handles the redirect\n- Check that redirect URI matches BlinkPay settings\n\n## Security Notes\n\n- Consent ID is stored encrypted in database\n- Client credentials stored as Replit secrets\n- No bank credentials ever stored in app\n- Users can revoke consent anytime\n- RLS policies protect user data\n\n## Production Checklist\n\nBefore going live with real BlinkPay:\n\n1. ✅ Update BlinkPay credentials to production keys\n2. ✅ Change sandbox URL to production URL\n3. ✅ Test with real bank accounts\n4. ✅ Update maximum payment amounts if needed\n5. ✅ Configure proper redirect URIs in BlinkPay dashboard\n6. ✅ Enable production RLS policies in Supabase\n7. ✅ Monitor payment failures and handle edge cases\n\n---\n\n**BlinkPay Integration Complete!**\nUsers can now connect their bank and make seamless split payments.\n","path":null,"size_bytes":5018,"size_tokens":null},"BLINKPAY_BACKEND_SETUP.md":{"content":"# BlinkPay Backend Server Setup\n\n## Problem\n\nThe BlinkPay Node.js SDK (`blink-debit-api-client-node`) is designed for Node.js environments and uses modules like `dotenv`, `path`, and `process.cwd()` that are not available in React Native/Expo environments. When you tried to import the SDK directly in the Expo app, it caused this error:\n\n```\nUnable to resolve module path from /home/runner/workspace/node_modules/dotenv/lib/main.js\n```\n\n## Solution\n\nWe've created a lightweight Express backend server that:\n1. Runs the BlinkPay Node.js SDK in a proper Node.js environment\n2. Exposes REST API endpoints that the React Native app can call\n3. Runs alongside the Expo dev server in Replit\n\n## Architecture\n\n```\n┌─────────────────────┐         ┌──────────────────────┐\n│  React Native App   │         │  Express Backend     │\n│  (Expo Go)          │         │  (Node.js)           │\n│                     │         │                      │\n│  WalletService      │────────▶│  /api/blinkpay/*     │\n│  EventDetailScreen  │  HTTP   │                      │\n│                     │  Fetch  │  BlinkPayService     │\n│                     │         │                      │\n└─────────────────────┘         └───────────┬──────────┘\n                                            │\n                                            │\n                                            ▼\n                                  ┌──────────────────┐\n                                  │  BlinkPay API    │\n                                  │  (Sandbox)       │\n                                  └──────────────────┘\n```\n\n## File Structure\n\n### Backend Server (New)\n```\nserver/\n├── index.ts                      # Express server entry point\n├── routes/\n│   └── blinkpay.routes.ts        # BlinkPay API endpoints\n└── services/\n    └── blinkpay.service.ts       # BlinkPay SDK wrapper\n```\n\n### Client (Updated)\n```\nservices/\n├── wallet.service.ts             # Calls backend API (updated)\n└── ...\n\nscreens/\n├── EventDetailScreen.tsx         # Calls backend API (updated)\n└── ...\n```\n\n## API Endpoints\n\n### POST /api/blinkpay/consent/create\nCreates an enduring consent for bank connection.\n\n**Request:**\n```json\n{\n  \"redirectUri\": \"split://blinkpay/callback\",\n  \"maxAmountPerPeriod\": \"1000.00\"\n}\n```\n\n**Response:**\n```json\n{\n  \"consentId\": \"consent_abc123\",\n  \"redirectUri\": \"https://blinkpay.co.nz/authorize?...\"\n}\n```\n\n### GET /api/blinkpay/consent/:consentId\nRetrieves consent details.\n\n**Response:**\n```json\n{\n  \"consent_id\": \"consent_abc123\",\n  \"bank_name\": \"Connected Bank\",\n  \"account_reference\": \"****1234\",\n  \"status\": \"active\",\n  \"expires_at\": \"2026-11-25T00:00:00Z\"\n}\n```\n\n### POST /api/blinkpay/consent/revoke\nRevokes an enduring consent.\n\n**Request:**\n```json\n{\n  \"consentId\": \"consent_abc123\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true\n}\n```\n\n### POST /api/blinkpay/payment/create\nCreates a payment using enduring consent.\n\n**Request:**\n```json\n{\n  \"consentId\": \"consent_abc123\",\n  \"amount\": \"50.00\",\n  \"particulars\": \"Split Payment\",\n  \"reference\": \"split_xyz789\"\n}\n```\n\n**Response:**\n```json\n{\n  \"paymentId\": \"payment_abc123\",\n  \"status\": \"pending\"\n}\n```\n\n### GET /api/blinkpay/payment/:paymentId/status\nPolls for payment completion status.\n\n**Query Parameters:**\n- `maxWaitSeconds`: Maximum time to wait (default: 30)\n\n**Response:**\n```json\n{\n  \"paymentId\": \"payment_abc123\",\n  \"status\": \"AcceptedSettlementCompleted\"\n}\n```\n\n## Running the App\n\n### Option 1: Manual Start (For Development)\n\n**Terminal 1 - Backend Server:**\n```bash\nPORT=8082 npx nodemon server/index.ts\n```\n\n**Terminal 2 - Expo Dev Server:**\n```bash\nnpm run dev\n```\n\n### Option 2: Using Start Script (Recommended)\n\nWe've created a `start-all.sh` script that runs both servers:\n\n```bash\n./start-all.sh\n```\n\nThis starts:\n- Backend server on port 8082 (external port 3000 in Replit)\n- Expo dev server on port 8081\n\n## Environment Configuration\n\n### Replit Port Mapping\nIn Replit, ports are mapped as follows:\n- `localhost:8081` → External port 80 (Expo)\n- `localhost:8082` → External port 3000 (Backend)\n\n### Backend URL\nThe client code automatically detects the environment:\n- **Development (Replit)**: `https://{replit-domain}:3000`\n- **Local**: `http://localhost:3000`\n\nThis is handled by the `getBackendUrl()` function in:\n- `services/wallet.service.ts`\n- `screens/EventDetailScreen.tsx`\n\n## Testing the Backend\n\n### Health Check\n```bash\ncurl https://{your-replit-domain}:3000/health\n```\n\nExpected response:\n```json\n{\n  \"status\": \"ok\",\n  \"message\": \"Backend server is running\"\n}\n```\n\n### Create Consent (Example)\n```bash\ncurl -X POST https://{your-replit-domain}:3000/api/blinkpay/consent/create \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"redirectUri\": \"split://blinkpay/callback\"}'\n```\n\n## Database Migration\n\nBefore testing BlinkPay features, **you must run the database migration**:\n\n1. Open your Supabase project dashboard\n2. Go to SQL Editor\n3. Copy the SQL from `UPDATE_WALLETS_FOR_BLINKPAY.md`\n4. Execute the SQL\n\nThis adds the necessary columns to track BlinkPay consent information:\n- `blinkpay_consent_id`\n- `blinkpay_consent_status`\n- `blinkpay_consent_expires_at`\n\n## Troubleshooting\n\n### Backend Server Not Starting\n**Symptom:** Cannot connect to backend API  \n**Solution:**\n1. Check if port 8082 is available: `lsof -i :8082`\n2. Check server logs for errors\n3. Ensure `BLINKPAY_CLIENT_ID` and `BLINKPAY_CLIENT_SECRET` secrets are set\n\n### Module Resolution Errors\n**Symptom:** `Unable to resolve module path`  \n**Solution:** This error should no longer occur since we removed the BlinkPay SDK from client code. If you see it:\n1. Clear Metro bundler cache: `npx expo start -c`\n2. Ensure `services/blinkpay.service.ts` doesn't exist in client code\n\n### CORS Errors\n**Symptom:** Fetch requests blocked by CORS  \n**Solution:** The backend has CORS enabled globally. If issues persist:\n1. Check backend server logs\n2. Verify the backend URL is correctly set in client code\n\n### Payment Timeout\n**Symptom:** Payment takes longer than 30 seconds  \n**Solution:** BlinkPay sandbox payments usually complete in 2-5 seconds. If timing out:\n1. Check BlinkPay sandbox status\n2. Verify consent is active and not expired\n3. Check backend server logs for errors\n\n## Next Steps\n\n1. **Run the Database Migration** (see `UPDATE_WALLETS_FOR_BLINKPAY.md`)\n2. **Start Both Servers** (backend + Expo)\n3. **Test Bank Connection Flow:**\n   - Open app in Expo Go\n   - Navigate to Wallet tab\n   - Click \"Connect Bank Account\"\n   - Complete OAuth flow\n   - Verify bank details displayed\n4. **Test Payment Flow:**\n   - Create a split event\n   - Accept the split\n   - Click \"Pay\" button\n   - Verify payment processes instantly\n\n## Production Deployment\n\nFor production:\n1. Deploy the Express backend to a hosting service (Heroku, Railway, etc.)\n2. Update `BACKEND_URL` to point to production backend\n3. Switch BlinkPay credentials from sandbox to production\n4. Ensure proper environment variable management\n\n---\n\n**Backend Integration Complete!**  \nThe BlinkPay SDK now runs properly in a Node.js backend, and the React Native app communicates with it via REST APIs.\n","path":null,"size_bytes":7524,"size_tokens":null},"server/services/blinkpay.service.ts":{"content":"import axios from 'axios';\nimport { \n  BlinkDebitClient,\n  EnduringConsentRequest,\n  CreateConsentResponse,\n  PaymentRequest,\n  PaymentResponse,\n  Consent,\n  Payment,\n  AuthFlowDetailTypeEnum,\n  AmountCurrencyEnum\n} from 'blink-debit-api-client-node';\n\nconst BLINKPAY_SANDBOX_URL = 'https://sandbox.debit.blinkpay.co.nz';\n\nexport interface BlinkPayBankDetails {\n  consent_id: string;\n  bank_name: string;\n  account_reference: string;\n  status: 'active' | 'revoked' | 'expired';\n  expires_at: string;\n}\n\nexport class BlinkPayService {\n  private static client: BlinkDebitClient | null = null;\n\n  private static getClient(): BlinkDebitClient {\n    if (!this.client) {\n      const clientId = process.env.BLINKPAY_CLIENT_ID;\n      const clientSecret = process.env.BLINKPAY_CLIENT_SECRET;\n\n      if (!clientId || !clientSecret) {\n        throw new Error('BlinkPay credentials not configured');\n      }\n\n      this.client = new BlinkDebitClient(axios, {\n        blinkpay: {\n          debitUrl: BLINKPAY_SANDBOX_URL,\n          clientId,\n          clientSecret,\n          timeout: 30000,\n          retryEnabled: true\n        }\n      });\n    }\n\n    return this.client;\n  }\n\n  static async createEnduringConsent(\n    redirectUri: string,\n    maxAmountPerPeriod: string = '1000.00'\n  ): Promise<{ consentId: string; redirectUri: string }> {\n    try {\n      console.log('BlinkPay: Starting consent creation...');\n      console.log('BlinkPay: Client ID configured:', !!process.env.BLINKPAY_CLIENT_ID);\n      console.log('BlinkPay: Client Secret configured:', !!process.env.BLINKPAY_CLIENT_SECRET);\n      console.log('BlinkPay: Redirect URI:', redirectUri);\n      \n      const client = this.getClient();\n\n      const now = new Date();\n      const oneYearLater = new Date();\n      oneYearLater.setFullYear(now.getFullYear() + 1);\n\n      const request: EnduringConsentRequest = {\n        flow: {\n          detail: {\n            type: AuthFlowDetailTypeEnum.Gateway,\n            redirectUri\n          }\n        },\n        maximumAmountPeriod: {\n          currency: AmountCurrencyEnum.NZD,\n          total: maxAmountPerPeriod\n        },\n        maximumAmountPayment: {\n          currency: AmountCurrencyEnum.NZD,\n          total: maxAmountPerPeriod\n        },\n        period: 'monthly' as any,\n        fromTimestamp: now.toISOString() as any,\n        expiryTimestamp: oneYearLater.toISOString() as any\n      };\n\n      console.log('BlinkPay: Creating enduring consent with request:', JSON.stringify(request, null, 2));\n\n      const response: CreateConsentResponse = await client.createEnduringConsent(request);\n\n      console.log('BlinkPay: Consent created successfully:', { consentId: response.consentId, redirectUri: response.redirectUri });\n\n      return {\n        consentId: response.consentId || '',\n        redirectUri: response.redirectUri || ''\n      };\n    } catch (error: any) {\n      console.error('BlinkPay: Error creating consent:', error);\n      console.error('BlinkPay: Error details:', JSON.stringify(error, Object.getOwnPropertyNames(error), 2));\n      if (error.response) {\n        console.error('BlinkPay: Response status:', error.response.status);\n        console.error('BlinkPay: Response data:', JSON.stringify(error.response.data, null, 2));\n      }\n      throw error;\n    }\n  }\n\n  static async getEnduringConsent(consentId: string): Promise<BlinkPayBankDetails> {\n    const client = this.getClient();\n    const consent: Consent = await client.getEnduringConsent(consentId);\n\n    const enduringDetail = consent.detail as any;\n\n    return {\n      consent_id: consentId,\n      bank_name: 'Connected Bank',\n      account_reference: '****',\n      status: consent.status === 'Authorised' ? 'active' : \n              consent.status === 'Revoked' ? 'revoked' : 'expired',\n      expires_at: enduringDetail?.expiryTimestamp || ''\n    };\n  }\n\n  static async createPayment(\n    consentId: string,\n    amount: string,\n    particulars: string,\n    reference: string\n  ): Promise<{ paymentId: string; status: string }> {\n    const client = this.getClient();\n\n    const request: PaymentRequest = {\n      consentId,\n      amount: {\n        currency: AmountCurrencyEnum.NZD,\n        total: amount\n      },\n      pcr: {\n        particulars: particulars || 'Split Payment',\n        code: 'PAYMENT',\n        reference: reference || 'SPLIT'\n      }\n    };\n\n    const response: PaymentResponse = await client.createPayment(request);\n\n    return {\n      paymentId: response.paymentId || '',\n      status: 'pending'\n    };\n  }\n\n  static async revokeEnduringConsent(consentId: string): Promise<void> {\n    const client = this.getClient();\n    await client.revokeEnduringConsent(consentId);\n  }\n\n  static async awaitSuccessfulPayment(\n    paymentId: string,\n    maxWaitSeconds: number = 30\n  ): Promise<{ paymentId: string; status: string }> {\n    const client = this.getClient();\n    const payment: Payment = await client.awaitSuccessfulPayment(paymentId, maxWaitSeconds);\n    return {\n      paymentId: payment.paymentId,\n      status: payment.status.toString()\n    };\n  }\n}\n","path":null,"size_bytes":5053,"size_tokens":null},"server/index.ts":{"content":"import express from 'express';\nimport cors from 'cors';\nimport dotenv from 'dotenv';\nimport path from 'path';\nimport nodemailer from 'nodemailer';\n\nimport blinkpayRouter from './routes/blinkpay.routes';\nimport notificationsRouter from './routes/notifications.routes';\nimport twilioRouter from './routes/twilio.routes';\nimport adminRouter from './routes/admin.routes';\nimport stripeRouter from './routes/stripe.routes';\nimport gamificationRouter from './routes/gamification.routes';\nimport { DailyReminderService } from './services/dailyReminder.service';\nimport { sendWithdrawalNotification, sendUserReportNotification } from './services/email.service';\n\n// Email transporter for admin notifications\nconst emailTransporter = process.env.EMAIL_HOST ? nodemailer.createTransport({\n  host: process.env.EMAIL_HOST,\n  port: parseInt(process.env.EMAIL_PORT || '587'),\n  secure: process.env.EMAIL_PORT === '465',\n  auth: {\n    user: process.env.EMAIL_USER,\n    pass: process.env.EMAIL_PASS,\n  },\n}) : null;\n\ndotenv.config();\n\nconst app = express();\nconst PORT = parseInt(process.env.PORT || '8081', 10);\n\napp.use(cors());\napp.use(express.json());\n\napp.use('/admin', express.static(path.join(__dirname, 'public/admin')));\napp.use('/images', express.static(path.join(__dirname, 'public/images')));\n\napp.get('/robots.txt', (req, res) => {\n  res.type('text/plain');\n  res.sendFile(path.join(__dirname, 'public/robots.txt'));\n});\n\napp.get('/sitemap.xml', (req, res) => {\n  res.type('application/xml');\n  res.sendFile(path.join(__dirname, 'public/sitemap.xml'));\n});\n\n// Google Play Console site verification\napp.get('/google9ae7f141ca49f2ac.html', (req, res) => {\n  res.type('text/html');\n  res.sendFile(path.join(__dirname, 'public/google9ae7f141ca49f2ac.html'));\n});\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public/index.html'));\n});\n\napp.get('/terms', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public/terms.html'));\n});\n\napp.get('/privacy', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public/privacy.html'));\n});\n\napp.get('/delete-account', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public/delete-account.html'));\n});\n\napp.get('/card-setup.html', (req, res) => {\n  res.sendFile(path.join(__dirname, 'public/card-setup.html'));\n});\n\n// Import Supabase for server-side password operations\nimport { createClient } from '@supabase/supabase-js';\nconst supabaseUrl = 'https://vhicohutiocnfjwsofhy.supabase.co';\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || '';\nconst supabaseServer = createClient(supabaseUrl, supabaseServiceKey);\n\n// API endpoint for password reset - uses service role key server-side\napp.post('/api/reset-password', async (req, res) => {\n  try {\n    const { token_hash, type, new_password } = req.body;\n    \n    if (!token_hash || !new_password) {\n      return res.status(400).json({ error: 'Missing required fields' });\n    }\n    \n    if (new_password.length < 8) {\n      return res.status(400).json({ error: 'Password must be at least 8 characters' });\n    }\n    \n    // First verify the OTP to get the user\n    const { data: verifyData, error: verifyError } = await supabaseServer.auth.verifyOtp({\n      token_hash,\n      type: type || 'recovery'\n    });\n    \n    if (verifyError) {\n      console.error('Token verification error:', verifyError);\n      return res.status(400).json({ error: 'Invalid or expired reset link', details: verifyError.message });\n    }\n    \n    if (!verifyData.user) {\n      return res.status(400).json({ error: 'Could not verify user' });\n    }\n    \n    // Update the user's password using admin API\n    const { error: updateError } = await supabaseServer.auth.admin.updateUserById(\n      verifyData.user.id,\n      { password: new_password }\n    );\n    \n    if (updateError) {\n      console.error('Password update error:', updateError);\n      return res.status(500).json({ error: 'Failed to update password', details: updateError.message });\n    }\n    \n    console.log('Password updated successfully for user:', verifyData.user.email);\n    res.json({ success: true, message: 'Password updated successfully' });\n    \n  } catch (error: any) {\n    console.error('Reset password error:', error);\n    res.status(500).json({ error: 'An error occurred' });\n  }\n});\n\n// API endpoint for requesting password reset email\napp.post('/api/request-password-reset', async (req, res) => {\n  try {\n    const { email } = req.body;\n    \n    if (!email) {\n      return res.status(400).json({ error: 'Email is required' });\n    }\n    \n    const { error } = await supabaseServer.auth.resetPasswordForEmail(email, {\n      redirectTo: 'https://splinepay.replit.app/reset-password'\n    });\n    \n    if (error) {\n      console.error('Password reset request error:', error);\n      return res.status(500).json({ error: 'Failed to send reset email' });\n    }\n    \n    res.json({ success: true });\n  } catch (error: any) {\n    console.error('Password reset request error:', error);\n    res.status(500).json({ error: 'An error occurred' });\n  }\n});\n\n// API endpoint for account deletion requests (public - for Google Play compliance)\napp.post('/api/account/delete-request', async (req, res) => {\n  try {\n    const { email, reason } = req.body;\n    \n    if (!email) {\n      return res.status(400).json({ error: 'Email is required' });\n    }\n\n    // Send notification email to admin about the deletion request\n    const emailContent = `\nAccount Deletion Request\n========================\n\nUser Email: ${email}\nReason: ${reason || 'Not provided'}\nRequested At: ${new Date().toISOString()}\n\nPlease process this account deletion request within 30 days as per our privacy policy.\n\nSteps to complete:\n1. Verify the user's identity\n2. Check for any pending wallet balance\n3. Delete user data from Supabase\n4. Send confirmation email to user\n    `;\n\n    // Send email notification to admin\n    if (emailTransporter) {\n      await emailTransporter.sendMail({\n        from: 'Spline <noreply@spline.nz>',\n        to: 'hzeng1217@gmail.com',\n        subject: `Account Deletion Request - ${email}`,\n        text: emailContent,\n        html: emailContent.replace(/\\n/g, '<br>'),\n      });\n    }\n\n    console.log('Account deletion request received:', { email, reason, timestamp: new Date().toISOString() });\n    \n    res.json({ success: true, message: 'Deletion request submitted' });\n  } catch (error: any) {\n    console.error('Account deletion request error:', error);\n    res.status(500).json({ error: 'An error occurred' });\n  }\n});\n\n// API endpoint for withdrawal notification emails (internal service endpoint)\n// Protected by a simple service key to prevent unauthorized access from external sources\napp.post('/api/notify-withdrawal', async (req, res) => {\n  try {\n    // Validate service key to prevent unauthorized access\n    // The mobile app uses 'spline-internal-service' as a shared key\n    const serviceKey = req.headers['x-service-key'];\n    const validKeys = ['spline-internal-service', process.env.SESSION_SECRET].filter(Boolean);\n    \n    if (!serviceKey || !validKeys.includes(serviceKey as string)) {\n      return res.status(403).json({ error: 'Unauthorized' });\n    }\n\n    const {\n      userId,\n      userDatabaseId,\n      userName,\n      userEmail,\n      userPhone,\n      amount,\n      feeAmount,\n      netAmount,\n      withdrawalType,\n      bankName,\n      accountNumber,\n      accountHolderName,\n      accountLast4,\n      estimatedArrival,\n      transactionId,\n      remainingBalance\n    } = req.body;\n\n    if (!transactionId || !userId || !amount) {\n      return res.status(400).json({ error: 'Missing required fields' });\n    }\n\n    const success = await sendWithdrawalNotification({\n      userId,\n      userDatabaseId: userDatabaseId || 'N/A',\n      userName: userName || 'Unknown User',\n      userEmail: userEmail || 'N/A',\n      userPhone: userPhone || 'N/A',\n      amount: parseFloat(amount) || 0,\n      feeAmount: parseFloat(feeAmount) || 0,\n      netAmount: parseFloat(netAmount) || 0,\n      withdrawalType: withdrawalType || 'normal',\n      bankName: bankName || 'Unknown Bank',\n      accountNumber: accountNumber || 'Not provided',\n      accountHolderName: accountHolderName || 'Not provided',\n      accountLast4: accountLast4 || '****',\n      estimatedArrival: estimatedArrival || 'Not specified',\n      transactionId,\n      remainingBalance: parseFloat(remainingBalance) || 0\n    });\n\n    res.json({ success, message: success ? 'Notification sent' : 'Notification logged (email not configured)' });\n  } catch (error: any) {\n    console.error('Withdrawal notification error:', error);\n    res.status(500).json({ error: 'Failed to send notification' });\n  }\n});\n\napp.get('/reset-password', (req, res) => {\n  // Use the known Supabase credentials (anon key is meant to be public)\n  const supabaseUrl = 'https://vhicohutiocnfjwsofhy.supabase.co';\n  const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZoaWNvaHV0aW9jbmZqd3NvZmh5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM5NTQ2NjksImV4cCI6MjA3OTUzMDY2OX0.KJuLMgwy2Dfu5amY0VN4KfPemfsJcRB3EI0AxZQpOb8';\n  \n  // Get token from query params (some email clients pass it there)\n  const tokenFromQuery = req.query.token || req.query.access_token || '';\n  const typeFromQuery = req.query.type || '';\n  \n  const html = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Reset Password - Spline</title>\n  <script src=\"https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2\"></script>\n  <style>\n    * { margin: 0; padding: 0; box-sizing: border-box; }\n    body {\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      background: linear-gradient(135deg, #3B82F6 0%, #1E40AF 100%);\n      min-height: 100vh;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      padding: 20px;\n    }\n    .container {\n      background: white;\n      border-radius: 24px;\n      padding: 48px 32px;\n      max-width: 420px;\n      width: 100%;\n      text-align: center;\n      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);\n    }\n    .logo {\n      font-size: 48px;\n      font-weight: 800;\n      margin-bottom: 24px;\n    }\n    .logo-sp { color: #3B82F6; }\n    .logo-line { color: #1f2937; text-decoration: underline; text-decoration-color: #3B82F6; text-underline-offset: 4px; }\n    .logo::after { content: '.'; color: #3B82F6; }\n    h1 {\n      font-size: 24px;\n      color: #1f2937;\n      margin-bottom: 8px;\n    }\n    .subtitle {\n      color: #6b7280;\n      font-size: 14px;\n      margin-bottom: 24px;\n    }\n    .form-group {\n      margin-bottom: 16px;\n      text-align: left;\n    }\n    .form-group label {\n      display: block;\n      color: #374151;\n      font-size: 14px;\n      font-weight: 500;\n      margin-bottom: 6px;\n    }\n    .form-group input {\n      width: 100%;\n      padding: 14px 16px;\n      border: 1px solid #d1d5db;\n      border-radius: 12px;\n      font-size: 16px;\n      transition: border-color 0.2s, box-shadow 0.2s;\n    }\n    .form-group input:focus {\n      outline: none;\n      border-color: #3B82F6;\n      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n    }\n    .btn {\n      display: block;\n      width: 100%;\n      background: #3B82F6;\n      color: white;\n      padding: 16px 32px;\n      border: none;\n      border-radius: 12px;\n      font-weight: 600;\n      font-size: 16px;\n      cursor: pointer;\n      transition: background 0.2s;\n      margin-top: 8px;\n    }\n    .btn:hover { background: #2563eb; }\n    .btn:disabled { background: #9ca3af; cursor: not-allowed; }\n    .btn-secondary {\n      background: transparent;\n      color: #3B82F6;\n      border: 2px solid #3B82F6;\n      margin-top: 12px;\n    }\n    .btn-secondary:hover { background: rgba(59, 130, 246, 0.1); }\n    .error {\n      background: #fef2f2;\n      color: #dc2626;\n      padding: 12px 16px;\n      border-radius: 8px;\n      font-size: 14px;\n      margin-bottom: 16px;\n      display: none;\n    }\n    .success {\n      background: #f0fdf4;\n      color: #16a34a;\n      padding: 12px 16px;\n      border-radius: 8px;\n      font-size: 14px;\n      margin-bottom: 16px;\n      display: none;\n    }\n    .divider {\n      display: flex;\n      align-items: center;\n      margin: 24px 0;\n      color: #9ca3af;\n      font-size: 14px;\n    }\n    .divider::before, .divider::after {\n      content: '';\n      flex: 1;\n      height: 1px;\n      background: #e5e7eb;\n    }\n    .divider span { padding: 0 16px; }\n    .app-link {\n      color: #6b7280;\n      font-size: 14px;\n      margin-top: 16px;\n    }\n    .app-link a { color: #3B82F6; text-decoration: none; font-weight: 500; }\n    .password-requirements {\n      text-align: left;\n      font-size: 12px;\n      color: #6b7280;\n      margin-top: 8px;\n    }\n    .hidden { display: none !important; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"logo\"><span class=\"logo-sp\">Sp</span><span class=\"logo-line\">line</span></div>\n    \n    <div id=\"loading-view\">\n      <h1>Verifying Link...</h1>\n      <p class=\"subtitle\">Please wait while we verify your reset link</p>\n      <div style=\"margin: 24px 0;\">\n        <div style=\"width: 40px; height: 40px; border: 3px solid #e5e7eb; border-top-color: #3B82F6; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;\"></div>\n      </div>\n      <style>@keyframes spin { to { transform: rotate(360deg); } }</style>\n    </div>\n    \n    <div id=\"confirm-view\" class=\"hidden\">\n      <h1>Verify Your Identity</h1>\n      <p class=\"subtitle\">Click the button below to verify your reset link and set a new password.</p>\n      \n      <div id=\"confirm-error\" class=\"error\"></div>\n      \n      <button onclick=\"handleVerifyToken()\" class=\"btn\" id=\"verifyBtn\">\n        Verify & Continue\n      </button>\n      \n      <p class=\"app-link\" style=\"margin-top: 24px;\">\n        <a href=\"/\">Return to Homepage</a>\n      </p>\n    </div>\n    \n    <div id=\"reset-form\" class=\"hidden\">\n      <h1>Reset Your Password</h1>\n      <p class=\"subtitle\">Enter your new password below</p>\n      \n      <div id=\"error\" class=\"error\"></div>\n      <div id=\"success\" class=\"success\"></div>\n      \n      <form onsubmit=\"handleSubmit(event)\">\n        <div class=\"form-group\">\n          <label for=\"password\">New Password</label>\n          <input type=\"password\" id=\"password\" placeholder=\"Enter new password\" required minlength=\"8\">\n          <p class=\"password-requirements\">Must be at least 8 characters</p>\n        </div>\n        \n        <div class=\"form-group\">\n          <label for=\"confirmPassword\">Confirm Password</label>\n          <input type=\"password\" id=\"confirmPassword\" placeholder=\"Confirm new password\" required>\n        </div>\n        \n        <button type=\"submit\" class=\"btn\" id=\"submitBtn\">Update Password</button>\n      </form>\n    </div>\n    \n    <div id=\"expired-view\" class=\"hidden\">\n      <h1>Link Expired</h1>\n      <p class=\"subtitle\">This reset link has expired or is invalid. Request a new one below.</p>\n      \n      <div id=\"expired-error\" class=\"error\"></div>\n      <div id=\"expired-success\" class=\"success\"></div>\n      \n      <form onsubmit=\"handleResendRequest(event)\">\n        <div class=\"form-group\">\n          <label for=\"email\">Email Address</label>\n          <input type=\"email\" id=\"email\" placeholder=\"Enter your email\" required>\n        </div>\n        \n        <button type=\"submit\" class=\"btn\" id=\"resendBtn\">Send New Reset Link</button>\n      </form>\n      \n      <p class=\"app-link\" style=\"margin-top: 24px;\">\n        <a href=\"/\">Return to Homepage</a>\n      </p>\n    </div>\n    \n    <div id=\"success-view\" class=\"hidden\">\n      <div style=\"font-size: 64px; margin-bottom: 24px; color: #16a34a;\">&#10003;</div>\n      <h1>Password Updated!</h1>\n      <p class=\"subtitle\">Your password has been successfully reset. You can now log in with your new password.</p>\n      <a href=\"/\" class=\"btn\" style=\"display: block; text-decoration: none; margin-top: 24px;\">\n        Return to Homepage\n      </a>\n    </div>\n    \n    <div id=\"email-sent-view\" class=\"hidden\">\n      <div style=\"font-size: 64px; margin-bottom: 24px;\">&#9993;</div>\n      <h1>Check Your Email</h1>\n      <p class=\"subtitle\">We've sent a new password reset link to your email address. Please check your inbox and click the link.</p>\n      <a href=\"/\" class=\"btn\" style=\"display: block; text-decoration: none; margin-top: 24px;\">\n        Return to Homepage\n      </a>\n    </div>\n  </div>\n\n  <script>\n    const SUPABASE_URL = '${supabaseUrl}';\n    const SUPABASE_ANON_KEY = '${supabaseAnonKey}';\n    \n    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);\n    let sessionReady = false;\n    \n    function showView(viewId) {\n      ['loading-view', 'confirm-view', 'reset-form', 'expired-view', 'success-view', 'email-sent-view'].forEach(id => {\n        document.getElementById(id).classList.add('hidden');\n      });\n      document.getElementById(viewId).classList.remove('hidden');\n    }\n    \n    // Store token_hash for verification\n    let pendingTokenHash = null;\n    let pendingTokenType = null;\n    \n    function showError(message, elementId = 'error') {\n      const errorEl = document.getElementById(elementId);\n      if (errorEl) {\n        errorEl.textContent = message;\n        errorEl.style.display = 'block';\n      }\n    }\n    \n    function hideError(elementId = 'error') {\n      const errorEl = document.getElementById(elementId);\n      if (errorEl) {\n        errorEl.style.display = 'none';\n      }\n    }\n    \n    // Listen for auth state changes - most reliable method\n    supabase.auth.onAuthStateChange((event, session) => {\n      console.log('Auth event:', event, session ? 'with session' : 'no session');\n      \n      if (event === 'PASSWORD_RECOVERY') {\n        sessionReady = true;\n        showView('reset-form');\n        console.log('Password recovery session established');\n      } else if (event === 'SIGNED_IN' && session) {\n        sessionReady = true;\n        showView('reset-form');\n        console.log('Session established via SIGNED_IN');\n      }\n    });\n    \n    async function initSession() {\n      console.log('Full URL:', window.location.href);\n      console.log('Hash:', window.location.hash);\n      console.log('Search:', window.location.search);\n      \n      // Check for token_hash in URL (from custom email template)\n      const urlParams = new URLSearchParams(window.location.search);\n      const tokenHash = urlParams.get('token_hash');\n      const tokenType = urlParams.get('type') || 'recovery';\n      \n      if (tokenHash) {\n        console.log('Found token_hash in URL, showing confirm view');\n        pendingTokenHash = tokenHash;\n        pendingTokenType = tokenType;\n        showView('confirm-view');\n        return;\n      }\n      \n      // Give Supabase time to process the URL hash (for standard flow)\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      // Check if session was established via onAuthStateChange\n      if (sessionReady) {\n        return;\n      }\n      \n      // Check for existing session\n      const { data: { session }, error } = await supabase.auth.getSession();\n      console.log('Session check:', session ? 'found' : 'not found', error || '');\n      \n      if (session) {\n        sessionReady = true;\n        showView('reset-form');\n        return;\n      }\n      \n      // Wait a bit more then show expired view\n      setTimeout(() => {\n        if (!sessionReady) {\n          console.log('No session established, showing expired view');\n          showView('expired-view');\n        }\n      }, 1500);\n    }\n    \n    async function handleVerifyToken() {\n      const verifyBtn = document.getElementById('verifyBtn');\n      verifyBtn.disabled = true;\n      verifyBtn.textContent = 'Verifying...';\n      \n      hideError('confirm-error');\n      \n      try {\n        if (!pendingTokenHash) {\n          showError('No verification token found.', 'confirm-error');\n          verifyBtn.disabled = false;\n          verifyBtn.textContent = 'Verify & Continue';\n          return;\n        }\n        \n        // Token will be verified server-side when password is submitted\n        // Just show the form for now\n        console.log('Token found, showing password form');\n        sessionReady = true;\n        showView('reset-form');\n        \n      } catch (err) {\n        console.error('Verification error:', err);\n        showError('An error occurred. Please try again.', 'confirm-error');\n        verifyBtn.disabled = false;\n        verifyBtn.textContent = 'Verify & Continue';\n      }\n    }\n    \n    initSession();\n    \n    async function handleResendRequest(e) {\n      e.preventDefault();\n      \n      const email = document.getElementById('email').value;\n      const resendBtn = document.getElementById('resendBtn');\n      \n      hideError('expired-error');\n      resendBtn.disabled = true;\n      resendBtn.textContent = 'Sending...';\n      \n      try {\n        // Use server-side API to send reset email\n        const response = await fetch('/api/request-password-reset', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ email })\n        });\n        \n        const result = await response.json();\n        \n        if (!response.ok) {\n          showError(result.error || 'Failed to send reset email', 'expired-error');\n          resendBtn.disabled = false;\n          resendBtn.textContent = 'Send New Reset Link';\n          return;\n        }\n        \n        showView('email-sent-view');\n      } catch (err) {\n        showError('An error occurred. Please try again.', 'expired-error');\n        resendBtn.disabled = false;\n        resendBtn.textContent = 'Send New Reset Link';\n      }\n    }\n    \n    async function handleSubmit(e) {\n      e.preventDefault();\n      \n      const password = document.getElementById('password').value;\n      const confirmPassword = document.getElementById('confirmPassword').value;\n      const submitBtn = document.getElementById('submitBtn');\n      \n      // Hide previous messages\n      document.getElementById('error').style.display = 'none';\n      document.getElementById('success').style.display = 'none';\n      \n      // Validate passwords match\n      if (password !== confirmPassword) {\n        showError('Passwords do not match');\n        return;\n      }\n      \n      // Validate password length\n      if (password.length < 8) {\n        showError('Password must be at least 8 characters');\n        return;\n      }\n      \n      if (!pendingTokenHash) {\n        showError('Reset link is invalid. Please request a new password reset.');\n        return;\n      }\n      \n      submitBtn.disabled = true;\n      submitBtn.textContent = 'Updating...';\n      \n      try {\n        // Use server-side API to update password\n        const response = await fetch('/api/reset-password', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            token_hash: pendingTokenHash,\n            type: pendingTokenType,\n            new_password: password\n          })\n        });\n        \n        const result = await response.json();\n        \n        if (!response.ok) {\n          showError(result.error || 'Failed to update password');\n          submitBtn.disabled = false;\n          submitBtn.textContent = 'Update Password';\n          \n          // If token expired, show expired view\n          if (result.error && result.error.includes('expired')) {\n            setTimeout(() => showView('expired-view'), 2000);\n          }\n          return;\n        }\n        \n        // Show success view\n        showView('success-view');\n        \n      } catch (err) {\n        console.error('Password update error:', err);\n        showError('An unexpected error occurred. Please try again.');\n        submitBtn.disabled = false;\n        submitBtn.textContent = 'Update Password';\n      }\n    }\n  </script>\n</body>\n</html>`;\n  \n  res.type('html').send(html);\n});\n\n// API endpoint for account deletion - requires authenticated user\napp.delete('/api/delete-account', async (req, res) => {\n  try {\n    const authHeader = req.headers.authorization;\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n    \n    const token = authHeader.replace('Bearer ', '');\n    \n    // Verify the user token\n    const { data: authData, error: authError } = await supabaseServer.auth.getUser(token);\n    \n    if (authError || !authData.user) {\n      console.error('Token verification failed:', authError?.message);\n      return res.status(401).json({ error: 'Invalid or expired token' });\n    }\n    \n    const userId = authData.user.id;\n    const userEmail = authData.user.email;\n    \n    console.log(`Account deletion requested for user: ${userEmail} (${userId})`);\n    \n    // Track deletion errors to ensure complete data removal\n    const deletionErrors: string[] = [];\n    \n    // Delete user data in order (respecting foreign key constraints)\n    // 1. Delete notifications\n    const { error: notifError } = await supabaseServer\n      .from('notifications')\n      .delete()\n      .eq('user_id', userId);\n    if (notifError && notifError.code !== 'PGRST116') {\n      console.error('Notifications delete error:', notifError.message);\n      deletionErrors.push(`notifications: ${notifError.message}`);\n    }\n    \n    // 2. Delete split participants where user is participant\n    const { error: participantError } = await supabaseServer\n      .from('split_participants')\n      .delete()\n      .eq('user_id', userId);\n    if (participantError && participantError.code !== 'PGRST116') {\n      console.error('Split participants delete error:', participantError.message);\n      deletionErrors.push(`split_participants: ${participantError.message}`);\n    }\n    \n    // 3. Delete split events created by user\n    const { error: splitsError } = await supabaseServer\n      .from('split_events')\n      .delete()\n      .eq('creator_id', userId);\n    if (splitsError && splitsError.code !== 'PGRST116') {\n      console.error('Split events delete error:', splitsError.message);\n      deletionErrors.push(`split_events: ${splitsError.message}`);\n    }\n    \n    // 4. Delete friend relationships (both directions)\n    const { error: friendsError1 } = await supabaseServer\n      .from('friends')\n      .delete()\n      .eq('user_id', userId);\n    if (friendsError1 && friendsError1.code !== 'PGRST116') {\n      console.error('Friends (user_id) delete error:', friendsError1.message);\n      deletionErrors.push(`friends_user: ${friendsError1.message}`);\n    }\n    \n    const { error: friendsError2 } = await supabaseServer\n      .from('friends')\n      .delete()\n      .eq('friend_id', userId);\n    if (friendsError2 && friendsError2.code !== 'PGRST116') {\n      console.error('Friends (friend_id) delete error:', friendsError2.message);\n      deletionErrors.push(`friends_friend: ${friendsError2.message}`);\n    }\n    \n    // 5. Delete transactions\n    const { error: txError } = await supabaseServer\n      .from('transactions')\n      .delete()\n      .eq('user_id', userId);\n    if (txError && txError.code !== 'PGRST116') {\n      console.error('Transactions delete error:', txError.message);\n      deletionErrors.push(`transactions: ${txError.message}`);\n    }\n    \n    // 5.5. Delete gamification profiles\n    const { error: gamificationError } = await supabaseServer\n      .from('gamification_profiles')\n      .delete()\n      .eq('user_id', userId);\n    if (gamificationError && gamificationError.code !== 'PGRST116') {\n      console.error('Gamification profile delete error:', gamificationError.message);\n      deletionErrors.push(`gamification: ${gamificationError.message}`);\n    }\n    \n    // 6. Delete wallet\n    const { error: walletError } = await supabaseServer\n      .from('wallets')\n      .delete()\n      .eq('user_id', userId);\n    if (walletError && walletError.code !== 'PGRST116') {\n      console.error('Wallet delete error:', walletError.message);\n      deletionErrors.push(`wallet: ${walletError.message}`);\n    }\n    \n    // 7. Delete user profile\n    const { error: profileError } = await supabaseServer\n      .from('users')\n      .delete()\n      .eq('id', userId);\n    if (profileError && profileError.code !== 'PGRST116') {\n      console.error('User profile delete error:', profileError.message);\n      deletionErrors.push(`user_profile: ${profileError.message}`);\n    }\n    \n    // Check if critical data deletion failed (wallet and user profile are critical)\n    if (deletionErrors.some(e => e.includes('wallet:') || e.includes('user_profile:'))) {\n      console.error('Critical deletion errors:', deletionErrors);\n      return res.status(500).json({ \n        error: 'Failed to delete account data. Please contact support.',\n        details: deletionErrors \n      });\n    }\n    \n    // 8. Delete auth user (this is the final step - only proceed if data was deleted)\n    const { error: authDeleteError } = await supabaseServer.auth.admin.deleteUser(userId);\n    \n    if (authDeleteError) {\n      console.error('Auth user deletion failed:', authDeleteError);\n      return res.status(500).json({ error: 'Failed to complete account deletion. Please contact support.' });\n    }\n    \n    // Log any non-critical deletion issues for monitoring\n    if (deletionErrors.length > 0) {\n      console.warn(`Account deleted with some non-critical errors for ${userEmail}:`, deletionErrors);\n    }\n    \n    console.log(`Account successfully deleted for: ${userEmail}`);\n    res.json({ success: true, message: 'Account deleted successfully' });\n    \n  } catch (error: any) {\n    console.error('Account deletion error:', error);\n    res.status(500).json({ error: 'An error occurred during account deletion' });\n  }\n});\n\n// =============================================\n// BLOCK/UNBLOCK USER ENDPOINTS\n// =============================================\n\n// Block a user\napp.post('/api/friends/block', async (req, res) => {\n  try {\n    const { userId, blockedUserId } = req.body;\n    \n    if (!userId || !blockedUserId) {\n      return res.status(400).json({ error: 'Missing required fields: userId and blockedUserId' });\n    }\n    \n    if (userId === blockedUserId) {\n      return res.status(400).json({ error: 'Cannot block yourself' });\n    }\n    \n    // Use RPC function to block user (handles friendship removal atomically)\n    const { data, error } = await supabaseServer.rpc('block_user', {\n      p_user_id: userId,\n      p_blocked_user_id: blockedUserId\n    });\n    \n    if (error) {\n      console.error('Error blocking user:', error);\n      return res.status(500).json({ error: 'Failed to block user', details: error.message });\n    }\n    \n    console.log(`User ${userId} blocked user ${blockedUserId}`);\n    res.json({ success: true, message: 'User blocked successfully' });\n    \n  } catch (error: any) {\n    console.error('Block user error:', error);\n    res.status(500).json({ error: 'An error occurred while blocking user' });\n  }\n});\n\n// Unblock a user\napp.delete('/api/friends/block/:blockedUserId', async (req, res) => {\n  try {\n    const { blockedUserId } = req.params;\n    const userId = req.query.userId as string;\n    \n    if (!userId || !blockedUserId) {\n      return res.status(400).json({ error: 'Missing required fields: userId and blockedUserId' });\n    }\n    \n    const { error } = await supabaseServer\n      .from('blocked_users')\n      .delete()\n      .eq('user_id', userId)\n      .eq('blocked_user_id', blockedUserId);\n    \n    if (error) {\n      console.error('Error unblocking user:', error);\n      return res.status(500).json({ error: 'Failed to unblock user', details: error.message });\n    }\n    \n    console.log(`User ${userId} unblocked user ${blockedUserId}`);\n    res.json({ success: true, message: 'User unblocked successfully' });\n    \n  } catch (error: any) {\n    console.error('Unblock user error:', error);\n    res.status(500).json({ error: 'An error occurred while unblocking user' });\n  }\n});\n\n// Get blocked users list\napp.get('/api/friends/blocked', async (req, res) => {\n  try {\n    const userId = req.query.userId as string;\n    \n    if (!userId) {\n      return res.status(400).json({ error: 'Missing required field: userId' });\n    }\n    \n    // First get blocked user IDs (avoid PostgREST FK join issues)\n    const { data: blockedData, error: blockedError } = await supabaseServer\n      .from('blocked_users')\n      .select('id, user_id, blocked_user_id, created_at')\n      .eq('user_id', userId)\n      .order('created_at', { ascending: false });\n    \n    if (blockedError) {\n      console.error('Error fetching blocked users:', blockedError);\n      return res.status(500).json({ error: 'Failed to fetch blocked users', details: blockedError.message });\n    }\n    \n    if (!blockedData || blockedData.length === 0) {\n      return res.json({ blockedUsers: [] });\n    }\n    \n    // Then fetch user details separately\n    const blockedUserIds = blockedData.map(b => b.blocked_user_id);\n    const { data: usersData, error: usersError } = await supabaseServer\n      .from('users')\n      .select('id, unique_id, name, email, profile_picture')\n      .in('id', blockedUserIds);\n    \n    if (usersError) {\n      console.error('Error fetching blocked user details:', usersError);\n      return res.status(500).json({ error: 'Failed to fetch blocked user details', details: usersError.message });\n    }\n    \n    // Combine the data\n    const usersMap = new Map(usersData?.map(u => [u.id, u]) || []);\n    const blockedUsers = blockedData.map(b => ({\n      ...b,\n      blocked_user: usersMap.get(b.blocked_user_id) || null\n    }));\n    \n    res.json({ blockedUsers });\n    \n  } catch (error: any) {\n    console.error('Get blocked users error:', error);\n    res.status(500).json({ error: 'An error occurred while fetching blocked users' });\n  }\n});\n\n// Check if a user is blocked\napp.get('/api/friends/is-blocked', async (req, res) => {\n  try {\n    const userId = req.query.userId as string;\n    const otherUserId = req.query.otherUserId as string;\n    \n    if (!userId || !otherUserId) {\n      return res.status(400).json({ error: 'Missing required fields: userId and otherUserId' });\n    }\n    \n    const { data, error } = await supabaseServer.rpc('is_user_blocked', {\n      p_user_id: userId,\n      p_other_user_id: otherUserId\n    });\n    \n    if (error) {\n      console.error('Error checking block status:', error);\n      return res.status(500).json({ error: 'Failed to check block status', details: error.message });\n    }\n    \n    res.json({ isBlocked: data || false });\n    \n  } catch (error: any) {\n    console.error('Check block status error:', error);\n    res.status(500).json({ error: 'An error occurred while checking block status' });\n  }\n});\n\n// =============================================\n// USER REPORT ENDPOINTS\n// =============================================\n\n// Create a user report - stores in Supabase cloud database\napp.post('/api/reports', async (req, res) => {\n  try {\n    const { reporterId, reportedUserId, reason } = req.body;\n    \n    if (!reporterId || !reportedUserId || !reason) {\n      return res.status(400).json({ error: 'Missing required fields: reporterId, reportedUserId, and reason' });\n    }\n    \n    if (reporterId === reportedUserId) {\n      return res.status(400).json({ error: 'Cannot report yourself' });\n    }\n    \n    if (reason.length < 10) {\n      return res.status(400).json({ error: 'Reason must be at least 10 characters' });\n    }\n    \n    // Insert directly into Supabase user_reports table\n    const { data: insertData, error: insertError } = await supabaseServer\n      .from('user_reports')\n      .insert({\n        reporter_id: reporterId,\n        reported_user_id: reportedUserId,\n        reason: reason,\n        status: 'pending'\n      })\n      .select('id')\n      .single();\n    \n    if (insertError) {\n      console.error('Error creating report:', insertError);\n      return res.status(500).json({ error: 'Failed to create report', details: insertError.message });\n    }\n    \n    const reportId = insertData?.id;\n    \n    // Get user details from Supabase for email notification\n    const { data: users } = await supabaseServer\n      .from('users')\n      .select('id, name, email')\n      .in('id', [reporterId, reportedUserId]);\n    \n    const reporter = users?.find(u => u.id === reporterId);\n    const reportedUser = users?.find(u => u.id === reportedUserId);\n    \n    // Send email notification to admin\n    if (reporter && reportedUser) {\n      await sendUserReportNotification({\n        reportId,\n        reporterId,\n        reporterName: reporter.name || 'Unknown',\n        reporterEmail: reporter.email || 'Unknown',\n        reportedUserId,\n        reportedUserName: reportedUser.name || 'Unknown',\n        reportedUserEmail: reportedUser.email || 'Unknown',\n        reason,\n        timestamp: new Date().toLocaleString('en-NZ', { timeZone: 'Pacific/Auckland' })\n      });\n    }\n    \n    console.log(`Report created: ${reporterId} reported ${reportedUserId}`);\n    res.json({ success: true, reportId, message: 'Report submitted successfully' });\n    \n  } catch (error: any) {\n    console.error('Create report error:', error);\n    res.status(500).json({ error: 'An error occurred while creating report' });\n  }\n});\n\napp.get('/health', (req, res) => {\n  res.json({ status: 'ok', message: 'Backend server is running' });\n});\n\napp.use('/api/blinkpay', blinkpayRouter);\napp.use('/api/notifications', notificationsRouter);\napp.use('/api/twilio', twilioRouter);\napp.use('/api/admin', adminRouter);\napp.use('/api/stripe', stripeRouter);\napp.use('/api/gamification', gamificationRouter);\n\napp.post('/api/reminders/send-now', async (req, res) => {\n  try {\n    console.log('Manual trigger: Sending daily reminders now');\n    await DailyReminderService.sendDailyReminders();\n    res.json({ success: true, message: 'Daily reminders sent' });\n  } catch (error: any) {\n    console.error('Error sending reminders:', error);\n    res.status(500).json({ error: error.message || 'Failed to send reminders' });\n  }\n});\n\napp.listen(PORT, '0.0.0.0', () => {\n  console.log(`Spline server running on port ${PORT}`);\n  console.log(`Landing page: http://localhost:${PORT}`);\n  console.log(`Admin dashboard: http://localhost:${PORT}/admin`);\n  \n  DailyReminderService.start();\n});\n","path":null,"size_bytes":38346,"size_tokens":null},"start-all.sh":{"content":"#!/bin/bash\n\n# Start backend server on port 8082 in the background\nPORT=8082 npx tsx server/index.ts &\n\n# Start Expo dev server\nEXPO_PACKAGER_PROXY_URL=https://$REPLIT_DEV_DOMAIN REACT_NATIVE_PACKAGER_HOSTNAME=$REPLIT_DEV_DOMAIN npx expo start\n","path":null,"size_bytes":244,"size_tokens":null},"server/routes/blinkpay.routes.ts":{"content":"import express from 'express';\nimport { BlinkPayService } from '../services/blinkpay.service';\n\nconst router = express.Router();\n\nrouter.get('/health', (req, res) => {\n  res.json({ \n    status: 'ok', \n    service: 'blinkpay',\n    timestamp: new Date().toISOString()\n  });\n});\n\nrouter.post('/consent/create', async (req, res) => {\n  try {\n    const { redirectUri, maxAmountPerPeriod } = req.body;\n    \n    if (!redirectUri) {\n      return res.status(400).json({ error: 'redirectUri is required' });\n    }\n\n    const result = await BlinkPayService.createEnduringConsent(\n      redirectUri,\n      maxAmountPerPeriod || '1000.00'\n    );\n    \n    res.json(result);\n  } catch (error: any) {\n    console.error('Error creating consent:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.get('/consent/:consentId', async (req, res) => {\n  try {\n    const { consentId } = req.params;\n    \n    const result = await BlinkPayService.getEnduringConsent(consentId);\n    \n    res.json(result);\n  } catch (error: any) {\n    console.error('Error getting consent:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/consent/revoke', async (req, res) => {\n  try {\n    const { consentId } = req.body;\n    \n    if (!consentId) {\n      return res.status(400).json({ error: 'consentId is required' });\n    }\n\n    await BlinkPayService.revokeEnduringConsent(consentId);\n    \n    res.json({ success: true });\n  } catch (error: any) {\n    console.error('Error revoking consent:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/payment', async (req, res) => {\n  try {\n    const { consentId, amount, particulars, reference } = req.body;\n    \n    if (!consentId || !amount) {\n      return res.status(400).json({ error: 'consentId and amount are required' });\n    }\n\n    const result = await BlinkPayService.createPayment(\n      consentId,\n      amount,\n      particulars || 'Split Payment',\n      reference || 'SPLIT'\n    );\n    \n    res.json(result);\n  } catch (error: any) {\n    console.error('Error creating payment:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/payment/create', async (req, res) => {\n  try {\n    const { consentId, amount, particulars, reference } = req.body;\n    \n    if (!consentId || !amount) {\n      return res.status(400).json({ error: 'consentId and amount are required' });\n    }\n\n    const result = await BlinkPayService.createPayment(\n      consentId,\n      amount,\n      particulars || 'Split Payment',\n      reference || 'SPLIT'\n    );\n    \n    res.json(result);\n  } catch (error: any) {\n    console.error('Error creating payment:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.get('/payment/:paymentId/status', async (req, res) => {\n  try {\n    const { paymentId } = req.params;\n    const { maxWaitSeconds } = req.query;\n    \n    const result = await BlinkPayService.awaitSuccessfulPayment(\n      paymentId,\n      maxWaitSeconds ? parseInt(maxWaitSeconds as string) : 30\n    );\n    \n    res.json(result);\n  } catch (error: any) {\n    console.error('Error checking payment status:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nexport default router;\n","path":null,"size_bytes":3243,"size_tokens":null},"utils/backend.ts":{"content":"import * as Constants from 'expo-constants';\n\n/**\n * Resolves the backend API origin for BlinkPay operations.\n * \n * Environment support:\n * - Web/Replit: Uses EXPO_PUBLIC_BACKEND_URL (HTTPS)\n * - Expo Go on LAN: Auto-detects from hostUri (HTTP)\n * - Expo Go tunnel (exp.host/u.expo.dev): Requires EXPO_PUBLIC_BACKEND_URL\n * - Localhost web: Falls back to http://localhost:8082\n * \n * Note: Expo tunnel mode cannot reach local backends.\n * Set EXPO_PUBLIC_BACKEND_URL to your Replit domain for tunnel testing.\n */\nconst PRODUCTION_BACKEND_URL = 'https://splinepay.replit.app';\n\nexport const resolveBackendOrigin = (): string => {\n  if (process.env.EXPO_PUBLIC_BACKEND_URL) {\n    const url = process.env.EXPO_PUBLIC_BACKEND_URL;\n    console.log('Using EXPO_PUBLIC_BACKEND_URL:', url);\n    return url;\n  }\n  \n  const isDev = __DEV__;\n  \n  // In production builds (TestFlight, App Store), use the production backend\n  if (!isDev) {\n    console.log('Using production backend URL:', PRODUCTION_BACKEND_URL);\n    return PRODUCTION_BACKEND_URL;\n  }\n  \n  const replitDevDomain = process.env.EXPO_PUBLIC_REPLIT_DEV_DOMAIN;\n  \n  if (replitDevDomain) {\n    const url = `https://${replitDevDomain}:8082`;\n    console.log('Using REPLIT_DEV_DOMAIN:', url);\n    return url;\n  }\n  \n  if (Constants.default.expoConfig?.hostUri) {\n    const fullHostUri = Constants.default.expoConfig.hostUri;\n    const hostWithoutScheme = fullHostUri.replace(/^[a-z]+:\\/\\//, '');\n    const hostWithoutPath = hostWithoutScheme.split('/')[0];\n    const host = hostWithoutPath.split(':')[0];\n    \n    if (host === 'exp.host' || host === 'u.expo.dev') {\n      console.error(\n        '⚠️ EXPO TUNNEL DETECTED: Backend cannot be reached through Expo tunnel.',\n        '\\nPlease set EXPO_PUBLIC_BACKEND_URL environment variable to your Replit domain:',\n        '\\nEXPO_PUBLIC_BACKEND_URL=https://your-repl.replit.dev:8082',\n        '\\nOr use LAN mode instead of tunnel mode for local testing.'\n      );\n      throw new Error(\n        'Backend unreachable in Expo tunnel mode. Set EXPO_PUBLIC_BACKEND_URL or use LAN mode.'\n      );\n    }\n    \n    const scheme = fullHostUri.includes('.replit.dev') ? 'https' : 'http';\n    const url = `${scheme}://${host}:8082`;\n    console.log('Using hostUri with scheme:', url, 'from', fullHostUri);\n    return url;\n  }\n  \n  const fallback = 'http://localhost:8082';\n  console.log('Using fallback localhost:', fallback);\n  return fallback;\n};\n","path":null,"size_bytes":2440,"size_tokens":null},"start-with-tunnel.sh":{"content":"#!/bin/bash\n\nTUNNEL_LOG=\"/tmp/cloudflared.log\"\nTUNNEL_URL_FILE=\"/tmp/tunnel_url.txt\"\n\necho \"============================================\"\necho \"  Split Payment App - Development Server\"\necho \"============================================\"\n\ncleanup() {\n    echo \"\"\n    echo \"Shutting down...\"\n    pkill -f \"cloudflared tunnel\" 2>/dev/null\n    exit 0\n}\n\ntrap cleanup SIGINT SIGTERM\n\nstart_tunnel() {\n    echo \"\"\n    echo \"Starting Cloudflare tunnel for backend...\"\n    pkill -f \"cloudflared tunnel\" 2>/dev/null\n    sleep 1\n    \n    cloudflared tunnel --url http://127.0.0.1:8082 --protocol http2 > \"$TUNNEL_LOG\" 2>&1 &\n    TUNNEL_PID=$!\n    \n    for i in {1..30}; do\n        TUNNEL_URL=$(grep -o 'https://[^[:space:]]*\\.trycloudflare\\.com' \"$TUNNEL_LOG\" 2>/dev/null | head -1)\n        if [ -n \"$TUNNEL_URL\" ]; then\n            echo \"$TUNNEL_URL\" > \"$TUNNEL_URL_FILE\"\n            echo \"\"\n            echo \"============================================\"\n            echo \"  TUNNEL ACTIVE\"\n            echo \"============================================\"\n            echo \"  Backend URL: $TUNNEL_URL\"\n            echo \"\"\n            echo \"  To use on Expo Go (mobile):\"\n            echo \"  1. Set this environment variable in Replit:\"\n            echo \"     EXPO_PUBLIC_BACKEND_URL=$TUNNEL_URL\"\n            echo \"  2. Restart the app\"\n            echo \"============================================\"\n            echo \"\"\n            export EXPO_PUBLIC_BACKEND_URL=\"$TUNNEL_URL\"\n            return 0\n        fi\n        sleep 1\n    done\n    \n    echo \"Warning: Could not establish tunnel connection\"\n    echo \"Mobile bank connection will not work\"\n    echo \"Web version will still work via localhost\"\n    return 1\n}\n\nstart_tunnel\n\necho \"Starting development servers...\"\nnpm run dev\n","path":null,"size_bytes":1770,"size_tokens":null},"services/pushNotifications.service.ts":{"content":"import * as Notifications from 'expo-notifications';\nimport * as Device from 'expo-device';\nimport { Platform } from 'react-native';\nimport Constants from 'expo-constants';\nimport { supabase } from './supabase';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: true,\n    shouldSetBadge: true,\n    shouldShowBanner: true,\n    shouldShowList: true,\n  }),\n});\n\nexport interface PushNotificationData {\n  title: string;\n  body: string;\n  data?: Record<string, any>;\n}\n\nexport class PushNotificationsService {\n  static async registerForPushNotifications(userId: string): Promise<string | null> {\n    if (Platform.OS === 'web') {\n      console.log('Push notifications not supported on web');\n      return null;\n    }\n\n    if (!Device.isDevice) {\n      console.log('Push notifications require a physical device');\n      return null;\n    }\n\n    try {\n      const { status: existingStatus } = await Notifications.getPermissionsAsync();\n      let finalStatus = existingStatus;\n\n      if (existingStatus !== 'granted') {\n        const { status } = await Notifications.requestPermissionsAsync();\n        finalStatus = status;\n      }\n\n      if (finalStatus !== 'granted') {\n        console.log('Push notification permission denied');\n        return null;\n      }\n\n      if (Platform.OS === 'android') {\n        await Notifications.setNotificationChannelAsync('default', {\n          name: 'Split Notifications',\n          importance: Notifications.AndroidImportance.MAX,\n          vibrationPattern: [0, 250, 250, 250],\n          lightColor: '#2563EB',\n        });\n      }\n\n      // Get projectId - must be a valid UUID from EAS\n      const projectId = \n        Constants?.expoConfig?.extra?.eas?.projectId ?? \n        Constants?.easConfig?.projectId;\n      \n      // If no valid EAS projectId, skip push token registration\n      // Push notifications require a development build with EAS for full support\n      if (!projectId) {\n        console.log('Push notifications: No EAS projectId configured. Skipping token registration.');\n        console.log('Note: For full push notification support, create a development build with EAS.');\n        return null;\n      }\n      \n      console.log('Using projectId for push notifications:', projectId);\n      \n      const tokenData = await Notifications.getExpoPushTokenAsync({\n        projectId: projectId,\n      });\n\n      const pushToken = tokenData.data;\n      console.log('Got push token:', pushToken);\n\n      await this.savePushToken(userId, pushToken);\n\n      return pushToken;\n    } catch (error: any) {\n      // Gracefully handle Expo Go limitations\n      if (error?.message?.includes('Invalid uuid') || error?.message?.includes('400')) {\n        console.log('Push notifications: EAS project not configured. Using in-app notifications only.');\n        console.log('Note: For push notifications, build with EAS: npx eas build');\n        return null;\n      }\n      console.error('Failed to register for push notifications:', error);\n      return null;\n    }\n  }\n\n  static async savePushToken(userId: string, pushToken: string): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('users')\n        .update({ push_token: pushToken })\n        .eq('id', userId);\n\n      if (error) {\n        // Gracefully handle missing column - push notifications will still work\n        // but tokens won't persist across sessions until the column is added\n        if (error.code === 'PGRST204' || error.message?.includes('push_token')) {\n          console.log('Push token column not found in database. Push notifications require the push_token column in users table.');\n          return;\n        }\n        console.error('Failed to save push token:', error);\n      } else {\n        console.log('Push token saved successfully');\n      }\n    } catch (error) {\n      console.error('Error saving push token:', error);\n    }\n  }\n\n  static async removePushToken(userId: string): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('users')\n        .update({ push_token: null })\n        .eq('id', userId);\n      \n      // Silently ignore if column doesn't exist\n      if (error && (error.code === 'PGRST204' || error.message?.includes('push_token'))) {\n        return;\n      }\n    } catch (error) {\n      console.error('Error removing push token:', error);\n    }\n  }\n\n  static async getPushToken(userId: string): Promise<string | null> {\n    try {\n      const { data, error } = await supabase\n        .from('users')\n        .select('push_token')\n        .eq('id', userId)\n        .single();\n\n      // Return null if column doesn't exist or other error\n      if (error) {\n        if (error.code === 'PGRST204' || error.message?.includes('push_token')) {\n          return null;\n        }\n        return null;\n      }\n      return data?.push_token ?? null;\n    } catch (error) {\n      console.error('Error getting push token:', error);\n      return null;\n    }\n  }\n\n  static async sendPushNotification(\n    pushToken: string,\n    notification: PushNotificationData\n  ): Promise<boolean> {\n    try {\n      const message = {\n        to: pushToken,\n        sound: 'default',\n        title: notification.title,\n        body: notification.body,\n        data: notification.data || {},\n        priority: 'high' as const,\n        badge: 1,\n      };\n\n      const response = await fetch('https://exp.host/--/api/v2/push/send', {\n        method: 'POST',\n        headers: {\n          Accept: 'application/json',\n          'Accept-encoding': 'gzip, deflate',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(message),\n      });\n\n      const result = await response.json();\n      \n      if (result.data && Array.isArray(result.data)) {\n        const ticket = result.data[0];\n        if (ticket?.status === 'ok') {\n          console.log('Push notification sent successfully');\n          return true;\n        } else if (ticket?.status === 'error') {\n          console.error('Push notification error:', ticket.message, ticket.details);\n          return false;\n        }\n      }\n      \n      console.log('Push notification response:', result);\n      return true;\n    } catch (error) {\n      console.error('Error sending push notification:', error);\n      return false;\n    }\n  }\n\n  static async sendPushToUser(\n    userId: string,\n    notification: PushNotificationData\n  ): Promise<boolean> {\n    const pushToken = await this.getPushToken(userId);\n    \n    if (!pushToken) {\n      console.log('No push token found for user:', userId);\n      return false;\n    }\n\n    return this.sendPushNotification(pushToken, notification);\n  }\n\n  static async sendPushToMultipleUsers(\n    userIds: string[],\n    notification: PushNotificationData\n  ): Promise<void> {\n    const promises = userIds.map(userId => this.sendPushToUser(userId, notification));\n    await Promise.allSettled(promises);\n  }\n\n  static addNotificationReceivedListener(\n    callback: (notification: Notifications.Notification) => void\n  ): Notifications.Subscription {\n    return Notifications.addNotificationReceivedListener(callback);\n  }\n\n  static addNotificationResponseListener(\n    callback: (response: Notifications.NotificationResponse) => void\n  ): Notifications.Subscription {\n    return Notifications.addNotificationResponseReceivedListener(callback);\n  }\n\n  static async setBadgeCount(count: number): Promise<void> {\n    try {\n      await Notifications.setBadgeCountAsync(count);\n    } catch (error) {\n      console.error('Error setting badge count:', error);\n    }\n  }\n\n  static async clearBadge(): Promise<void> {\n    await this.setBadgeCount(0);\n  }\n}\n","path":null,"size_bytes":7678,"size_tokens":null},"hooks/usePushNotifications.ts":{"content":"import { useEffect, useRef } from 'react';\nimport { AppState, AppStateStatus } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport type { Subscription } from 'expo-notifications';\nimport { PushNotificationsService } from '@/services/pushNotifications.service';\nimport { NotificationsService } from '@/services/notifications.service';\nimport * as RootNavigation from '@/utils/RootNavigation';\n\ntype NotificationType = \n  | 'friend_request' \n  | 'friend_accepted' \n  | 'split_invite' \n  | 'split_accepted' \n  | 'split_declined' \n  | 'split_paid' \n  | 'split_completed' \n  | 'payment_reminder'\n  | 'payment_received'\n  | 'split_cancelled';\n\nfunction handleNotificationNavigation(data: Record<string, any> | undefined, delayMs: number = 0) {\n  const notificationType = data?.type as NotificationType | undefined;\n  \n  console.log('[PushNotification] Handling navigation for type:', notificationType, 'data:', data);\n  \n  const doNavigation = () => {\n    try {\n      switch (notificationType) {\n        case 'friend_request':\n        case 'friend_accepted':\n          console.log('[PushNotification] Deep linking to FriendsTab for:', notificationType);\n          RootNavigation.navigate('Main', {\n            screen: 'FriendsTab',\n            params: {\n              screen: 'Friends',\n            },\n          });\n          break;\n\n        case 'split_invite':\n        case 'split_accepted':\n        case 'split_declined':\n        case 'split_paid':\n        case 'split_completed':\n        case 'payment_received':\n          if (data?.splitEventId) {\n            console.log('[PushNotification] Deep linking to EventDetail for split:', data.splitEventId);\n            RootNavigation.navigate('Main', {\n              screen: 'HomeTab',\n              params: {\n                screen: 'EventDetail',\n                params: { eventId: data.splitEventId },\n              },\n            });\n          } else {\n            console.log('[PushNotification] Deep linking to Notifications (no splitEventId)');\n            RootNavigation.navigate('Main', {\n              screen: 'HomeTab',\n              params: {\n                screen: 'Notifications',\n              },\n            });\n          }\n          break;\n\n        case 'split_cancelled':\n          console.log('[PushNotification] Split was cancelled, navigating to Notifications');\n          RootNavigation.navigate('Main', {\n            screen: 'HomeTab',\n            params: {\n              screen: 'Notifications',\n            },\n          });\n          break;\n\n        case 'payment_reminder':\n          console.log('[PushNotification] Deep linking to Notifications for payment reminder');\n          RootNavigation.navigate('Main', {\n            screen: 'HomeTab',\n            params: {\n              screen: 'Notifications',\n            },\n          });\n          break;\n\n        default:\n          if (data?.splitEventId) {\n            console.log('[PushNotification] Deep linking to EventDetail (default with splitEventId)');\n            RootNavigation.navigate('Main', {\n              screen: 'HomeTab',\n              params: {\n                screen: 'EventDetail',\n                params: { eventId: data.splitEventId },\n              },\n            });\n          } else if (data?.friendship_id) {\n            console.log('[PushNotification] Deep linking to FriendsTab (default with friendship_id)');\n            RootNavigation.navigate('Main', {\n              screen: 'FriendsTab',\n              params: {\n                screen: 'Friends',\n              },\n            });\n          } else {\n            console.log('[PushNotification] Deep linking to Notifications (default fallback)');\n            RootNavigation.navigate('Main', {\n              screen: 'HomeTab',\n              params: {\n                screen: 'Notifications',\n              },\n            });\n          }\n          break;\n      }\n    } catch (error) {\n      console.error('[PushNotification] Navigation error:', error);\n      try {\n        RootNavigation.navigate('Main', {\n          screen: 'HomeTab',\n          params: { screen: 'MainHome' },\n        });\n      } catch (fallbackError) {\n        console.error('[PushNotification] Fallback navigation error:', fallbackError);\n      }\n    }\n  };\n\n  if (delayMs > 0) {\n    setTimeout(doNavigation, delayMs);\n  } else {\n    doNavigation();\n  }\n}\n\nexport function usePushNotifications(userId: string | undefined) {\n  const notificationListener = useRef<Subscription | null>(null);\n  const responseListener = useRef<Subscription | null>(null);\n  const initialNotificationHandled = useRef(false);\n\n  useEffect(() => {\n    if (!userId) return;\n\n    const registerAndSetup = async () => {\n      await PushNotificationsService.registerForPushNotifications(userId);\n\n      try {\n        const unreadCount = await NotificationsService.getUnreadCount(userId);\n        await PushNotificationsService.setBadgeCount(unreadCount);\n      } catch (error) {\n        console.error('Failed to set initial badge count:', error);\n      }\n    };\n\n    registerAndSetup();\n\n    const checkInitialNotification = async () => {\n      if (initialNotificationHandled.current) return;\n      \n      try {\n        const lastResponse = await Notifications.getLastNotificationResponseAsync();\n        if (lastResponse) {\n          initialNotificationHandled.current = true;\n          console.log('[PushNotification] Handling initial notification response (cold start)');\n          const data = lastResponse.notification.request.content.data;\n          \n          handleNotificationNavigation(data, 1000);\n        }\n      } catch (error) {\n        console.error('[PushNotification] Error checking initial notification:', error);\n      }\n    };\n\n    setTimeout(() => {\n      checkInitialNotification();\n    }, 500);\n\n    notificationListener.current = PushNotificationsService.addNotificationReceivedListener(\n      (notification) => {\n        console.log('Notification received:', notification);\n      }\n    );\n\n    responseListener.current = PushNotificationsService.addNotificationResponseListener(\n      (response) => {\n        console.log('[PushNotification] Notification response received');\n        const data = response.notification.request.content.data;\n        handleNotificationNavigation(data);\n      }\n    );\n\n    const handleAppStateChange = async (nextAppState: AppStateStatus) => {\n      if (nextAppState === 'active' && userId) {\n        try {\n          const unreadCount = await NotificationsService.getUnreadCount(userId);\n          await PushNotificationsService.setBadgeCount(unreadCount);\n        } catch (error) {\n          console.error('Failed to update badge count:', error);\n        }\n      }\n    };\n\n    const subscription = AppState.addEventListener('change', handleAppStateChange);\n\n    return () => {\n      if (notificationListener.current) {\n        notificationListener.current.remove();\n      }\n      if (responseListener.current) {\n        responseListener.current.remove();\n      }\n      subscription.remove();\n    };\n  }, [userId]);\n}\n","path":null,"size_bytes":7045,"size_tokens":null},"screens/ForgotPasswordScreen.tsx":{"content":"import React, { useState } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, Platform } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { Feather } from '@expo/vector-icons';\nimport { supabase } from '@/services/supabase';\n\ntype Props = NativeStackScreenProps<any, 'ForgotPassword'>;\n\nexport default function ForgotPasswordScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n  const [email, setEmail] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [sent, setSent] = useState(false);\n  const [error, setError] = useState('');\n\n  const getRedirectUrl = (): string => {\n    // Always use the production web URL for password reset\n    // This ensures the redirect URL matches what's in Supabase's allowed list\n    // The web page will then provide a deep link to open the app\n    // Note: Expo Go uses exp:// scheme which isn't in the allowed list,\n    // so we must use the web URL even on mobile\n    return 'https://splinepay.replit.app/reset-password';\n  };\n\n  const handleResetPassword = async () => {\n    setError('');\n    \n    if (!email) {\n      setError('Please enter your email address');\n      return;\n    }\n\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      setError('Please enter a valid email address');\n      return;\n    }\n\n    setLoading(true);\n    try {\n      const redirectUrl = getRedirectUrl();\n      console.log('Password reset redirect URL:', redirectUrl);\n      \n      const { error: supabaseError } = await supabase.auth.resetPasswordForEmail(email, {\n        redirectTo: redirectUrl,\n      });\n\n      if (supabaseError) {\n        if (supabaseError.message.includes('rate limit')) {\n          setError('Too many requests. Please try again in a few minutes.');\n        } else {\n          setError(supabaseError.message);\n        }\n        return;\n      }\n\n      setSent(true);\n    } catch (err: any) {\n      setError(err.message || 'Failed to send reset email');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  if (sent) {\n    return (\n      <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n        <ThemedView style={styles.content}>\n          <View style={[styles.iconContainer, { backgroundColor: Colors.light.success + '20' }]}>\n            <Feather name=\"mail\" size={48} color={Colors.light.success} />\n          </View>\n          \n          <ThemedText style={[Typography.h1, { color: theme.text, marginTop: Spacing.xl, textAlign: 'center' }]}>\n            Check Your Email\n          </ThemedText>\n          \n          <ThemedText style={[Typography.body, { color: theme.textSecondary, marginTop: Spacing.md, textAlign: 'center' }]}>\n            We've sent password reset instructions to:\n          </ThemedText>\n          \n          <ThemedText style={[Typography.body, { color: theme.primary, marginTop: Spacing.sm, fontWeight: '600', textAlign: 'center' }]}>\n            {email}\n          </ThemedText>\n          \n          <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginTop: Spacing.xl, textAlign: 'center' }]}>\n            Didn't receive the email? Check your spam folder or try again.\n          </ThemedText>\n\n          <Pressable\n            style={({ pressed }) => [\n              styles.button,\n              { backgroundColor: theme.primary, opacity: pressed ? 0.7 : 1, marginTop: Spacing['2xl'] }\n            ]}\n            onPress={() => navigation.popToTop()}\n          >\n            <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n              Back to Login\n            </ThemedText>\n          </Pressable>\n\n          <Pressable\n            style={({ pressed }) => [styles.linkButton, { opacity: pressed ? 0.7 : 1 }]}\n            onPress={() => {\n              setSent(false);\n              setEmail('');\n            }}\n          >\n            <ThemedText style={[Typography.body, { color: theme.primary }]}>\n              Try a different email\n            </ThemedText>\n          </Pressable>\n        </ThemedView>\n      </ScreenKeyboardAwareScrollView>\n    );\n  }\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <View style={[styles.iconContainer, { backgroundColor: theme.primary + '15' }]}>\n          <Feather name=\"lock\" size={48} color={theme.primary} />\n        </View>\n        \n        <ThemedText style={[Typography.h1, { color: theme.text, marginTop: Spacing.xl, textAlign: 'center' }]}>\n          Forgot Password?\n        </ThemedText>\n        \n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginTop: Spacing.md, textAlign: 'center' }]}>\n          No worries! Enter your email address and we'll send you instructions to reset your password.\n        </ThemedText>\n\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: error ? Colors.light.danger : theme.border,\n            marginTop: Spacing['2xl']\n          }]}\n          placeholder=\"Email address\"\n          placeholderTextColor={theme.textSecondary}\n          value={email}\n          onChangeText={(text) => {\n            setEmail(text);\n            if (error) setError('');\n          }}\n          keyboardType=\"email-address\"\n          autoCapitalize=\"none\"\n          autoCorrect={false}\n          autoFocus\n        />\n\n        {error ? (\n          <ThemedText style={[Typography.caption, { color: Colors.light.danger, marginTop: Spacing.sm }]}>\n            {error}\n          </ThemedText>\n        ) : null}\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { backgroundColor: theme.primary, opacity: pressed || loading ? 0.7 : 1 }\n          ]}\n          onPress={handleResetPassword}\n          disabled={loading}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            {loading ? 'Sending...' : 'Send Reset Link'}\n          </ThemedText>\n        </Pressable>\n\n        <Pressable\n          style={({ pressed }) => [styles.linkButton, { opacity: pressed ? 0.7 : 1 }]}\n          onPress={() => navigation.goBack()}\n        >\n          <View style={styles.backLink}>\n            <Feather name=\"arrow-left\" size={16} color={theme.primary} />\n            <ThemedText style={[Typography.body, { color: theme.primary, marginLeft: Spacing.xs }]}>\n              Back to Login\n            </ThemedText>\n          </View>\n        </Pressable>\n      </ThemedView>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  iconContainer: {\n    width: 96,\n    height: 96,\n    borderRadius: 48,\n    justifyContent: 'center',\n    alignItems: 'center',\n    alignSelf: 'center',\n  },\n  input: {\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    fontSize: 16,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginTop: Spacing.lg,\n  },\n  linkButton: {\n    marginTop: Spacing.xl,\n    alignItems: 'center',\n  },\n  backLink: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":7820,"size_tokens":null},"screens/WelcomeScreen.tsx":{"content":"import React, { useEffect, useState } from 'react';\nimport { View, StyleSheet, Pressable, useWindowDimensions, Platform, ActivityIndicator, Alert } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport * as RootNavigation from '@/utils/RootNavigation';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n  withRepeat,\n  withSequence,\n  withDelay,\n  Easing,\n  interpolate,\n  useDerivedValue,\n} from 'react-native-reanimated';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { SocialAuthService } from '@/services/socialAuth.service';\n\ntype Props = NativeStackScreenProps<any, 'Welcome'>;\n\nfunction quadraticBezier(t: number, p0: {x: number, y: number}, p1: {x: number, y: number}, p2: {x: number, y: number}) {\n  'worklet';\n  const oneMinusT = 1 - t;\n  const x = oneMinusT * oneMinusT * p0.x + 2 * oneMinusT * t * p1.x + t * t * p2.x;\n  const y = oneMinusT * oneMinusT * p0.y + 2 * oneMinusT * t * p1.y + t * t * p2.y;\n  return { x, y };\n}\n\nexport default function WelcomeScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n  const { refreshUser, setSocialSignupInProgress, clearSignupOverlay } = useAuth();\n  const insets = useSafeAreaInsets();\n  const { width, height } = useWindowDimensions();\n  const [appleLoading, setAppleLoading] = useState(false);\n  const [googleLoading, setGoogleLoading] = useState(false);\n  const [showAppleButton, setShowAppleButton] = useState(false);\n\n  const progress = useSharedValue(0);\n  const fadeIn = useSharedValue(0);\n  const floatAnim1 = useSharedValue(0);\n  const floatAnim2 = useSharedValue(0);\n  const floatAnim3 = useSharedValue(0);\n\n  const curveStartX = width * 0.08;\n  const curveEndX = width * 0.92;\n  const curveY = height * 0.32;\n  const curveControlY = height * 0.18;\n  const controlX = width * 0.5;\n\n  const startPoint = { x: curveStartX, y: curveY };\n  const controlPoint = { x: controlX, y: curveControlY };\n  const endPoint = { x: curveEndX, y: curveY };\n\n  useEffect(() => {\n    SocialAuthService.isAppleSignInAvailable().then(setShowAppleButton);\n    \n    fadeIn.value = withTiming(1, { duration: 1000 });\n    \n    progress.value = withRepeat(\n      withSequence(\n        withTiming(1, { duration: 3000, easing: Easing.inOut(Easing.ease) }),\n        withTiming(0, { duration: 3000, easing: Easing.inOut(Easing.ease) })\n      ),\n      -1,\n      false\n    );\n\n    floatAnim1.value = withRepeat(\n      withSequence(\n        withTiming(1, { duration: 4000, easing: Easing.inOut(Easing.ease) }),\n        withTiming(0, { duration: 4000, easing: Easing.inOut(Easing.ease) })\n      ),\n      -1,\n      false\n    );\n\n    floatAnim2.value = withDelay(1000, withRepeat(\n      withSequence(\n        withTiming(1, { duration: 5000, easing: Easing.inOut(Easing.ease) }),\n        withTiming(0, { duration: 5000, easing: Easing.inOut(Easing.ease) })\n      ),\n      -1,\n      false\n    ));\n\n    floatAnim3.value = withDelay(2000, withRepeat(\n      withSequence(\n        withTiming(1, { duration: 3500, easing: Easing.inOut(Easing.ease) }),\n        withTiming(0, { duration: 3500, easing: Easing.inOut(Easing.ease) })\n      ),\n      -1,\n      false\n    ));\n  }, []);\n\n  const dotPosition = useDerivedValue(() => {\n    return quadraticBezier(progress.value, startPoint, controlPoint, endPoint);\n  });\n\n  const dotStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: dotPosition.value.x - 14 },\n        { translateY: dotPosition.value.y - 14 },\n      ],\n    };\n  });\n\n  const trailDot1Style = useAnimatedStyle(() => {\n    const trailProgress = Math.max(0, progress.value - 0.06);\n    const pos = quadraticBezier(trailProgress, startPoint, controlPoint, endPoint);\n    return {\n      transform: [\n        { translateX: pos.x - 8 },\n        { translateY: pos.y - 8 },\n      ],\n      opacity: 0.6,\n    };\n  });\n\n  const trailDot2Style = useAnimatedStyle(() => {\n    const trailProgress = Math.max(0, progress.value - 0.12);\n    const pos = quadraticBezier(trailProgress, startPoint, controlPoint, endPoint);\n    return {\n      transform: [\n        { translateX: pos.x - 5 },\n        { translateY: pos.y - 5 },\n      ],\n      opacity: 0.35,\n    };\n  });\n\n  const trailDot3Style = useAnimatedStyle(() => {\n    const trailProgress = Math.max(0, progress.value - 0.18);\n    const pos = quadraticBezier(trailProgress, startPoint, controlPoint, endPoint);\n    return {\n      transform: [\n        { translateX: pos.x - 3 },\n        { translateY: pos.y - 3 },\n      ],\n      opacity: 0.15,\n    };\n  });\n\n  const fadeStyle = useAnimatedStyle(() => ({\n    opacity: fadeIn.value,\n  }));\n\n  const logoFadeStyle = useAnimatedStyle(() => ({\n    opacity: interpolate(fadeIn.value, [0, 1], [0, 1]),\n    transform: [\n      { translateY: interpolate(fadeIn.value, [0, 1], [30, 0]) },\n    ],\n  }));\n\n  const curvePathStyle = useAnimatedStyle(() => ({\n    opacity: interpolate(fadeIn.value, [0, 1], [0, 0.2]),\n  }));\n\n  const floatingCircle1Style = useAnimatedStyle(() => ({\n    transform: [\n      { translateY: interpolate(floatAnim1.value, [0, 1], [0, -20]) },\n      { scale: interpolate(floatAnim1.value, [0, 1], [1, 1.1]) },\n    ],\n    opacity: interpolate(fadeIn.value, [0, 1], [0, 0.08]),\n  }));\n\n  const floatingCircle2Style = useAnimatedStyle(() => ({\n    transform: [\n      { translateY: interpolate(floatAnim2.value, [0, 1], [0, 15]) },\n      { scale: interpolate(floatAnim2.value, [0, 1], [1, 0.9]) },\n    ],\n    opacity: interpolate(fadeIn.value, [0, 1], [0, 0.06]),\n  }));\n\n  const floatingCircle3Style = useAnimatedStyle(() => ({\n    transform: [\n      { translateY: interpolate(floatAnim3.value, [0, 1], [0, -12]) },\n      { translateX: interpolate(floatAnim3.value, [0, 1], [0, 8]) },\n    ],\n    opacity: interpolate(fadeIn.value, [0, 1], [0, 0.05]),\n  }));\n\n  const handleSocialAuthResult = async (result: any, provider: 'apple' | 'google') => {\n    console.log('[WelcomeScreen] handleSocialAuthResult called with:', JSON.stringify(result, null, 2));\n    if (result.success && result.userId) {\n      console.log('[WelcomeScreen] Success! needsName:', result.needsName, 'needsPhone:', result.needsPhoneVerification, 'needsDOB:', result.needsDOB);\n      \n      // Use RootNavigation (app-level navigation ref) for reliable navigation after OAuth browser return\n      // This is the standard pattern for navigating from OAuth callbacks\n      \n      if (result.needsName) {\n        console.log('[WelcomeScreen] Using RootNavigation to navigate to SocialSignupName');\n        RootNavigation.navigate('SocialSignupName', {\n          userId: result.userId,\n          email: result.email,\n          provider,\n          needsPhone: result.needsPhoneVerification,\n          needsDOB: result.needsDOB,\n          existingPhone: result.existingPhone,\n        });\n        // Clear overlay after navigation\n        setTimeout(() => clearSignupOverlay(), 100);\n      } else if (result.needsPhoneVerification) {\n        console.log('[WelcomeScreen] Using RootNavigation to navigate to SocialSignupPhone');\n        RootNavigation.navigate('SocialSignupPhone', {\n          userId: result.userId,\n          email: result.email,\n          fullName: result.fullName,\n          provider,\n        });\n        // Clear overlay after navigation\n        setTimeout(() => clearSignupOverlay(), 100);\n      } else if (result.needsDOB) {\n        console.log('[WelcomeScreen] Using RootNavigation to navigate to SocialSignupDOB');\n        RootNavigation.navigate('SocialSignupDOB', {\n          userId: result.userId,\n          fullName: result.fullName,\n          provider,\n          phone: result.existingPhone,\n        });\n        // Clear overlay after navigation\n        setTimeout(() => clearSignupOverlay(), 100);\n      } else {\n        console.log('[WelcomeScreen] Profile complete, refreshing user');\n        await refreshUser();\n      }\n    } else {\n      console.log('[WelcomeScreen] Auth failed or no userId:', result.error);\n      setSocialSignupInProgress(false);\n      if (result.error && result.error !== 'Sign-in was cancelled' && result.error !== 'Google Sign-In was cancelled') {\n        Alert.alert('Sign-In Failed', result.error);\n      }\n    }\n  };\n\n  const handleAppleSignIn = async () => {\n    setAppleLoading(true);\n    setSocialSignupInProgress(true);\n    try {\n      const result = await SocialAuthService.signInWithApple();\n      await handleSocialAuthResult(result, 'apple');\n    } catch (error: any) {\n      setSocialSignupInProgress(false);\n      Alert.alert('Error', error.message || 'Apple Sign-In failed');\n    } finally {\n      setAppleLoading(false);\n    }\n  };\n\n  const handleGoogleSignIn = async () => {\n    setGoogleLoading(true);\n    setSocialSignupInProgress(true);\n    try {\n      const result = await SocialAuthService.signInWithGoogle();\n      await handleSocialAuthResult(result, 'google');\n    } catch (error: any) {\n      setSocialSignupInProgress(false);\n      Alert.alert('Error', error.message || 'Google Sign-In failed');\n    } finally {\n      setGoogleLoading(false);\n    }\n  };\n\n  const generateCurvePoints = () => {\n    const points = [];\n    for (let i = 0; i <= 40; i++) {\n      const t = i / 40;\n      const pos = quadraticBezier(t, startPoint, controlPoint, endPoint);\n      points.push(pos);\n    }\n    return points;\n  };\n\n  const curvePoints = generateCurvePoints();\n\n  return (\n    <View style={[styles.container, { backgroundColor: theme.backgroundRoot }]}>\n      <Animated.View style={[styles.floatingCircle1, { backgroundColor: Colors.light.primary }, floatingCircle1Style]} />\n      <Animated.View style={[styles.floatingCircle2, { backgroundColor: Colors.light.primary }, floatingCircle2Style]} />\n      <Animated.View style={[styles.floatingCircle3, { backgroundColor: Colors.light.primary }, floatingCircle3Style]} />\n\n\n      <View style={StyleSheet.absoluteFill}>\n        <Animated.View style={curvePathStyle}>\n          {curvePoints.map((point, index) => (\n            <View\n              key={index}\n              style={[\n                styles.curvePoint,\n                {\n                  left: point.x - 2.5,\n                  top: point.y - 2.5,\n                  backgroundColor: Colors.light.primary,\n                },\n              ]}\n            />\n          ))}\n        </Animated.View>\n\n        <Animated.View style={[styles.trailDot3, { backgroundColor: Colors.light.primary }, trailDot3Style]} />\n        <Animated.View style={[styles.trailDot2, { backgroundColor: Colors.light.primary }, trailDot2Style]} />\n        <Animated.View style={[styles.trailDot1, { backgroundColor: Colors.light.primary }, trailDot1Style]} />\n        <Animated.View style={[styles.dot, { backgroundColor: Colors.light.primary }, dotStyle]}>\n          <View style={styles.dotInner} />\n        </Animated.View>\n      </View>\n\n      <Animated.View style={[styles.content, { paddingTop: insets.top + Spacing['2xl'] }, logoFadeStyle]}>\n        <View style={styles.logoContainer}>\n          <View style={styles.logoTextContainer}>\n            <ThemedText style={[styles.logoText, { color: Colors.light.primary }]}>\n              Sp\n            </ThemedText>\n            <ThemedText style={[styles.logoText, { color: theme.text }]}>\n              line\n            </ThemedText>\n          </View>\n          <View style={styles.logoUnderline}>\n            <View style={[styles.underlineSegment, { backgroundColor: Colors.light.primary }]} />\n            <View style={[styles.underlineDot, { backgroundColor: Colors.light.primary }]} />\n          </View>\n          <ThemedText style={[Typography.body, styles.tagline, { color: theme.textSecondary }]}>\n            Split bills effortlessly with friends\n          </ThemedText>\n        </View>\n      </Animated.View>\n\n      <Animated.View style={[styles.buttonContainer, { paddingBottom: insets.bottom + Spacing['2xl'] }, fadeStyle]}>\n        {showAppleButton ? (\n          <Pressable\n            style={({ pressed }) => [\n              styles.socialButton,\n              { backgroundColor: '#000000', opacity: pressed || appleLoading ? 0.8 : 1 }\n            ]}\n            onPress={handleAppleSignIn}\n            disabled={appleLoading || googleLoading}\n          >\n            {appleLoading ? (\n              <ActivityIndicator color=\"#FFFFFF\" size=\"small\" />\n            ) : (\n              <>\n                <Feather name=\"smartphone\" size={20} color=\"#FFFFFF\" style={styles.buttonIcon} />\n                <ThemedText style={[Typography.body, { color: '#FFFFFF', fontWeight: '600' }]}>\n                  Continue with Apple\n                </ThemedText>\n              </>\n            )}\n          </Pressable>\n        ) : null}\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.socialButton,\n            { backgroundColor: '#FFFFFF', borderWidth: 1, borderColor: theme.border, opacity: pressed || googleLoading ? 0.8 : 1 }\n          ]}\n          onPress={handleGoogleSignIn}\n          disabled={appleLoading || googleLoading}\n        >\n          {googleLoading ? (\n            <ActivityIndicator color=\"#4285F4\" size=\"small\" />\n          ) : (\n            <>\n              <View style={styles.googleIconContainer}>\n                <ThemedText style={{ color: '#4285F4', fontWeight: '700', fontSize: 16 }}>G</ThemedText>\n              </View>\n              <ThemedText style={[Typography.body, { color: '#333333', fontWeight: '600' }]}>\n                Continue with Google\n              </ThemedText>\n            </>\n          )}\n        </Pressable>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.socialButton,\n            { \n              backgroundColor: theme.surface, \n              borderWidth: 1,\n              borderColor: theme.border,\n              opacity: pressed ? 0.8 : 1 \n            }\n          ]}\n          onPress={() => navigation.navigate('SignupFirstName')}\n          disabled={appleLoading || googleLoading}\n        >\n          <Feather name=\"mail\" size={20} color={theme.text} style={styles.buttonIcon} />\n          <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n            Continue with Email\n          </ThemedText>\n        </Pressable>\n\n        <Pressable\n          style={styles.loginLink}\n          onPress={() => navigation.navigate('Login')}\n          disabled={appleLoading || googleLoading}\n        >\n          <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n            Already have an account?{' '}\n          </ThemedText>\n          <ThemedText style={[Typography.body, { color: Colors.light.primary, fontWeight: '600' }]}>\n            Login\n          </ThemedText>\n        </Pressable>\n      </Animated.View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  floatingCircle1: {\n    position: 'absolute',\n    top: '15%',\n    left: '10%',\n    width: 180,\n    height: 180,\n    borderRadius: 90,\n  },\n  floatingCircle2: {\n    position: 'absolute',\n    top: '55%',\n    right: '-10%',\n    width: 220,\n    height: 220,\n    borderRadius: 110,\n  },\n  floatingCircle3: {\n    position: 'absolute',\n    bottom: '20%',\n    left: '-5%',\n    width: 140,\n    height: 140,\n    borderRadius: 70,\n  },\n  curvePoint: {\n    position: 'absolute',\n    width: 5,\n    height: 5,\n    borderRadius: 2.5,\n  },\n  dot: {\n    position: 'absolute',\n    width: 28,\n    height: 28,\n    borderRadius: 14,\n    justifyContent: 'center',\n    alignItems: 'center',\n    ...Platform.select({\n      ios: {\n        shadowColor: Colors.light.primary,\n        shadowOffset: { width: 0, height: 0 },\n        shadowOpacity: 0.7,\n        shadowRadius: 10,\n      },\n      android: {\n        elevation: 10,\n      },\n      default: {},\n    }),\n  },\n  dotInner: {\n    width: 12,\n    height: 12,\n    borderRadius: 6,\n    backgroundColor: '#FFFFFF',\n  },\n  trailDot1: {\n    position: 'absolute',\n    width: 16,\n    height: 16,\n    borderRadius: 8,\n  },\n  trailDot2: {\n    position: 'absolute',\n    width: 10,\n    height: 10,\n    borderRadius: 5,\n  },\n  trailDot3: {\n    position: 'absolute',\n    width: 6,\n    height: 6,\n    borderRadius: 3,\n  },\n  content: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  logoContainer: {\n    alignItems: 'center',\n    marginTop: Spacing.xl,\n  },\n  logoTextContainer: {\n    flexDirection: 'row',\n    alignItems: 'baseline',\n  },\n  logoText: {\n    fontSize: 56,\n    fontWeight: '700',\n    letterSpacing: -1,\n  },\n  logoUnderline: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginTop: Spacing.xs,\n    gap: 6,\n  },\n  underlineSegment: {\n    width: 60,\n    height: 4,\n    borderRadius: 2,\n  },\n  underlineDot: {\n    width: 8,\n    height: 8,\n    borderRadius: 4,\n  },\n  tagline: {\n    marginTop: Spacing.lg,\n    textAlign: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  buttonContainer: {\n    paddingHorizontal: Spacing.xl,\n    gap: Spacing.md,\n  },\n  socialButton: {\n    height: Spacing.buttonHeight + 4,\n    borderRadius: BorderRadius.sm,\n    flexDirection: 'row',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  buttonIcon: {\n    marginRight: Spacing.sm,\n  },\n  googleIconContainer: {\n    width: 20,\n    height: 20,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginRight: Spacing.sm,\n  },\n  loginLink: {\n    flexDirection: 'row',\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingVertical: Spacing.md,\n    marginTop: Spacing.xs,\n  },\n});\n","path":null,"size_bytes":17713,"size_tokens":null},"services/supabaseAdmin.ts":{"content":"import { createClient, SupabaseClient } from '@supabase/supabase-js';\nimport { supabase } from './supabase';\n\n// Direct Supabase URL for admin client\nconst supabaseUrl = 'https://vhicohutiocnfjwsofhy.supabase.co';\nconst supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY || '';\n\nlet adminClient: SupabaseClient;\n\nif (supabaseServiceRoleKey && supabaseServiceRoleKey.length > 0) {\n  adminClient = createClient(supabaseUrl, supabaseServiceRoleKey, {\n    auth: {\n      autoRefreshToken: false,\n      persistSession: false,\n    },\n  });\n} else {\n  console.warn('SUPABASE_SERVICE_ROLE_KEY not available, using regular client for admin operations');\n  adminClient = supabase;\n}\n\nexport const supabaseAdmin = adminClient;\n","path":null,"size_bytes":727,"size_tokens":null},"services/backendNotifications.service.ts":{"content":"import Constants from 'expo-constants';\nimport { Platform } from 'react-native';\nimport { supabase } from './supabase';\n\ninterface NotificationPayload {\n  user_id: string;\n  type: string;\n  title: string;\n  message: string;\n  metadata?: Record<string, any>;\n  split_event_id?: string;\n  friendship_id?: string;\n}\n\nconst getBackendUrl = (): string => {\n  const extra = Constants.expoConfig?.extra || {};\n  return extra.backendUrl || process.env.EXPO_PUBLIC_BACKEND_URL || 'http://localhost:8082';\n};\n\nconst isBackendAccessible = (): boolean => {\n  if (Platform.OS !== 'web') {\n    return false;\n  }\n  return true;\n};\n\nexport class BackendNotificationsService {\n  /**\n   * Create a notification using the Express backend server\n   * Falls back to Supabase RPC if backend is not accessible\n   */\n  static async createNotification(payload: NotificationPayload): Promise<{ success: boolean; notification?: any; error?: string }> {\n    if (!isBackendAccessible()) {\n      return await this.createNotificationViaSupabase(payload);\n    }\n    \n    try {\n      const backendUrl = getBackendUrl();\n      const response = await fetch(`${backendUrl}/api/notifications/create`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          user_id: payload.user_id,\n          type: payload.type,\n          title: payload.title,\n          message: payload.message,\n          metadata: payload.metadata || {},\n          split_event_id: payload.split_event_id || null,\n          friendship_id: payload.friendship_id || null,\n        }),\n      });\n\n      const contentType = response.headers.get('content-type');\n      if (contentType && contentType.includes('text/html')) {\n        return await this.createNotificationViaSupabase(payload);\n      }\n\n      if (!response.ok) {\n        return await this.createNotificationViaSupabase(payload);\n      }\n\n      const data = await response.json();\n      \n      if (data.success) {\n        return { success: true, notification: data.notification };\n      } else {\n        return await this.createNotificationViaSupabase(payload);\n      }\n    } catch (error: any) {\n      return await this.createNotificationViaSupabase(payload);\n    }\n  }\n\n  /**\n   * Fallback: Create notification via Supabase RPC\n   */\n  private static async createNotificationViaSupabase(payload: NotificationPayload): Promise<{ success: boolean; notification?: any; error?: string }> {\n    try {\n      console.log('Attempting notification creation via Supabase RPC for user:', payload.user_id);\n      \n      const { data, error } = await supabase.rpc('create_notification_v2', {\n        p_user_id: payload.user_id,\n        p_type: payload.type,\n        p_title: payload.title,\n        p_message: payload.message,\n        p_metadata: payload.metadata || {},\n        p_split_event_id: payload.split_event_id || null,\n        p_friendship_id: payload.friendship_id || null,\n      });\n\n      if (error) {\n        console.error('Supabase RPC error:', error);\n        // Final fallback: try direct insert (may fail due to RLS)\n        return await this.createNotificationDirect(payload);\n      }\n\n      if (data && data.success) {\n        console.log('Notification created successfully via Supabase RPC');\n        return { success: true, notification: data.notification };\n      } else {\n        console.error('RPC returned error:', data?.error);\n        return await this.createNotificationDirect(payload);\n      }\n    } catch (error: any) {\n      console.error('Failed to call Supabase RPC:', error);\n      return await this.createNotificationDirect(payload);\n    }\n  }\n\n  /**\n   * Final fallback: Direct insert (may fail if user doesn't own the notification)\n   */\n  private static async createNotificationDirect(payload: NotificationPayload): Promise<{ success: boolean; notification?: any; error?: string }> {\n    try {\n      console.log('Attempting direct notification insert for user:', payload.user_id);\n      \n      const { data, error } = await supabase.from('notifications').insert({\n        user_id: payload.user_id,\n        type: payload.type,\n        title: payload.title,\n        message: payload.message,\n        metadata: payload.metadata || {},\n        split_event_id: payload.split_event_id || null,\n        friendship_id: payload.friendship_id || null,\n        read: false,\n      }).select().single();\n\n      if (error) {\n        console.error('Direct insert error:', error);\n        return { success: false, error: error.message };\n      }\n\n      console.log('Notification created successfully via direct insert');\n      return { success: true, notification: data };\n    } catch (error: any) {\n      console.error('Failed direct notification insert:', error);\n      return { success: false, error: error.message || 'Failed to create notification' };\n    }\n  }\n}\n","path":null,"size_bytes":4854,"size_tokens":null},"server/routes/notifications.routes.ts":{"content":"import express from 'express';\nimport { createClient } from '@supabase/supabase-js';\n\nconst router = express.Router();\n\nconst supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || '';\nconst supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY || '';\n\nconst supabaseAdmin = createClient(supabaseUrl, supabaseServiceRoleKey, {\n  auth: {\n    autoRefreshToken: false,\n    persistSession: false,\n  },\n});\n\nrouter.post('/create', async (req, res) => {\n  try {\n    const { user_id, type, title, message, metadata, split_event_id, friendship_id } = req.body;\n\n    if (!user_id || !type || !title || !message) {\n      return res.status(400).json({ error: 'Missing required fields' });\n    }\n\n    console.log('Creating notification for user:', user_id, 'type:', type);\n\n    const { data, error } = await supabaseAdmin.from('notifications').insert({\n      user_id,\n      type,\n      title,\n      message,\n      metadata: metadata || {},\n      split_event_id: split_event_id || null,\n      friendship_id: friendship_id || null,\n      read: false,\n    }).select().single();\n\n    if (error) {\n      console.error('Failed to create notification:', error);\n      return res.status(500).json({ error: error.message });\n    }\n\n    console.log('Notification created successfully:', data.id);\n    res.json({ success: true, notification: data });\n  } catch (error: any) {\n    console.error('Notification creation error:', error);\n    res.status(500).json({ error: error.message || 'Failed to create notification' });\n  }\n});\n\n// Create a test user in Supabase (for testing purposes)\nrouter.post('/test-user', async (req, res) => {\n  try {\n    const { name, email, unique_id } = req.body;\n\n    if (!name || !email || !unique_id) {\n      return res.status(400).json({ error: 'Missing required fields: name, email, unique_id' });\n    }\n\n    console.log('Creating test user with unique_id:', unique_id);\n\n    const { data, error } = await supabaseAdmin.from('users').insert({\n      name,\n      email,\n      unique_id,\n    }).select().single();\n\n    if (error) {\n      console.error('Failed to create test user:', error);\n      return res.status(500).json({ error: error.message });\n    }\n\n    console.log('Test user created successfully:', data.id);\n    res.json({ success: true, user: data });\n  } catch (error: any) {\n    console.error('Test user creation error:', error);\n    res.status(500).json({ error: error.message || 'Failed to create test user' });\n  }\n});\n\n// Lookup user by unique_id (for testing purposes)\nrouter.get('/lookup-user/:unique_id', async (req, res) => {\n  try {\n    const { unique_id } = req.params;\n\n    console.log('Looking up user with unique_id:', unique_id);\n\n    const { data, error } = await supabaseAdmin\n      .from('users')\n      .select('id, name, unique_id')\n      .eq('unique_id', unique_id)\n      .maybeSingle();\n\n    if (error) {\n      console.error('User lookup error:', error);\n      return res.status(500).json({ error: error.message });\n    }\n\n    if (!data) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n\n    res.json({ success: true, user: data });\n  } catch (error: any) {\n    console.error('User lookup error:', error);\n    res.status(500).json({ error: error.message || 'Failed to lookup user' });\n  }\n});\n\nexport default router;\n","path":null,"size_bytes":3290,"size_tokens":null},"screens/PrivacyPolicyScreen.tsx":{"content":"import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenScrollView } from '@/components/ScreenScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Spacing, Typography } from '@/constants/theme';\n\ntype Props = NativeStackScreenProps<any, 'PrivacyPolicy'>;\n\nexport default function PrivacyPolicyScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n\n  return (\n    <ScreenScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.xl }]}>\n          Privacy Policy\n        </ThemedText>\n\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Last updated: November 2024\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          1. Introduction\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          KNH Group (\"we\", \"us\", or \"our\") operates Spline Payment (the \"App\"). This Privacy Policy explains how we collect, use, disclose, and safeguard your information when you use our App. By using Spline Payment, you consent to the data practices described in this policy.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          2. Information We Collect\n        </ThemedText>\n        <ThemedText style={[styles.subTitle, { color: theme.text }]}>\n          Personal Information\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          When you create an account, we collect your name, email address, phone number, date of birth, and profile picture. This information is necessary to provide our services and verify your identity.\n        </ThemedText>\n        <ThemedText style={[styles.subTitle, { color: theme.text }]}>\n          Financial Information\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          To facilitate payments, we collect bank account information through our payment partner BlinkPay. We store transaction history, wallet balances, and payment preferences to provide our bill-splitting services.\n        </ThemedText>\n        <ThemedText style={[styles.subTitle, { color: theme.text }]}>\n          Usage Data\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          We automatically collect information about how you interact with the App, including device information, IP address, app usage patterns, and crash reports. This helps us improve our services.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          3. How We Use Your Information\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          We use the collected information to provide and maintain the App's functionality, process transactions and manage your wallet, connect you with friends for bill splitting, send notifications about split requests and payments, improve and personalize your experience, comply with legal obligations and prevent fraud, and communicate important updates about our services.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          4. Information Sharing\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          We may share your information with payment processors such as BlinkPay to facilitate transactions, other users as necessary for bill splitting such as your name and profile picture, service providers who assist in operating our App, and legal authorities when required by law or to protect our rights.\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          We do not sell your personal information to third parties for marketing purposes.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          5. Data Security\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          We implement industry-standard security measures to protect your information, including encryption of data in transit and at rest, secure authentication protocols, regular security audits and monitoring, and limited access to personal data by authorized personnel only.\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          However, no method of electronic transmission or storage is 100% secure. While we strive to protect your information, we cannot guarantee absolute security.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          6. Data Retention\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          We retain your personal information for as long as your account is active or as needed to provide services. We may retain certain information as required by law, to resolve disputes, or enforce our agreements. Transaction records may be kept for up to 7 years for legal and regulatory compliance.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          7. Your Rights\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          Depending on your location, you may have the right to access the personal information we hold about you, request correction of inaccurate information, request deletion of your information, object to or restrict certain processing activities, receive your data in a portable format, and withdraw consent where processing is based on consent.\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          To exercise these rights, please contact us at admin@spline.nz.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          8. Push Notifications\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          With your permission, we send push notifications about split requests, payment updates, and friend activity. You can manage notification preferences in your device settings at any time.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          9. Children's Privacy\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          The App is not intended for users under 18 years of age. We do not knowingly collect personal information from children. If we discover that we have collected information from a child, we will promptly delete it.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          10. International Data Transfers\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          Your information may be transferred to and processed in countries other than New Zealand. We ensure appropriate safeguards are in place to protect your information in accordance with this Privacy Policy.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          11. Changes to This Policy\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          We may update this Privacy Policy from time to time. We will notify you of significant changes through the App or via email. The \"Last updated\" date at the top of this policy indicates when it was last revised.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          12. Contact Us\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          If you have questions or concerns about this Privacy Policy or our data practices, please contact us at:\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.primary }]}>\n          admin@spline.nz\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          KNH Group{'\\n'}\n          New Zealand\n        </ThemedText>\n      </ThemedView>\n    </ScreenScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.xl,\n  },\n  sectionTitle: {\n    fontSize: 16,\n    fontWeight: '600',\n    marginTop: Spacing.lg,\n    marginBottom: Spacing.sm,\n  },\n  subTitle: {\n    fontSize: 14,\n    fontWeight: '600',\n    marginTop: Spacing.sm,\n    marginBottom: Spacing.xs,\n  },\n  paragraph: {\n    fontSize: 14,\n    lineHeight: 22,\n    marginBottom: Spacing.md,\n  },\n});\n","path":null,"size_bytes":9343,"size_tokens":null},"screens/TermsScreen.tsx":{"content":"import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenScrollView } from '@/components/ScreenScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Spacing, Typography } from '@/constants/theme';\n\ntype Props = NativeStackScreenProps<any, 'Terms'>;\n\nexport default function TermsScreen({ navigation }: Props) {\n  const { theme } = useTheme();\n\n  return (\n    <ScreenScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.xl }]}>\n          Terms and Conditions\n        </ThemedText>\n\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Last updated: November 2024\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          1. Agreement to Terms\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          By accessing or using Spline Payment (\"the App\"), operated by KNH Group, you agree to be bound by these Terms and Conditions. If you do not agree to these terms, please do not use the App.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          2. Description of Service\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          Spline Payment is a mobile application that enables users to split bills, manage shared expenses, and facilitate payments between friends. The App provides tools for creating split events, tracking payments, and managing a digital wallet for seamless transactions.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          3. User Accounts\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          To use the App, you must create an account by providing accurate and complete information. You are responsible for maintaining the confidentiality of your account credentials and for all activities that occur under your account. You must be at least 18 years old to use this service.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          4. Payment Services\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          The App integrates with BlinkPay for payment processing. By using payment features, you authorize KNH Group to initiate transactions on your behalf. All payment transactions are subject to the terms and conditions of our payment partners. Funds deposited into your Spline wallet are held in a business bank account, and in-app transfers between users are recorded as ledger entries until withdrawn.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          5. User Conduct\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          You agree not to use the App for any unlawful purpose, to harass or abuse other users, to attempt to gain unauthorized access to other accounts, to engage in fraudulent transactions, or to violate any applicable laws or regulations.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          6. Fees and Charges\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          While the basic features of the App are free to use, certain transactions may incur fees. Any applicable fees will be clearly disclosed before you complete a transaction. KNH Group reserves the right to modify fee structures with reasonable notice to users.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          7. Intellectual Property\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          All content, features, and functionality of the App, including but not limited to text, graphics, logos, and software, are the exclusive property of KNH Group and are protected by copyright, trademark, and other intellectual property laws.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          8. Limitation of Liability\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          To the maximum extent permitted by law, KNH Group shall not be liable for any indirect, incidental, special, consequential, or punitive damages arising from your use of the App. Our total liability shall not exceed the amount of fees paid by you in the twelve months preceding the claim.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          9. Dispute Resolution\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          Any disputes arising from these terms or your use of the App shall be resolved through good faith negotiation. If a resolution cannot be reached, disputes shall be submitted to binding arbitration in New Zealand under the Arbitration Act 1996.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          10. Termination\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          KNH Group reserves the right to suspend or terminate your account at any time for violation of these terms or for any other reason at our sole discretion. Upon termination, you must cease all use of the App and any outstanding wallet balance will be returned to you within a reasonable timeframe.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          11. Changes to Terms\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          We may update these Terms and Conditions from time to time. We will notify you of any material changes through the App or via email. Your continued use of the App after such changes constitutes acceptance of the updated terms.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.text }]}>\n          12. Contact Information\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary }]}>\n          If you have any questions about these Terms and Conditions, please contact us at:\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.primary }]}>\n          admin@spline.nz\n        </ThemedText>\n        <ThemedText style={[styles.paragraph, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          KNH Group{'\\n'}\n          New Zealand\n        </ThemedText>\n      </ThemedView>\n    </ScreenScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.xl,\n  },\n  sectionTitle: {\n    fontSize: 16,\n    fontWeight: '600',\n    marginTop: Spacing.lg,\n    marginBottom: Spacing.sm,\n  },\n  paragraph: {\n    fontSize: 14,\n    lineHeight: 22,\n    marginBottom: Spacing.md,\n  },\n});\n","path":null,"size_bytes":7628,"size_tokens":null},"supabase/DEPLOY_EDGE_FUNCTIONS.md":{"content":"# Deploying BlinkPay Edge Functions to Supabase\n\nThese Edge Functions handle BlinkPay payment processing for the Spline app, replacing the need for a separate Express backend for payment operations.\n\n## Prerequisites\n\n1. **Supabase CLI** (version 1.150.0 or higher):\n   ```bash\n   npm install -g supabase\n   supabase --version  # Verify installation\n   ```\n\n2. **Supabase Account**: A Supabase project with Edge Functions enabled\n\n3. **BlinkPay Account**: Sandbox or production BlinkPay credentials\n   - Client ID\n   - Client Secret\n   - Sandbox: https://sandbox.debit.blinkpay.co.nz\n   - Production: https://debit.blinkpay.co.nz\n\n## Initial Setup\n\n### 1. Login to Supabase CLI\n```bash\nsupabase login\n```\n\n### 2. Link Your Project\n```bash\n# Get your project reference from Supabase dashboard\nsupabase link --project-ref YOUR_PROJECT_REF\n```\n\n### 3. Configure BlinkPay Secrets\n```bash\n# Set BlinkPay credentials (required)\nsupabase secrets set BLINKPAY_CLIENT_ID=your_client_id\nsupabase secrets set BLINKPAY_CLIENT_SECRET=your_client_secret\n\n# Verify secrets are set\nsupabase secrets list\n```\n\n## Deploy Functions\n\nDeploy both Edge Functions:\n\n```bash\n# Navigate to project root (where supabase/ folder exists)\ncd /path/to/project\n\n# Deploy consent function\nsupabase functions deploy blinkpay-consent --no-verify-jwt\n\n# Deploy payment function  \nsupabase functions deploy blinkpay-payment --no-verify-jwt\n```\n\nThe `--no-verify-jwt` flag allows the functions to be called from the mobile app without requiring a Supabase auth token (the functions handle their own authentication with BlinkPay).\n\n## Function URLs\n\nAfter deployment, your functions will be available at:\n- **Consent**: `https://YOUR_PROJECT_REF.supabase.co/functions/v1/blinkpay-consent`\n- **Payment**: `https://YOUR_PROJECT_REF.supabase.co/functions/v1/blinkpay-payment`\n\nThe mobile app automatically uses these URLs via `supabase.functions.invoke()`.\n\n## Function Endpoints\n\n### blinkpay-consent\nHandles bank connection consent management.\n\n**Create Consent** (Initiate bank connection):\n```json\nPOST /functions/v1/blinkpay-consent\n{\n  \"action\": \"create\",\n  \"redirectUri\": \"spline://wallet/callback\",\n  \"maxAmount\": \"1000.00\"\n}\n```\nResponse:\n```json\n{\n  \"consentId\": \"consent_abc123\",\n  \"redirectUri\": \"https://sandbox.debit.blinkpay.co.nz/...\"\n}\n```\n\n**Get Consent** (Check consent status):\n```json\nPOST /functions/v1/blinkpay-consent\n{\n  \"action\": \"get\",\n  \"consentId\": \"consent_abc123\"\n}\n```\nResponse:\n```json\n{\n  \"consent_id\": \"consent_abc123\",\n  \"bank_name\": \"ANZ Bank\",\n  \"account_reference\": \"****1234\",\n  \"status\": \"active\",\n  \"expires_at\": \"2026-01-01T00:00:00Z\"\n}\n```\n\n**Revoke Consent** (Disconnect bank):\n```json\nPOST /functions/v1/blinkpay-consent\n{\n  \"action\": \"revoke\",\n  \"consentId\": \"consent_abc123\"\n}\n```\nResponse:\n```json\n{\n  \"success\": true\n}\n```\n\n### blinkpay-payment\nHandles payment processing.\n\n**Create Payment**:\n```json\nPOST /functions/v1/blinkpay-payment\n{\n  \"action\": \"create\",\n  \"consentId\": \"consent_abc123\",\n  \"amount\": \"10.00\",\n  \"particulars\": \"Split Payment\",\n  \"reference\": \"SPLIT-123\"\n}\n```\nResponse:\n```json\n{\n  \"paymentId\": \"payment_xyz789\",\n  \"status\": \"pending\"\n}\n```\n\n**Check Payment Status** (with polling):\n```json\nPOST /functions/v1/blinkpay-payment\n{\n  \"action\": \"status\",\n  \"paymentId\": \"payment_xyz789\",\n  \"maxWaitSeconds\": 30\n}\n```\nResponse:\n```json\n{\n  \"paymentId\": \"payment_xyz789\",\n  \"status\": \"completed\"\n}\n```\n\n## App Configuration\n\n### Redirect URI Setup\nFor BlinkPay OAuth flow, configure the redirect URI in your app:\n\n1. **Development (Expo Go)**: Use deep link scheme\n   ```\n   spline://wallet/callback\n   ```\n\n2. **Production**: Use your production app's deep link\n   ```\n   spline://wallet/callback\n   ```\n\n### Environment Variables (Already Configured)\nThe mobile app uses these environment variables (already set in Supabase):\n- `EXPO_PUBLIC_SUPABASE_URL`: Your Supabase project URL\n- `EXPO_PUBLIC_SUPABASE_ANON_KEY`: Your Supabase anonymous key\n\n## Switching to Production\n\nFor production deployment:\n\n1. **Update BlinkPay URL** in both edge functions:\n   ```typescript\n   // Change from sandbox to production\n   const BLINKPAY_URL = 'https://debit.blinkpay.co.nz';\n   ```\n\n2. **Set production secrets**:\n   ```bash\n   supabase secrets set BLINKPAY_CLIENT_ID=your_production_client_id\n   supabase secrets set BLINKPAY_CLIENT_SECRET=your_production_client_secret\n   ```\n\n3. **Redeploy functions**:\n   ```bash\n   supabase functions deploy blinkpay-consent --no-verify-jwt\n   supabase functions deploy blinkpay-payment --no-verify-jwt\n   ```\n\n## Local Testing\n\nTo test locally before deploying:\n\n1. **Create `.env.local`**:\n   ```bash\n   BLINKPAY_CLIENT_ID=your_sandbox_client_id\n   BLINKPAY_CLIENT_SECRET=your_sandbox_client_secret\n   ```\n\n2. **Serve functions locally**:\n   ```bash\n   supabase functions serve --env-file .env.local\n   ```\n\n3. **Test endpoints**:\n   ```bash\n   curl -X POST http://localhost:54321/functions/v1/blinkpay-consent \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"action\": \"create\", \"redirectUri\": \"http://localhost:3000/callback\"}'\n   ```\n\n## Troubleshooting\n\n### Function Not Found\n- Verify deployment succeeded with `supabase functions list`\n- Check project reference is correct\n\n### Authentication Errors\n- Verify BlinkPay secrets are set: `supabase secrets list`\n- Confirm credentials are for correct environment (sandbox vs production)\n\n### CORS Errors\n- Functions include CORS headers for cross-origin requests\n- If issues persist, check function logs: `supabase functions logs blinkpay-consent`\n\n### Payment Failures\n- Check consent is still active (not expired/revoked)\n- Verify amount format (e.g., \"10.00\" not \"10\")\n- Review function logs for detailed error messages\n\n## Legacy Express Backend Cleanup\n\nAfter deploying Edge Functions successfully:\n\n1. The Express backend is still used for daily reminders service\n2. BlinkPay routes in Express (`/api/blinkpay/*`) are no longer needed\n3. The `EXPO_PUBLIC_BACKEND_URL` environment variable is no longer required for BlinkPay\n\n## Architecture Overview\n\n```\nMobile App (Expo)\n       |\n       v\nSupabase Client (supabase.functions.invoke)\n       |\n       v\nSupabase Edge Functions\n├── blinkpay-consent (create/get/revoke consent)\n└── blinkpay-payment (create payment/check status)\n       |\n       v\nBlinkPay API (sandbox or production)\n```\n\nThis architecture eliminates the need for port forwarding and works seamlessly in:\n- Expo Go on physical devices\n- Production App Store/Play Store builds\n- Web deployments\n","path":null,"size_bytes":6544,"size_tokens":null},"supabase/functions/blinkpay-consent/index.ts":{"content":"import { serve } from \"https://deno.land/std@0.168.0/http/server.ts\";\n\nconst BLINKPAY_SANDBOX_URL = 'https://sandbox.debit.blinkpay.co.nz';\n\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n  'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',\n};\n\ninterface TokenResponse {\n  access_token: string;\n  token_type: string;\n  expires_in: number;\n}\n\nasync function getAccessToken(): Promise<string> {\n  const clientId = Deno.env.get('BLINKPAY_CLIENT_ID');\n  const clientSecret = Deno.env.get('BLINKPAY_CLIENT_SECRET');\n\n  if (!clientId || !clientSecret) {\n    console.error('Missing credentials - clientId exists:', !!clientId, 'clientSecret exists:', !!clientSecret);\n    throw new Error('BlinkPay credentials not configured');\n  }\n\n  console.log('Attempting token request with clientId length:', clientId.length);\n\n  const response = await fetch(`${BLINKPAY_SANDBOX_URL}/oauth2/token`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      client_id: clientId,\n      client_secret: clientSecret,\n      grant_type: 'client_credentials'\n    }),\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error('Token error - status:', response.status, 'response:', error);\n    throw new Error('Failed to get BlinkPay access token');\n  }\n\n  const data: TokenResponse = await response.json();\n  console.log('Token obtained successfully');\n  return data.access_token;\n}\n\nasync function createEnduringConsent(redirectUri: string, maxAmount: string = '1000.00') {\n  const accessToken = await getAccessToken();\n  \n  const now = new Date();\n  const oneYearLater = new Date();\n  oneYearLater.setFullYear(now.getFullYear() + 1);\n\n  const request = {\n    flow: {\n      detail: {\n        type: 'gateway',\n        redirect_uri: redirectUri\n      }\n    },\n    maximum_amount_period: {\n      currency: 'NZD',\n      total: maxAmount\n    },\n    period: 'monthly',\n    from_timestamp: now.toISOString(),\n    expiry_timestamp: oneYearLater.toISOString()\n  };\n\n  console.log('Creating consent with request:', JSON.stringify(request));\n\n  const response = await fetch(`${BLINKPAY_SANDBOX_URL}/enduring-consents`, {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(request),\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error('Consent creation error:', error);\n    throw new Error(`Failed to create consent: ${error}`);\n  }\n\n  const data = await response.json();\n  console.log('Consent created:', data);\n  \n  return {\n    consentId: data.consent_id,\n    redirectUri: data.redirect_uri\n  };\n}\n\nasync function getEnduringConsent(consentId: string) {\n  const accessToken = await getAccessToken();\n\n  const response = await fetch(`${BLINKPAY_SANDBOX_URL}/enduring-consents/${consentId}`, {\n    method: 'GET',\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error('Get consent error:', error);\n    throw new Error(`Failed to get consent: ${error}`);\n  }\n\n  const data = await response.json();\n  console.log('Consent details from BlinkPay:', JSON.stringify(data));\n  \n  let bankName = 'Connected Bank';\n  let accountReference = '****';\n  \n  if (data.detail?.bank_reference_id) {\n    bankName = data.detail.bank_reference_id;\n  }\n  if (data.accounts && data.accounts.length > 0) {\n    const account = data.accounts[0];\n    bankName = account.bank?.bank_name || account.name || bankName;\n    accountReference = account.account_number ? \n      `****${account.account_number.slice(-4)}` : \n      account.account_reference || accountReference;\n  }\n  \n  return {\n    consent_id: consentId,\n    bank_name: bankName,\n    account_reference: accountReference,\n    status: data.status === 'Authorised' ? 'active' : \n            data.status === 'Revoked' ? 'revoked' : \n            data.status === 'Consumed' ? 'consumed' : 'expired',\n    expires_at: data.expiry_timestamp || ''\n  };\n}\n\nasync function revokeEnduringConsent(consentId: string) {\n  const accessToken = await getAccessToken();\n\n  const response = await fetch(`${BLINKPAY_SANDBOX_URL}/enduring-consents/${consentId}`, {\n    method: 'DELETE',\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error('Revoke consent error:', error);\n    throw new Error(`Failed to revoke consent: ${error}`);\n  }\n\n  return { success: true };\n}\n\nserve(async (req) => {\n  if (req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders });\n  }\n\n  try {\n    if (req.method !== 'POST') {\n      return new Response(\n        JSON.stringify({ error: 'Method not allowed' }),\n        { status: 405, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n      );\n    }\n\n    const body = await req.json();\n    const { action, redirectUri, maxAmount, consentId } = body;\n\n    console.log('BlinkPay Consent function called:', { action });\n\n    if (action === 'create') {\n      if (!redirectUri) {\n        return new Response(\n          JSON.stringify({ error: 'redirectUri is required' }),\n          { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n        );\n      }\n\n      const result = await createEnduringConsent(redirectUri, maxAmount);\n      return new Response(\n        JSON.stringify(result),\n        { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n      );\n    }\n\n    if (action === 'revoke') {\n      if (!consentId) {\n        return new Response(\n          JSON.stringify({ error: 'consentId is required' }),\n          { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n        );\n      }\n\n      const result = await revokeEnduringConsent(consentId);\n      return new Response(\n        JSON.stringify(result),\n        { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n      );\n    }\n\n    if (action === 'get') {\n      if (!consentId) {\n        return new Response(\n          JSON.stringify({ error: 'consentId is required' }),\n          { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n        );\n      }\n\n      const result = await getEnduringConsent(consentId);\n      return new Response(\n        JSON.stringify(result),\n        { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n      );\n    }\n\n    return new Response(\n      JSON.stringify({ error: 'Invalid action. Use create, get, or revoke' }),\n      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    );\n\n  } catch (error) {\n    console.error('BlinkPay consent error:', error);\n    return new Response(\n      JSON.stringify({ error: error.message || 'Internal server error' }),\n      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    );\n  }\n});\n","path":null,"size_bytes":7216,"size_tokens":null},"server/services/dailyReminder.service.ts":{"content":"import { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || '';\nconst supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY || '';\n\nconst supabaseAdmin = createClient(supabaseUrl, supabaseServiceRoleKey, {\n  auth: {\n    autoRefreshToken: false,\n    persistSession: false,\n  },\n});\n\ninterface UnpaidParticipant {\n  user_id: string;\n  total_pending: number;\n  event_count: number;\n  push_token: string | null;\n  user_name: string;\n}\n\nexport class DailyReminderService {\n  private static reminderInterval: NodeJS.Timeout | null = null;\n  private static readonly REMINDER_HOUR = 9;\n  private static lastReminderDate: string | null = null;\n\n  static async start(): Promise<void> {\n    console.log('Daily reminder service starting...');\n    \n    this.checkAndSendReminders();\n    \n    this.reminderInterval = setInterval(() => {\n      this.checkAndSendReminders();\n    }, 60 * 60 * 1000);\n    \n    console.log('Daily reminder service started - will check hourly and send at 9 AM');\n  }\n\n  static stop(): void {\n    if (this.reminderInterval) {\n      clearInterval(this.reminderInterval);\n      this.reminderInterval = null;\n      console.log('Daily reminder service stopped');\n    }\n  }\n\n  private static async checkAndSendReminders(): Promise<void> {\n    const now = new Date();\n    const currentHour = now.getHours();\n    const today = now.toISOString().split('T')[0];\n\n    if (currentHour === this.REMINDER_HOUR && this.lastReminderDate !== today) {\n      console.log(`Sending daily reminders at ${now.toISOString()}`);\n      await this.sendDailyReminders();\n      this.lastReminderDate = today;\n    }\n  }\n\n  static async sendDailyReminders(): Promise<void> {\n    try {\n      console.log('Fetching users with unpaid splits...');\n\n      const { data: unpaidParticipants, error } = await supabaseAdmin\n        .from('split_participants')\n        .select(`\n          user_id,\n          amount,\n          status,\n          is_creator,\n          split_events!inner (\n            id,\n            name,\n            creator_id\n          )\n        `)\n        .in('status', ['pending', 'accepted'])\n        .eq('is_creator', false);\n\n      if (error) {\n        console.error('Error fetching unpaid participants:', error);\n        return;\n      }\n\n      if (!unpaidParticipants || unpaidParticipants.length === 0) {\n        console.log('No users with unpaid splits found');\n        return;\n      }\n\n      // Get unique user IDs\n      const userIds = [...new Set(unpaidParticipants.map(p => p.user_id))];\n      \n      // Fetch user details separately - using * to get all columns\n      const { data: users, error: usersError } = await supabaseAdmin\n        .from('users')\n        .select('*')\n        .in('id', userIds);\n\n      if (usersError) {\n        console.error('Error fetching user details:', usersError);\n        // Continue without user details rather than returning\n        console.log('Continuing with limited user info');\n      }\n\n      const usersMap = new Map(users?.map(u => [u.id, u]) || []);\n\n      const userSummaries = new Map<string, {\n        userId: string;\n        userName: string;\n        pushToken: string | null;\n        totalAmount: number;\n        eventCount: number;\n        eventNames: string[];\n      }>();\n\n      for (const participant of unpaidParticipants) {\n        const userId = participant.user_id;\n        const user = usersMap.get(userId);\n        const event = participant.split_events as any;\n\n        if (!userSummaries.has(userId)) {\n          userSummaries.set(userId, {\n            userId,\n            userName: user?.name || 'User',\n            pushToken: user?.push_token || null,\n            totalAmount: 0,\n            eventCount: 0,\n            eventNames: [],\n          });\n        }\n\n        const summary = userSummaries.get(userId)!;\n        summary.totalAmount += parseFloat(participant.amount) || 0;\n        summary.eventCount += 1;\n        if (event?.name && !summary.eventNames.includes(event.name)) {\n          summary.eventNames.push(event.name);\n        }\n      }\n\n      console.log(`Found ${userSummaries.size} users with unpaid splits`);\n\n      for (const [userId, summary] of userSummaries) {\n        await this.sendReminderToUser(summary);\n      }\n\n      console.log('Daily reminders sent successfully');\n    } catch (error) {\n      console.error('Error sending daily reminders:', error);\n    }\n  }\n\n  private static async sendReminderToUser(summary: {\n    userId: string;\n    userName: string;\n    pushToken: string | null;\n    totalAmount: number;\n    eventCount: number;\n    eventNames: string[];\n  }): Promise<void> {\n    const { userId, userName, pushToken, totalAmount, eventCount, eventNames } = summary;\n\n    const title = 'Payment Reminder';\n    const eventList = eventNames.length <= 2 \n      ? eventNames.join(' and ')\n      : `${eventNames.slice(0, 2).join(', ')} and ${eventNames.length - 2} more`;\n    \n    const message = eventCount === 1\n      ? `Hi ${userName}, you have $${totalAmount.toFixed(2)} pending for \"${eventList}\". Tap to pay now!`\n      : `Hi ${userName}, you have $${totalAmount.toFixed(2)} pending across ${eventCount} splits (${eventList}). Tap to settle up!`;\n\n    try {\n      // Check if user already received a payment reminder today (regardless of read status)\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      const { count: existingCount } = await supabaseAdmin\n        .from('notifications')\n        .select('id', { count: 'exact', head: true })\n        .eq('user_id', userId)\n        .eq('type', 'payment_reminder')\n        .gte('created_at', today.toISOString());\n\n      if (existingCount && existingCount > 0) {\n        console.log(`User ${userId} already received a payment reminder today, skipping`);\n        return;\n      }\n\n      const { error: notifError } = await supabaseAdmin.from('notifications').insert({\n        user_id: userId,\n        type: 'payment_reminder',\n        title,\n        message,\n        metadata: {\n          total_amount: totalAmount,\n          event_count: eventCount,\n          event_names: eventNames,\n        },\n        read: false,\n      });\n\n      if (notifError) {\n        console.error(`Failed to create in-app notification for user ${userId}:`, notifError);\n      } else {\n        console.log(`In-app notification created for user ${userId}`);\n      }\n    } catch (error) {\n      console.error(`Error creating in-app notification for user ${userId}:`, error);\n    }\n\n    if (pushToken) {\n      try {\n        const pushMessage = {\n          to: pushToken,\n          sound: 'default',\n          title,\n          body: message,\n          data: {\n            type: 'payment_reminder',\n            totalAmount,\n            eventCount,\n          },\n          priority: 'high' as const,\n          badge: eventCount,\n        };\n\n        const response = await fetch('https://exp.host/--/api/v2/push/send', {\n          method: 'POST',\n          headers: {\n            Accept: 'application/json',\n            'Accept-encoding': 'gzip, deflate',\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify(pushMessage),\n        });\n\n        const result = await response.json() as { data?: Array<{ status: string; message?: string }> };\n        \n        if (result.data?.[0]?.status === 'ok') {\n          console.log(`Push notification sent to user ${userId}`);\n        } else if (result.data?.[0]?.status === 'error') {\n          console.error(`Push notification error for user ${userId}:`, result.data?.[0]?.message);\n        }\n      } catch (error) {\n        console.error(`Error sending push notification to user ${userId}:`, error);\n      }\n    } else {\n      console.log(`No push token for user ${userId}, skipping push notification`);\n    }\n  }\n\n  static async sendTestReminder(): Promise<{ usersNotified: number; message: string }> {\n    console.log('Sending test daily reminders...');\n    await this.sendDailyReminders();\n    return {\n      usersNotified: 0,\n      message: 'Test reminders sent. Check logs for details.',\n    };\n  }\n}\n","path":null,"size_bytes":8089,"size_tokens":null},"supabase/functions/blinkpay-payment/index.ts":{"content":"import { serve } from \"https://deno.land/std@0.168.0/http/server.ts\";\n\nconst BLINKPAY_SANDBOX_URL = 'https://sandbox.debit.blinkpay.co.nz';\n\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n  'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',\n};\n\ninterface TokenResponse {\n  access_token: string;\n  token_type: string;\n  expires_in: number;\n}\n\nasync function getAccessToken(): Promise<string> {\n  const clientId = Deno.env.get('BLINKPAY_CLIENT_ID');\n  const clientSecret = Deno.env.get('BLINKPAY_CLIENT_SECRET');\n\n  if (!clientId || !clientSecret) {\n    console.error('Missing credentials - clientId exists:', !!clientId, 'clientSecret exists:', !!clientSecret);\n    throw new Error('BlinkPay credentials not configured');\n  }\n\n  console.log('Attempting token request with clientId length:', clientId.length);\n\n  const response = await fetch(`${BLINKPAY_SANDBOX_URL}/oauth2/token`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      client_id: clientId,\n      client_secret: clientSecret,\n      grant_type: 'client_credentials'\n    }),\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error('Token error - status:', response.status, 'response:', error);\n    throw new Error('Failed to get BlinkPay access token');\n  }\n\n  const data: TokenResponse = await response.json();\n  console.log('Token obtained successfully');\n  return data.access_token;\n}\n\nasync function createPayment(\n  consentId: string,\n  amount: string,\n  particulars: string,\n  reference: string\n) {\n  const accessToken = await getAccessToken();\n\n  const request = {\n    consent_id: consentId,\n    amount: {\n      currency: 'NZD',\n      total: amount\n    },\n    pcr: {\n      particulars: particulars || 'Split Payment',\n      code: 'PAYMENT',\n      reference: reference || 'SPLIT'\n    }\n  };\n\n  console.log('Creating payment with request:', JSON.stringify(request));\n\n  const response = await fetch(`${BLINKPAY_SANDBOX_URL}/payments`, {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(request),\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error('Payment creation error:', error);\n    throw new Error(`Failed to create payment: ${error}`);\n  }\n\n  const data = await response.json();\n  console.log('Payment created:', data);\n  \n  return {\n    paymentId: data.payment_id,\n    status: 'pending'\n  };\n}\n\nasync function getPaymentStatus(paymentId: string, maxWaitSeconds: number = 30) {\n  const accessToken = await getAccessToken();\n  \n  const startTime = Date.now();\n  const maxWaitMs = maxWaitSeconds * 1000;\n  \n  while (Date.now() - startTime < maxWaitMs) {\n    const response = await fetch(`${BLINKPAY_SANDBOX_URL}/payments/${paymentId}`, {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      console.error('Get payment error:', error);\n      throw new Error(`Failed to get payment status: ${error}`);\n    }\n\n    const data = await response.json();\n    console.log('Payment status:', data.status);\n    \n    if (data.status === 'AcceptedSettlementCompleted' || \n        data.status === 'Completed' ||\n        data.status === 'completed') {\n      return {\n        paymentId: paymentId,\n        status: 'completed'\n      };\n    }\n    \n    if (data.status === 'Rejected' || \n        data.status === 'Failed' ||\n        data.status === 'rejected' ||\n        data.status === 'failed') {\n      return {\n        paymentId: paymentId,\n        status: 'failed'\n      };\n    }\n    \n    await new Promise(resolve => setTimeout(resolve, 2000));\n  }\n  \n  return {\n    paymentId: paymentId,\n    status: 'pending'\n  };\n}\n\nserve(async (req) => {\n  if (req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders });\n  }\n\n  try {\n    if (req.method !== 'POST') {\n      return new Response(\n        JSON.stringify({ error: 'Method not allowed' }),\n        { status: 405, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n      );\n    }\n\n    const body = await req.json();\n    const { action, consentId, amount, particulars, reference, paymentId, maxWaitSeconds } = body;\n\n    console.log('BlinkPay Payment function called:', { action });\n\n    if (action === 'create') {\n      if (!consentId || !amount) {\n        return new Response(\n          JSON.stringify({ error: 'consentId and amount are required' }),\n          { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n        );\n      }\n\n      const result = await createPayment(consentId, amount, particulars, reference);\n      return new Response(\n        JSON.stringify(result),\n        { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n      );\n    }\n\n    if (action === 'status') {\n      if (!paymentId) {\n        return new Response(\n          JSON.stringify({ error: 'paymentId is required' }),\n          { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n        );\n      }\n\n      const result = await getPaymentStatus(paymentId, maxWaitSeconds || 30);\n      return new Response(\n        JSON.stringify(result),\n        { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n      );\n    }\n\n    return new Response(\n      JSON.stringify({ error: 'Invalid action. Use create or status' }),\n      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    );\n\n  } catch (error) {\n    console.error('BlinkPay payment error:', error);\n    return new Response(\n      JSON.stringify({ error: error.message || 'Internal server error' }),\n      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    );\n  }\n});\n","path":null,"size_bytes":6037,"size_tokens":null},"server/routes/twilio.routes.ts":{"content":"import { Router, Request, Response } from 'express';\n\nconst router = Router();\n\nconst accountSid = process.env.TWILIO_ACCOUNT_SID;\nconst authToken = process.env.TWILIO_AUTH_TOKEN;\nconst serviceSid = process.env.TWILIO_SERVICE_SID;\n\nlet twilioClient: any = null;\n\nconst getTwilioClient = () => {\n  if (!twilioClient && accountSid && authToken) {\n    try {\n      const twilio = require('twilio');\n      twilioClient = twilio(accountSid, authToken);\n    } catch (error) {\n      console.error('Failed to initialize Twilio client:', error);\n    }\n  }\n  return twilioClient;\n};\n\ninterface RateLimitEntry {\n  count: number;\n  firstRequest: number;\n  lastRequest: number;\n}\n\nconst OTP_RATE_LIMITS = {\n  PHONE_MAX_REQUESTS_10MIN: 4,\n  PHONE_MAX_REQUESTS_HOUR: 5,\n  IP_MAX_REQUESTS_HOUR: 7,\n  TEN_MINUTES_MS: 10 * 60 * 1000,\n  ONE_HOUR_MS: 60 * 60 * 1000,\n};\n\nconst phoneRateLimits = new Map<string, RateLimitEntry>();\nconst ipRateLimits = new Map<string, RateLimitEntry>();\n\nconst cleanupRateLimits = () => {\n  const now = Date.now();\n  for (const [key, entry] of phoneRateLimits.entries()) {\n    if (now - entry.lastRequest > OTP_RATE_LIMITS.ONE_HOUR_MS) {\n      phoneRateLimits.delete(key);\n    }\n  }\n  for (const [key, entry] of ipRateLimits.entries()) {\n    if (now - entry.lastRequest > OTP_RATE_LIMITS.ONE_HOUR_MS) {\n      ipRateLimits.delete(key);\n    }\n  }\n};\n\nsetInterval(cleanupRateLimits, 5 * 60 * 1000);\n\nconst getClientIp = (req: Request): string => {\n  const forwarded = req.headers['x-forwarded-for'];\n  if (typeof forwarded === 'string') {\n    return forwarded.split(',')[0].trim();\n  }\n  if (Array.isArray(forwarded)) {\n    return forwarded[0];\n  }\n  return req.ip || req.socket.remoteAddress || 'unknown';\n};\n\nconst checkPhoneRateLimit = (phoneNumber: string): { allowed: boolean; message?: string; retryAfterMinutes?: number } => {\n  const now = Date.now();\n  const entry = phoneRateLimits.get(phoneNumber);\n  \n  if (!entry) {\n    phoneRateLimits.set(phoneNumber, { count: 1, firstRequest: now, lastRequest: now });\n    return { allowed: true };\n  }\n  \n  if (now - entry.firstRequest < OTP_RATE_LIMITS.TEN_MINUTES_MS) {\n    if (entry.count >= OTP_RATE_LIMITS.PHONE_MAX_REQUESTS_10MIN) {\n      const retryAfter = Math.ceil((OTP_RATE_LIMITS.TEN_MINUTES_MS - (now - entry.firstRequest)) / 60000);\n      return { \n        allowed: false, \n        message: `Too many OTP requests. Please try again in ${retryAfter} minutes.`,\n        retryAfterMinutes: retryAfter\n      };\n    }\n  } else if (now - entry.firstRequest < OTP_RATE_LIMITS.ONE_HOUR_MS) {\n    if (entry.count >= OTP_RATE_LIMITS.PHONE_MAX_REQUESTS_HOUR) {\n      const retryAfter = Math.ceil((OTP_RATE_LIMITS.ONE_HOUR_MS - (now - entry.firstRequest)) / 60000);\n      return { \n        allowed: false, \n        message: `Too many OTP requests. Please try again in ${retryAfter} minutes.`,\n        retryAfterMinutes: retryAfter\n      };\n    }\n  } else {\n    phoneRateLimits.set(phoneNumber, { count: 1, firstRequest: now, lastRequest: now });\n    return { allowed: true };\n  }\n  \n  entry.count++;\n  entry.lastRequest = now;\n  return { allowed: true };\n};\n\nconst checkIpRateLimit = (ip: string): { allowed: boolean; message?: string; retryAfterMinutes?: number } => {\n  const now = Date.now();\n  const entry = ipRateLimits.get(ip);\n  \n  if (!entry) {\n    ipRateLimits.set(ip, { count: 1, firstRequest: now, lastRequest: now });\n    return { allowed: true };\n  }\n  \n  if (now - entry.firstRequest < OTP_RATE_LIMITS.ONE_HOUR_MS) {\n    if (entry.count >= OTP_RATE_LIMITS.IP_MAX_REQUESTS_HOUR) {\n      const retryAfter = Math.ceil((OTP_RATE_LIMITS.ONE_HOUR_MS - (now - entry.firstRequest)) / 60000);\n      return { \n        allowed: false, \n        message: `Too many OTP requests from this network. Please try again in ${retryAfter} minutes.`,\n        retryAfterMinutes: retryAfter\n      };\n    }\n  } else {\n    ipRateLimits.set(ip, { count: 1, firstRequest: now, lastRequest: now });\n    return { allowed: true };\n  }\n  \n  entry.count++;\n  entry.lastRequest = now;\n  return { allowed: true };\n};\n\nrouter.post('/send-otp', async (req: Request, res: Response) => {\n  try {\n    const { phoneNumber } = req.body;\n\n    if (!phoneNumber) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Phone number is required' \n      });\n    }\n\n    const clientIp = getClientIp(req);\n    \n    const ipCheck = checkIpRateLimit(clientIp);\n    if (!ipCheck.allowed) {\n      console.log(`OTP rate limit (IP): ${clientIp} blocked`);\n      return res.status(429).json({ \n        success: false, \n        error: ipCheck.message,\n        retryAfterMinutes: ipCheck.retryAfterMinutes\n      });\n    }\n    \n    const phoneCheck = checkPhoneRateLimit(phoneNumber);\n    if (!phoneCheck.allowed) {\n      console.log(`OTP rate limit (Phone): ${phoneNumber} blocked`);\n      return res.status(429).json({ \n        success: false, \n        error: phoneCheck.message,\n        retryAfterMinutes: phoneCheck.retryAfterMinutes\n      });\n    }\n\n    const client = getTwilioClient();\n    \n    if (!client || !serviceSid) {\n      console.log('Twilio not configured, returning mock success for development');\n      return res.status(200).json({ \n        success: true, \n        status: 'pending',\n        message: 'Development mode: OTP simulation sent'\n      });\n    }\n\n    const verification = await client.verify.v2\n      .services(serviceSid)\n      .verifications\n      .create({ \n        to: phoneNumber,\n        channel: 'sms'\n      });\n\n    console.log('Twilio OTP sent:', verification.status);\n    \n    res.status(200).json({ \n      success: true, \n      status: verification.status \n    });\n  } catch (error: any) {\n    console.error('Error sending OTP:', error);\n    res.status(500).json({ \n      success: false, \n      error: error.message || 'Failed to send verification code' \n    });\n  }\n});\n\nrouter.post('/verify-otp', async (req: Request, res: Response) => {\n  try {\n    const { phoneNumber, code } = req.body;\n\n    if (!phoneNumber || !code) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Phone number and code are required' \n      });\n    }\n\n    const client = getTwilioClient();\n    \n    if (!client || !serviceSid) {\n      console.log('Twilio not configured, accepting any 6-digit code for development');\n      const isValidCode = /^\\d{6}$/.test(code);\n      return res.status(200).json({ \n        success: true, \n        valid: isValidCode,\n        message: isValidCode ? 'Development mode: Code accepted' : 'Invalid code format'\n      });\n    }\n\n    const verificationCheck = await client.verify.v2\n      .services(serviceSid)\n      .verificationChecks\n      .create({ \n        to: phoneNumber, \n        code: code \n      });\n\n    console.log('Twilio verification status:', verificationCheck.status);\n    \n    const isValid = verificationCheck.status === 'approved';\n    \n    res.status(200).json({ \n      success: true, \n      valid: isValid,\n      status: verificationCheck.status\n    });\n  } catch (error: any) {\n    console.error('Error verifying OTP:', error);\n    \n    if (error.code === 20404) {\n      return res.status(400).json({ \n        success: false, \n        valid: false,\n        error: 'Verification code expired. Please request a new one.' \n      });\n    }\n    \n    res.status(500).json({ \n      success: false, \n      valid: false,\n      error: error.message || 'Failed to verify code' \n    });\n  }\n});\n\nexport default router;\n","path":null,"size_bytes":7445,"size_tokens":null},"services/twilio.service.ts":{"content":"import { supabase } from './supabase';\n\nexport interface SendOTPResult {\n  success: boolean;\n  status?: string;\n  error?: string;\n}\n\nexport interface VerifyOTPResult {\n  success: boolean;\n  valid: boolean;\n  error?: string;\n}\n\nexport class TwilioService {\n  static async sendOTP(phoneNumber: string): Promise<SendOTPResult> {\n    try {\n      const formattedPhone = this.formatPhoneNumber(phoneNumber);\n      \n      const { data, error } = await supabase.functions.invoke('twilio-sms', {\n        body: { \n          action: 'send',\n          phoneNumber: formattedPhone \n        },\n      });\n\n      if (error) {\n        console.error('Supabase function error:', error);\n        console.error('Error context:', error.context);\n        \n        let errorMessage = 'Failed to send verification code';\n        if (error.context?.body) {\n          try {\n            const errorBody = typeof error.context.body === 'string' \n              ? JSON.parse(error.context.body) \n              : error.context.body;\n            errorMessage = errorBody.error || errorMessage;\n          } catch (e) {\n            console.error('Could not parse error body:', e);\n          }\n        }\n        \n        return { \n          success: false, \n          error: errorMessage\n        };\n      }\n\n      if (!data.success) {\n        return { \n          success: false, \n          error: data.error || 'Failed to send verification code' \n        };\n      }\n\n      return { \n        success: true, \n        status: data.status \n      };\n    } catch (error: any) {\n      console.error('Error sending OTP:', error);\n      return { \n        success: false, \n        error: error.message || 'Network error. Please try again.' \n      };\n    }\n  }\n\n  static async verifyOTP(phoneNumber: string, code: string): Promise<VerifyOTPResult> {\n    try {\n      const formattedPhone = this.formatPhoneNumber(phoneNumber);\n      \n      const { data, error } = await supabase.functions.invoke('twilio-sms', {\n        body: { \n          action: 'verify',\n          phoneNumber: formattedPhone,\n          code \n        },\n      });\n\n      if (error) {\n        console.error('Supabase function error:', error);\n        return { \n          success: false, \n          valid: false,\n          error: error.message || 'Failed to verify code' \n        };\n      }\n\n      if (!data.success) {\n        return { \n          success: false, \n          valid: false,\n          error: data.error || 'Failed to verify code' \n        };\n      }\n\n      return { \n        success: true, \n        valid: data.valid === true,\n        error: data.valid ? undefined : 'Invalid verification code'\n      };\n    } catch (error: any) {\n      console.error('Error verifying OTP:', error);\n      return { \n        success: false, \n        valid: false,\n        error: error.message || 'Network error. Please try again.' \n      };\n    }\n  }\n\n  static formatPhoneNumber(phone: string): string {\n    let cleaned = phone.replace(/\\s+/g, '').replace(/-/g, '');\n    \n    if (!cleaned.startsWith('+')) {\n      if (cleaned.startsWith('64')) {\n        cleaned = '+' + cleaned;\n      } else if (cleaned.startsWith('0')) {\n        cleaned = '+64' + cleaned.substring(1);\n      } else {\n        cleaned = '+64' + cleaned;\n      }\n    }\n    \n    return cleaned;\n  }\n\n  static isValidNZPhone(phone: string): boolean {\n    const cleaned = phone.replace(/\\s+/g, '').replace(/-/g, '');\n    const nzMobileRegex = /^(\\+?64|0)?2\\d{7,9}$/;\n    const nzLandlineRegex = /^(\\+?64|0)?[3-9]\\d{6,8}$/;\n    \n    return nzMobileRegex.test(cleaned) || nzLandlineRegex.test(cleaned);\n  }\n}\n","path":null,"size_bytes":3584,"size_tokens":null},"supabase/functions/twilio-sms/index.ts":{"content":"import { serve } from \"https://deno.land/std@0.168.0/http/server.ts\"\n\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n}\n\nserve(async (req) => {\n  if (req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders })\n  }\n\n  try {\n    const { action, phoneNumber, code } = await req.json()\n\n    const accountSid = Deno.env.get('TWILIO_ACCOUNT_SID')\n    const authToken = Deno.env.get('TWILIO_AUTH_TOKEN')\n    const serviceSid = Deno.env.get('TWILIO_SERVICE_SID')\n\n    if (!accountSid || !authToken || !serviceSid) {\n      return new Response(\n        JSON.stringify({ success: false, error: 'Twilio not configured' }),\n        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }\n      )\n    }\n\n    const twilioAuth = btoa(`${accountSid}:${authToken}`)\n\n    if (action === 'send') {\n      const response = await fetch(\n        `https://verify.twilio.com/v2/Services/${serviceSid}/Verifications`,\n        {\n          method: 'POST',\n          headers: {\n            'Authorization': `Basic ${twilioAuth}`,\n            'Content-Type': 'application/x-www-form-urlencoded',\n          },\n          body: new URLSearchParams({\n            To: phoneNumber,\n            Channel: 'sms',\n          }),\n        }\n      )\n\n      const data = await response.json()\n\n      if (!response.ok) {\n        console.error('Twilio error:', data)\n        return new Response(\n          JSON.stringify({ success: false, error: data.message || 'Failed to send OTP' }),\n          { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 400 }\n        )\n      }\n\n      return new Response(\n        JSON.stringify({ success: true, status: data.status }),\n        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n      )\n    }\n\n    if (action === 'verify') {\n      const response = await fetch(\n        `https://verify.twilio.com/v2/Services/${serviceSid}/VerificationCheck`,\n        {\n          method: 'POST',\n          headers: {\n            'Authorization': `Basic ${twilioAuth}`,\n            'Content-Type': 'application/x-www-form-urlencoded',\n          },\n          body: new URLSearchParams({\n            To: phoneNumber,\n            Code: code,\n          }),\n        }\n      )\n\n      const data = await response.json()\n\n      if (!response.ok) {\n        console.error('Twilio verify error:', data)\n        return new Response(\n          JSON.stringify({ success: false, valid: false, error: data.message || 'Verification failed' }),\n          { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 400 }\n        )\n      }\n\n      const isValid = data.status === 'approved'\n\n      return new Response(\n        JSON.stringify({ success: true, valid: isValid, status: data.status }),\n        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n      )\n    }\n\n    return new Response(\n      JSON.stringify({ success: false, error: 'Invalid action' }),\n      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 400 }\n    )\n  } catch (error) {\n    console.error('Error:', error)\n    return new Response(\n      JSON.stringify({ success: false, error: error.message }),\n      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }\n    )\n  }\n})\n","path":null,"size_bytes":3381,"size_tokens":null},"screens/ResetPasswordScreen.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, Alert } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { Feather } from '@expo/vector-icons';\nimport { supabase } from '@/services/supabase';\n\ntype Props = NativeStackScreenProps<any, 'ResetPassword'>;\n\nexport default function ResetPasswordScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const [newPassword, setNewPassword] = useState('');\n  const [confirmPassword, setConfirmPassword] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n  const [success, setSuccess] = useState(false);\n  const [showNewPassword, setShowNewPassword] = useState(false);\n  const [showConfirmPassword, setShowConfirmPassword] = useState(false);\n\n  const handleResetPassword = async () => {\n    setError('');\n\n    if (!newPassword || !confirmPassword) {\n      setError('Please fill in all fields');\n      return;\n    }\n\n    if (newPassword.length < 8) {\n      setError('Password must be at least 8 characters');\n      return;\n    }\n\n    if (newPassword !== confirmPassword) {\n      setError('Passwords do not match');\n      return;\n    }\n\n    setLoading(true);\n    try {\n      const { error: updateError } = await supabase.auth.updateUser({\n        password: newPassword,\n      });\n\n      if (updateError) {\n        if (updateError.message.includes('session')) {\n          setError('Your reset link has expired. Please request a new one.');\n        } else {\n          setError(updateError.message);\n        }\n        return;\n      }\n\n      setSuccess(true);\n    } catch (err: any) {\n      setError(err.message || 'Failed to reset password');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  if (success) {\n    return (\n      <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n        <ThemedView style={styles.content}>\n          <View style={[styles.iconContainer, { backgroundColor: Colors.light.success + '20' }]}>\n            <Feather name=\"check-circle\" size={48} color={Colors.light.success} />\n          </View>\n          \n          <ThemedText style={[Typography.h1, { color: theme.text, marginTop: Spacing.xl, textAlign: 'center' }]}>\n            Password Updated!\n          </ThemedText>\n          \n          <ThemedText style={[Typography.body, { color: theme.textSecondary, marginTop: Spacing.md, textAlign: 'center' }]}>\n            Your password has been successfully reset. You can now log in with your new password.\n          </ThemedText>\n\n          <Pressable\n            style={({ pressed }) => [\n              styles.button,\n              { backgroundColor: theme.primary, opacity: pressed ? 0.7 : 1, marginTop: Spacing['2xl'] }\n            ]}\n            onPress={() => navigation.navigate('Login')}\n          >\n            <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n              Go to Login\n            </ThemedText>\n          </Pressable>\n        </ThemedView>\n      </ScreenKeyboardAwareScrollView>\n    );\n  }\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <View style={[styles.iconContainer, { backgroundColor: theme.primary + '15' }]}>\n          <Feather name=\"key\" size={48} color={theme.primary} />\n        </View>\n        \n        <ThemedText style={[Typography.h1, { color: theme.text, marginTop: Spacing.xl, textAlign: 'center' }]}>\n          Set New Password\n        </ThemedText>\n        \n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginTop: Spacing.md, textAlign: 'center' }]}>\n          Enter your new password below. Make sure it's at least 8 characters long.\n        </ThemedText>\n\n        <View style={[styles.inputContainer, { marginTop: Spacing['2xl'] }]}>\n          <TextInput\n            style={[styles.input, { \n              backgroundColor: theme.surface, \n              color: theme.text, \n              borderColor: error ? Colors.light.danger : theme.border,\n            }]}\n            placeholder=\"New password\"\n            placeholderTextColor={theme.textSecondary}\n            value={newPassword}\n            onChangeText={(text) => {\n              setNewPassword(text);\n              if (error) setError('');\n            }}\n            secureTextEntry={!showNewPassword}\n            autoCapitalize=\"none\"\n            autoCorrect={false}\n          />\n          <Pressable \n            style={styles.eyeButton}\n            onPress={() => setShowNewPassword(!showNewPassword)}\n          >\n            <Feather \n              name={showNewPassword ? 'eye-off' : 'eye'} \n              size={20} \n              color={theme.textSecondary} \n            />\n          </Pressable>\n        </View>\n\n        <View style={[styles.inputContainer, { marginTop: Spacing.md }]}>\n          <TextInput\n            style={[styles.input, { \n              backgroundColor: theme.surface, \n              color: theme.text, \n              borderColor: error ? Colors.light.danger : theme.border,\n            }]}\n            placeholder=\"Confirm new password\"\n            placeholderTextColor={theme.textSecondary}\n            value={confirmPassword}\n            onChangeText={(text) => {\n              setConfirmPassword(text);\n              if (error) setError('');\n            }}\n            secureTextEntry={!showConfirmPassword}\n            autoCapitalize=\"none\"\n            autoCorrect={false}\n          />\n          <Pressable \n            style={styles.eyeButton}\n            onPress={() => setShowConfirmPassword(!showConfirmPassword)}\n          >\n            <Feather \n              name={showConfirmPassword ? 'eye-off' : 'eye'} \n              size={20} \n              color={theme.textSecondary} \n            />\n          </Pressable>\n        </View>\n\n        {error ? (\n          <ThemedText style={[Typography.caption, { color: Colors.light.danger, marginTop: Spacing.sm }]}>\n            {error}\n          </ThemedText>\n        ) : null}\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { backgroundColor: theme.primary, opacity: pressed || loading ? 0.7 : 1 }\n          ]}\n          onPress={handleResetPassword}\n          disabled={loading}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            {loading ? 'Updating...' : 'Reset Password'}\n          </ThemedText>\n        </Pressable>\n      </ThemedView>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  iconContainer: {\n    width: 96,\n    height: 96,\n    borderRadius: 48,\n    justifyContent: 'center',\n    alignItems: 'center',\n    alignSelf: 'center',\n  },\n  inputContainer: {\n    position: 'relative',\n  },\n  input: {\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    paddingRight: 50,\n    fontSize: 16,\n  },\n  eyeButton: {\n    position: 'absolute',\n    right: 0,\n    top: 0,\n    height: Spacing.inputHeight,\n    width: 50,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginTop: Spacing.lg,\n  },\n});\n","path":null,"size_bytes":7861,"size_tokens":null},"screens/SignupPhoneOTPScreen.tsx":{"content":"import React, { useState, useRef, useEffect } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, Keyboard, Platform } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { TwilioService } from '@/services/twilio.service';\n\ntype Props = NativeStackScreenProps<any, 'SignupPhoneOTP'>;\n\nexport default function SignupPhoneOTPScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const params = route.params as { \n    firstName: string; \n    lastName: string; \n    email: string; \n    password: string;\n    phone: string;\n  };\n  \n  const [code, setCode] = useState(['', '', '', '', '', '']);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n  const [resendDisabled, setResendDisabled] = useState(true);\n  const [countdown, setCountdown] = useState(60);\n  \n  const inputRefs = useRef<(TextInput | null)[]>([]);\n  const hiddenInputRef = useRef<TextInput | null>(null);\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCountdown((prev) => {\n        if (prev <= 1) {\n          setResendDisabled(false);\n          clearInterval(timer);\n          return 0;\n        }\n        return prev - 1;\n      });\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, []);\n\n  const handleCodeChange = (index: number, value: string) => {\n    if (!/^\\d*$/.test(value)) return;\n    \n    // Handle paste/autofill of complete OTP code (iOS quick-fill)\n    if (value.length > 1) {\n      const digits = value.replace(/\\D/g, '').slice(0, 6).split('');\n      const newCode = ['', '', '', '', '', ''];\n      digits.forEach((digit, i) => {\n        newCode[i] = digit;\n      });\n      setCode(newCode);\n      setError('');\n      \n      if (digits.length === 6) {\n        Keyboard.dismiss();\n        handleVerify(newCode.join(''));\n      } else if (digits.length > 0) {\n        inputRefs.current[digits.length]?.focus();\n      }\n      return;\n    }\n    \n    const newCode = [...code];\n    newCode[index] = value;\n    setCode(newCode);\n    setError('');\n\n    if (value && index < 5) {\n      inputRefs.current[index + 1]?.focus();\n    }\n\n    if (newCode.every(digit => digit !== '') && newCode.join('').length === 6) {\n      Keyboard.dismiss();\n      handleVerify(newCode.join(''));\n    }\n  };\n  \n  // Handle iOS SMS autofill on hidden input\n  const handleHiddenInputChange = (value: string) => {\n    const digits = value.replace(/\\D/g, '').slice(0, 6);\n    if (digits.length > 0) {\n      const newCode = ['', '', '', '', '', ''];\n      digits.split('').forEach((digit, i) => {\n        newCode[i] = digit;\n      });\n      setCode(newCode);\n      setError('');\n      \n      if (digits.length === 6) {\n        Keyboard.dismiss();\n        handleVerify(digits);\n      } else {\n        inputRefs.current[digits.length]?.focus();\n      }\n    }\n  };\n\n  const handleKeyPress = (index: number, key: string) => {\n    if (key === 'Backspace' && !code[index] && index > 0) {\n      inputRefs.current[index - 1]?.focus();\n    }\n  };\n\n  const handleVerify = async (otp?: string) => {\n    const otpCode = otp || code.join('');\n    \n    if (otpCode.length !== 6) {\n      setError('Please enter the complete 6-digit code');\n      return;\n    }\n\n    setLoading(true);\n    setError('');\n\n    try {\n      const result = await TwilioService.verifyOTP(params.phone, otpCode);\n\n      if (result.valid) {\n        navigation.navigate('SignupDOB', { ...params });\n      } else {\n        setError(result.error || 'Invalid verification code. Please try again.');\n        setCode(['', '', '', '', '', '']);\n        inputRefs.current[0]?.focus();\n      }\n    } catch (err: any) {\n      setError(err.message || 'Verification failed. Please try again.');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleResend = async () => {\n    setResendDisabled(true);\n    setCountdown(60);\n    setError('');\n    setCode(['', '', '', '', '', '']);\n\n    try {\n      const result = await TwilioService.sendOTP(params.phone);\n      \n      if (!result.success) {\n        setError(result.error || 'Failed to resend code');\n        setResendDisabled(false);\n        setCountdown(0);\n      }\n    } catch (err: any) {\n      setError(err.message || 'Failed to resend code');\n      setResendDisabled(false);\n      setCountdown(0);\n    }\n\n    const timer = setInterval(() => {\n      setCountdown((prev) => {\n        if (prev <= 1) {\n          setResendDisabled(false);\n          clearInterval(timer);\n          return 0;\n        }\n        return prev - 1;\n      });\n    }, 1000);\n  };\n\n  const maskedPhone = params.phone.replace(/(\\+\\d{2})(\\d+)(\\d{2})$/, '$1 ••••• $3');\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Phone Verification\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.md }]}>\n          Enter verification code\n        </ThemedText>\n\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          We sent a 6-digit code to {maskedPhone}\n        </ThemedText>\n\n        {/* Hidden input for iOS SMS autofill - captures full OTP code */}\n        {Platform.OS === 'ios' ? (\n          <TextInput\n            ref={hiddenInputRef}\n            style={styles.hiddenInput}\n            textContentType=\"oneTimeCode\"\n            autoComplete=\"sms-otp\"\n            keyboardType=\"number-pad\"\n            onChangeText={handleHiddenInputChange}\n            autoFocus\n          />\n        ) : null}\n        \n        <View style={styles.codeContainer}>\n          {code.map((digit, index) => (\n            <TextInput\n              key={index}\n              ref={(ref) => { inputRefs.current[index] = ref; }}\n              style={[\n                styles.codeInput,\n                { \n                  backgroundColor: theme.surface, \n                  color: theme.text, \n                  borderColor: error ? Colors.light.danger : (digit ? theme.primary : theme.border),\n                }\n              ]}\n              value={digit}\n              onChangeText={(value) => handleCodeChange(index, value)}\n              onKeyPress={({ nativeEvent }) => handleKeyPress(index, nativeEvent.key)}\n              keyboardType=\"number-pad\"\n              maxLength={6}\n              selectTextOnFocus\n              autoFocus={Platform.OS !== 'ios' && index === 0}\n              textContentType={index === 0 ? 'oneTimeCode' : 'none'}\n              autoComplete={index === 0 ? 'sms-otp' : 'off'}\n            />\n          ))}\n        </View>\n\n        {error ? (\n          <ThemedText style={[Typography.caption, { color: Colors.light.danger, marginTop: Spacing.md, textAlign: 'center' }]}>\n            {error}\n          </ThemedText>\n        ) : null}\n\n        <View style={styles.resendContainer}>\n          {resendDisabled ? (\n            <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n              Resend code in {countdown}s\n            </ThemedText>\n          ) : (\n            <Pressable onPress={handleResend}>\n              <ThemedText style={[Typography.body, { color: theme.primary, fontWeight: '600' }]}>\n                Resend Code\n              </ThemedText>\n            </Pressable>\n          )}\n        </View>\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed || loading ? 0.7 : (code.every(d => d) ? 1 : 0.4)\n            }\n          ]}\n          onPress={() => handleVerify()}\n          disabled={loading || !code.every(d => d)}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            {loading ? 'Verifying...' : 'Verify'}\n          </ThemedText>\n        </Pressable>\n\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  codeContainer: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    gap: Spacing.sm,\n  },\n  codeInput: {\n    flex: 1,\n    height: 56,\n    borderWidth: 2,\n    borderRadius: BorderRadius.sm,\n    fontSize: 24,\n    fontWeight: '600',\n    textAlign: 'center',\n  },\n  hiddenInput: {\n    position: 'absolute',\n    width: 1,\n    height: 1,\n    opacity: 0,\n  },\n  resendContainer: {\n    alignItems: 'center',\n    marginTop: Spacing.xl,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":9285,"size_tokens":null},"server/routes/admin.routes.ts":{"content":"import express from 'express';\nimport { createClient } from '@supabase/supabase-js';\n\nconst router = express.Router();\n\nconst supabaseUrl = 'https://vhicohutiocnfjwsofhy.supabase.co';\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\nconst supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZoaWNvaHV0aW9jbmZqd3NvZmh5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgzOTcwNTgsImV4cCI6MjA2Mzk3MzA1OH0.EI2qBBfKIoF5HZIFU_Ls62xi5A0EPKwylvKGl9ppwQA';\n\nif (!supabaseServiceKey) {\n  console.error('FATAL: SUPABASE_SERVICE_ROLE_KEY is not configured');\n}\n\nif (!supabaseAnonKey) {\n  console.error('FATAL: SUPABASE_ANON_KEY is not configured');\n}\n\n// Create admin client with explicit db schema options\nconst supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey || '', {\n  db: {\n    schema: 'public'\n  },\n  auth: {\n    autoRefreshToken: false,\n    persistSession: false\n  }\n});\n\ninterface AuthenticatedRequest extends express.Request {\n  adminUser?: { id: string; email: string; role: string; name: string };\n}\n\nasync function verifyAuthToken(token: string): Promise<{ id: string; email: string } | null> {\n  try {\n    const { data, error } = await supabaseAdmin.auth.getUser(token);\n    \n    if (error || !data.user) {\n      console.error('Token verification failed:', error?.message);\n      return null;\n    }\n    \n    return { id: data.user.id, email: data.user.email || '' };\n  } catch (err) {\n    console.error('Token verification error:', err);\n    return null;\n  }\n}\n\nasync function checkAdminRole(email: string): Promise<{ authorized: boolean; role?: string; name?: string }> {\n  try {\n    console.log('Checking admin role for email:', email.toLowerCase());\n    \n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n    \n    const { data, error } = await freshClient\n      .from('admin_roles')\n      .select('role, name, email')\n      .eq('email', email.toLowerCase())\n      .maybeSingle();\n    \n    console.log('Admin role check result:', { data, error: error?.message });\n    \n    if (error) {\n      console.error('Admin role check error:', error.message);\n      return { authorized: false };\n    }\n    \n    if (!data) {\n      console.log('No admin role found for email:', email.toLowerCase());\n      const { data: allRoles } = await freshClient.from('admin_roles').select('email');\n      console.log('All admin emails in database:', allRoles?.map(r => r.email));\n      return { authorized: false };\n    }\n    \n    console.log('Admin role found:', data);\n    return { authorized: true, role: data.role, name: data.name };\n  } catch (err) {\n    console.error('Admin role check exception:', err);\n    return { authorized: false };\n  }\n}\n\nasync function adminAuthMiddleware(\n  req: AuthenticatedRequest,\n  res: express.Response,\n  next: express.NextFunction\n) {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return res.status(401).json({ error: 'Authentication required' });\n  }\n  \n  const token = authHeader.replace('Bearer ', '');\n  \n  const user = await verifyAuthToken(token);\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid or expired token' });\n  }\n  \n  const adminCheck = await checkAdminRole(user.email);\n  if (!adminCheck.authorized) {\n    return res.status(403).json({ error: 'Admin access denied for this account' });\n  }\n  \n  req.adminUser = {\n    id: user.id,\n    email: user.email,\n    role: adminCheck.role || 'admin',\n    name: adminCheck.name || user.email\n  };\n  \n  next();\n}\n\nrouter.post('/setup-admin', async (req, res) => {\n  try {\n    // Require ADMIN_SETUP_SECRET to prevent unauthorized admin creation\n    const setupSecret = process.env.ADMIN_SETUP_SECRET;\n    const providedSecret = req.body.setup_secret || req.headers['x-setup-secret'];\n    \n    if (!setupSecret || setupSecret !== providedSecret) {\n      console.log('Admin setup attempted without valid secret');\n      return res.status(403).json({ error: 'Admin setup not authorized' });\n    }\n    \n    // Accept custom credentials from request body, or use defaults\n    const adminEmail = req.body.email || 'admin@spline.nz';\n    const adminPassword = req.body.password || 'SplineAdmin2024!';\n    \n    console.log('Setting up admin user:', adminEmail);\n    \n    // First, try to find and delete any existing user with this email\n    // Paginate through all users to find the one we need\n    let page = 1;\n    let foundUserId: string | null = null;\n    \n    while (true) {\n      const { data: usersData, error: listError } = await supabaseAdmin.auth.admin.listUsers({\n        page,\n        perPage: 100\n      });\n      \n      if (listError) {\n        console.error('Error listing users:', listError);\n        break;\n      }\n      \n      if (!usersData?.users || usersData.users.length === 0) {\n        break;\n      }\n      \n      const existingUser = usersData.users.find(u => u.email?.toLowerCase() === adminEmail.toLowerCase());\n      if (existingUser) {\n        foundUserId = existingUser.id;\n        console.log('Found existing user:', foundUserId);\n        break;\n      }\n      \n      // Check if we've reached the last page\n      if (usersData.users.length < 100) {\n        break;\n      }\n      \n      page++;\n    }\n    \n    // Delete existing user if found\n    if (foundUserId) {\n      console.log('Deleting existing user:', foundUserId);\n      const { error: deleteError } = await supabaseAdmin.auth.admin.deleteUser(foundUserId);\n      if (deleteError) {\n        console.error('Error deleting existing user:', deleteError);\n        // Continue anyway - try to create new user\n      } else {\n        console.log('Existing user deleted successfully');\n      }\n    }\n    \n    // Create fresh admin user\n    console.log('Creating new admin user...');\n    const { data, error } = await supabaseAdmin.auth.admin.createUser({\n      email: adminEmail,\n      password: adminPassword,\n      email_confirm: true\n    });\n    \n    if (error) {\n      console.error('Error creating admin user:', error);\n      return res.status(500).json({ error: 'Failed to create admin user', details: error.message });\n    }\n    \n    console.log('Admin user created successfully:', data.user?.id);\n    \n    // Also add to admin_roles table in Supabase\n    const { error: roleError } = await supabaseAdmin\n      .from('admin_roles')\n      .upsert({\n        email: adminEmail.toLowerCase(),\n        role: 'super_admin',\n        name: 'Admin User'\n      }, { onConflict: 'email' });\n    \n    if (roleError) {\n      console.error('Error adding admin role:', roleError);\n      // User is created but role wasn't added - still return success\n    } else {\n      console.log('Admin role added successfully');\n    }\n    \n    res.json({ \n      success: true, \n      message: 'Admin user created successfully',\n      email: adminEmail,\n      userId: data.user?.id\n    });\n  } catch (error: any) {\n    console.error('Setup admin error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/login', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    \n    console.log('Admin login attempt for:', email);\n    \n    if (!email || !password) {\n      return res.status(400).json({ error: 'Email and password are required' });\n    }\n\n    if (!supabaseAnonKey) {\n      console.error('Admin login failed: SUPABASE_ANON_KEY not configured');\n      return res.status(500).json({ error: 'Server configuration error' });\n    }\n\n    console.log('Using Supabase URL:', supabaseUrl);\n    console.log('Attempting admin auth with service role key...');\n\n    // Use supabaseAdmin (service role) to verify credentials by signing in\n    const { data: authData, error: authError } = await supabaseAdmin.auth.signInWithPassword({\n      email,\n      password\n    });\n\n    if (authError) {\n      console.error('Supabase auth error:', authError.message, authError.status, authError.code);\n      return res.status(401).json({ error: 'Invalid email or password', details: authError.message });\n    }\n    \n    if (!authData.user) {\n      console.error('No user returned from Supabase');\n      return res.status(401).json({ error: 'Invalid email or password' });\n    }\n    \n    console.log('Supabase auth successful for:', authData.user.email);\n\n    const adminCheck = await checkAdminRole(authData.user.email || '');\n    if (!adminCheck.authorized) {\n      await supabaseAdmin.auth.signOut();\n      return res.status(403).json({ error: 'This account does not have admin access' });\n    }\n\n    res.json({\n      success: true,\n      user: {\n        id: authData.user.id,\n        email: authData.user.email,\n        role: adminCheck.role,\n        name: adminCheck.name || authData.user.email\n      },\n      session: {\n        access_token: authData.session?.access_token,\n        expires_at: authData.session?.expires_at\n      }\n    });\n  } catch (error: any) {\n    console.error('Admin login error:', error);\n    res.status(500).json({ error: 'Login failed' });\n  }\n});\n\nrouter.post('/logout', async (req, res) => {\n  try {\n    const authHeader = req.headers.authorization;\n    \n    if (authHeader && authHeader.startsWith('Bearer ')) {\n      const token = authHeader.replace('Bearer ', '');\n      \n      const { data: userData, error: userError } = await supabaseAdmin.auth.getUser(token);\n      \n      if (userError) {\n        console.log('Logout - could not get user from token:', userError.message);\n        return res.json({ success: true });\n      }\n      \n      if (userData?.user?.id) {\n        try {\n          const revokeMethod = (supabaseAdmin.auth.admin as any).invalidateRefreshTokens;\n          \n          if (typeof revokeMethod === 'function') {\n            const { error: revokeError } = await revokeMethod.call(\n              supabaseAdmin.auth.admin,\n              userData.user.id\n            );\n            \n            if (revokeError) {\n              console.error('Logout - invalidateRefreshTokens failed:', revokeError.message);\n              return res.status(500).json({ success: false, error: 'Failed to revoke session' });\n            }\n            \n            console.log('Logout - refresh tokens invalidated for user:', userData.user.id);\n          } else {\n            console.log('Logout - invalidateRefreshTokens not available, clearing client session only');\n          }\n        } catch (revokeErr: any) {\n          console.error('Logout - revocation error:', revokeErr.message);\n        }\n      }\n    }\n    \n    res.json({ success: true });\n  } catch (error: any) {\n    console.error('Logout error:', error);\n    res.json({ success: true });\n  }\n});\n\nrouter.get('/me', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  res.json({\n    authorized: true,\n    ...req.adminUser\n  });\n});\n\nrouter.get('/metrics', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    // Create fresh client for metrics (to ensure clean state)\n    const metricsClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n    \n    // Get total wallet liabilities (sum of all wallet balances)\n    const { data: walletData, error: walletError } = await metricsClient\n      .from('wallets')\n      .select('balance, user_id');\n    \n    if (walletError) {\n      console.error('Wallet query error:', walletError);\n      return res.status(500).json({ error: walletError.message });\n    }\n\n    const totalLiabilities = walletData?.reduce((sum, w) => sum + Number(w.balance || 0), 0) || 0;\n    const activeWalletCount = walletData?.filter(w => Number(w.balance || 0) > 0).length || 0;\n\n    // Get transaction totals\n    const { data: txData, error: txError } = await metricsClient\n      .from('transactions')\n      .select('type, amount, metadata, created_at, description, user_id');\n    \n    if (txError) {\n      console.error('Transaction query error:', txError);\n      return res.status(500).json({ error: txError.message });\n    }\n\n    const now = new Date();\n    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n    let totalDeposits = 0;\n    let totalWithdrawals = 0;\n    let deposits7d = 0;\n    let withdrawals7d = 0;\n    let deposits30d = 0;\n    let withdrawals30d = 0;\n    let fastWithdrawalFeeRevenue = 0;\n    let depositTransactionCount = 0;\n    let cardPaymentTransactionCount = 0;\n    let cardPaymentVolume = 0;\n\n    txData?.forEach(tx => {\n      const amount = Number(tx.amount || 0);\n      const createdAt = new Date(tx.created_at);\n\n      if (tx.type === 'deposit') {\n        totalDeposits += amount;\n        depositTransactionCount++;\n        if (createdAt >= thirtyDaysAgo) deposits30d += amount;\n        if (createdAt >= sevenDaysAgo) deposits7d += amount;\n      } else if (tx.type === 'card_charge') {\n        // Card charges for split payments - external money coming into business\n        totalDeposits += amount;\n        cardPaymentTransactionCount++;\n        cardPaymentVolume += amount;\n        if (createdAt >= thirtyDaysAgo) deposits30d += amount;\n        if (createdAt >= sevenDaysAgo) deposits7d += amount;\n      } else if (tx.type === 'withdrawal') {\n        totalWithdrawals += amount;\n        if (createdAt >= thirtyDaysAgo) withdrawals30d += amount;\n        if (createdAt >= sevenDaysAgo) withdrawals7d += amount;\n        \n        if (tx.metadata?.withdrawal_type === 'fast' && tx.metadata?.fee_amount) {\n          fastWithdrawalFeeRevenue += Number(tx.metadata.fee_amount);\n        }\n      } else if (tx.type === 'split_payment' && tx.description?.includes('from card')) {\n        // Legacy: old card payments logged as split_payment\n        cardPaymentTransactionCount++;\n        cardPaymentVolume += amount;\n      }\n    });\n\n    // Comprehensive Stripe Connect Marketplace Fee Model\n    // Reference: https://docs.stripe.com/connect/marketplace\n    // Note: card_charge transactions are already included in totalDeposits\n    // So totalCardVolume = totalDeposits (not totalDeposits + cardPaymentVolume to avoid double-counting)\n    const totalCardTransactions = depositTransactionCount + cardPaymentTransactionCount;\n    const totalCardVolume = totalDeposits;\n    \n    // Base Stripe fees: 2.9% + 30c per transaction\n    const stripeBasePercentageFee = totalCardVolume * 0.029;\n    const stripeFixedFee = totalCardTransactions * 0.30;\n    \n    // Additional Stripe fees for NZ domestic-only operations:\n    // International/cross-border/currency fees not applicable (NZ domestic only)\n    const internationalCardFee = 0;\n    const crossBorderFee = 0;\n    const currencyConversionFee = 0;\n    \n    // Dispute/chargeback reserve: $15 per dispute (estimate 0.5% dispute rate)\n    // Use floor to avoid overestimation when volume is low\n    const disputeRate = 0.005;\n    const estimatedDisputes = Math.floor(totalCardTransactions * disputeRate);\n    const disputeFeeReserve = estimatedDisputes * 15;\n    \n    // 5. Refund fee retention: When refunds are issued, Stripe keeps the processing fee\n    // Estimate 2% refund rate → we lose the Stripe fee on refunded transactions\n    const refundRate = 0.02;\n    const refundFeeLoss = totalCardVolume * refundRate * 0.029;\n    \n    // Total Stripe fees absorbed (base + additional risks)\n    const stripeBaseFeesAbsorbed = stripeBasePercentageFee + stripeFixedFee;\n    const stripeAdditionalFees = internationalCardFee + crossBorderFee + currencyConversionFee + disputeFeeReserve + refundFeeLoss;\n    const stripeFeesAbsorbed = stripeBaseFeesAbsorbed + stripeAdditionalFees;\n    \n    const netFeePosition = fastWithdrawalFeeRevenue - stripeFeesAbsorbed;\n\n    res.json({\n      total_wallet_liabilities: totalLiabilities,\n      total_deposits: totalDeposits,\n      total_withdrawals: totalWithdrawals,\n      active_wallet_count: activeWalletCount,\n      stripe_fees_absorbed: stripeFeesAbsorbed,\n      fast_withdrawal_fee_revenue: fastWithdrawalFeeRevenue,\n      net_fee_position: netFeePosition,\n      deposits_7days: deposits7d,\n      withdrawals_7days: withdrawals7d,\n      deposits_30days: deposits30d,\n      withdrawals_30days: withdrawals30d\n    });\n  } catch (error: any) {\n    console.error('Metrics error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.get('/buffer', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    // Get total wallet liabilities\n    // Note: For production with >1000 wallets, use PostgreSQL RPC for aggregation\n    const { data: walletData, error: walletError } = await supabaseAdmin\n      .from('wallets')\n      .select('balance')\n      .range(0, 99999);\n    \n    if (walletError) {\n      return res.status(500).json({ error: walletError.message });\n    }\n\n    const totalLiabilities = walletData?.reduce((sum, w) => sum + Number(w.balance || 0), 0) || 0;\n\n    // Get transaction data\n    // Note: For production with >1000 transactions, use PostgreSQL RPC for aggregation\n    const { data: txData, error: txError } = await supabaseAdmin\n      .from('transactions')\n      .select('type, amount, metadata, created_at, description')\n      .range(0, 99999);\n    \n    if (txError) {\n      return res.status(500).json({ error: txError.message });\n    }\n\n    const now = new Date();\n    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n    let totalDeposits = 0;\n    let totalWithdrawals = 0;\n    let withdrawals7d = 0;\n    let withdrawals30d = 0;\n    let fastWithdrawalFeeRevenue = 0;\n    let depositTransactionCount = 0;\n    let cardPaymentTransactionCount = 0;\n    let cardPaymentVolume = 0;\n\n    txData?.forEach(tx => {\n      const amount = Number(tx.amount || 0);\n      const createdAt = new Date(tx.created_at);\n\n      if (tx.type === 'deposit') {\n        totalDeposits += amount;\n        depositTransactionCount++;\n      } else if (tx.type === 'card_charge') {\n        // Card charges for split payments - external money coming into business\n        totalDeposits += amount;\n        cardPaymentTransactionCount++;\n        cardPaymentVolume += amount;\n      } else if (tx.type === 'withdrawal') {\n        totalWithdrawals += amount;\n        if (createdAt >= thirtyDaysAgo) withdrawals30d += amount;\n        if (createdAt >= sevenDaysAgo) withdrawals7d += amount;\n        \n        if (tx.metadata?.withdrawal_type === 'fast' && tx.metadata?.fee_amount) {\n          fastWithdrawalFeeRevenue += Number(tx.metadata.fee_amount);\n        }\n      } else if (tx.type === 'split_payment' && (tx.description as string)?.includes('from card')) {\n        // Legacy: old card payments logged as split_payment\n        cardPaymentTransactionCount++;\n        cardPaymentVolume += amount;\n      }\n    });\n\n    // Comprehensive Stripe Connect Marketplace Fee Model\n    // Reference: https://docs.stripe.com/connect/marketplace\n    // Note: card_charge transactions are already included in totalDeposits\n    // So totalCardVolume = totalDeposits (not totalDeposits + cardPaymentVolume to avoid double-counting)\n    const totalCardTransactions = depositTransactionCount + cardPaymentTransactionCount;\n    const totalCardVolume = totalDeposits;\n    \n    // Base Stripe fees: 2.9% + 30c per transaction\n    const stripeBasePercentageFee = totalCardVolume * 0.029;\n    const stripeFixedFee = totalCardTransactions * 0.30;\n    \n    // Additional Stripe fees for NZ domestic-only operations:\n    // International/cross-border/currency fees not applicable (NZ domestic only)\n    const internationalCardFee = 0;\n    const crossBorderFee = 0;\n    const currencyConversionFee = 0;\n    \n    // Dispute/chargeback reserve: $15 per dispute (estimate 0.5% dispute rate)\n    // Use floor to avoid overestimation when volume is low\n    const disputeRate = 0.005;\n    const estimatedDisputes = Math.floor(totalCardTransactions * disputeRate);\n    const disputeFeeReserve = estimatedDisputes * 15;\n    \n    // 5. Refund fee retention: When refunds are issued, Stripe keeps the processing fee\n    // Estimate 2% refund rate → we lose the Stripe fee on refunded transactions\n    const refundRate = 0.02;\n    const refundFeeLoss = totalCardVolume * refundRate * 0.029;\n    \n    // Total Stripe fees absorbed (base + additional risks)\n    const stripeBaseFeesAbsorbed = stripeBasePercentageFee + stripeFixedFee;\n    const stripeAdditionalFees = internationalCardFee + crossBorderFee + currencyConversionFee + disputeFeeReserve + refundFeeLoss;\n    const stripeFeesAbsorbed = stripeBaseFeesAbsorbed + stripeAdditionalFees;\n\n    // Net cash position = deposits received - Stripe fees paid - withdrawals sent out\n    const netCashPosition = totalDeposits - stripeFeesAbsorbed - totalWithdrawals;\n\n    // Buffer required = liabilities - cash position (what we need to cover shortfall)\n    const bufferRequired = Math.max(0, totalLiabilities - netCashPosition);\n    \n    // Add operational safety margin (10% of liabilities as contingency)\n    const safetyMargin = totalLiabilities * 0.10;\n    const recommendedBuffer = bufferRequired + safetyMargin;\n\n    // Calculate average daily withdrawals for projections\n    const daysIn7d = 7;\n    const daysIn30d = 30;\n    const avgDaily7d = withdrawals7d / daysIn7d;\n    const avgDaily30d = withdrawals30d / daysIn30d;\n\n    // Projections based on current withdrawal patterns + safety margin\n    const projection7d = recommendedBuffer + (avgDaily7d * 7);\n    const projection30d = recommendedBuffer + (avgDaily30d * 30);\n\n    // Determine status (more conservative thresholds)\n    let status = 'healthy';\n    let statusMessage = 'Cash position covers all liabilities with safety margin';\n    \n    if (bufferRequired > 0) {\n      if (bufferRequired > totalLiabilities * 0.3) {\n        status = 'critical';\n        statusMessage = 'Significant buffer shortfall - immediate action required';\n      } else if (bufferRequired > totalLiabilities * 0.05) {\n        status = 'warning';\n        statusMessage = 'Buffer shortfall detected - monitor closely';\n      }\n    } else if (netCashPosition < safetyMargin) {\n      status = 'warning';\n      statusMessage = 'Cash position below recommended safety margin';\n    }\n\n    res.json({\n      total_liabilities: totalLiabilities,\n      net_cash_position: netCashPosition,\n      stripe_fees_paid: stripeFeesAbsorbed,\n      stripe_base_fees: stripeBaseFeesAbsorbed,\n      stripe_additional_fees: stripeAdditionalFees,\n      fast_fee_revenue: fastWithdrawalFeeRevenue,\n      buffer_required: bufferRequired,\n      recommended_buffer: recommendedBuffer,\n      safety_margin: safetyMargin,\n      projection_7d: projection7d,\n      projection_30d: projection30d,\n      avg_daily_withdrawal_7d: avgDaily7d,\n      avg_daily_withdrawal_30d: avgDaily30d,\n      status,\n      status_message: statusMessage,\n      fee_breakdown: {\n        base_percentage: stripeBasePercentageFee,\n        fixed_per_transaction: stripeFixedFee,\n        international_cards: internationalCardFee,\n        cross_border: crossBorderFee,\n        currency_conversion: currencyConversionFee,\n        dispute_reserve: disputeFeeReserve,\n        refund_loss: refundFeeLoss\n      }\n    });\n  } catch (error: any) {\n    console.error('Buffer analysis error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.get('/trends', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const days = parseInt(req.query.days as string) || 30;\n    const startDate = new Date();\n    startDate.setDate(startDate.getDate() - days);\n\n    // Use fresh client to avoid stale connection issues\n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    const { data: txData, error: txError } = await freshClient\n      .from('transactions')\n      .select('type, amount, created_at')\n      .gte('created_at', startDate.toISOString())\n      .order('created_at', { ascending: true });\n\n    if (txError) {\n      return res.status(500).json({ error: txError.message });\n    }\n\n    // Group by date\n    const dailyData: Record<string, { deposits: number; withdrawals: number }> = {};\n    \n    // Initialize all days with 0\n    for (let i = 0; i < days; i++) {\n      const date = new Date(startDate);\n      date.setDate(date.getDate() + i);\n      const dateStr = date.toISOString().split('T')[0];\n      dailyData[dateStr] = { deposits: 0, withdrawals: 0 };\n    }\n\n    // Aggregate transaction amounts\n    txData?.forEach(tx => {\n      const dateStr = tx.created_at.split('T')[0];\n      const amount = Number(tx.amount || 0);\n      \n      if (!dailyData[dateStr]) {\n        dailyData[dateStr] = { deposits: 0, withdrawals: 0 };\n      }\n      \n      if (tx.type === 'deposit' || tx.type === 'card_charge') {\n        // Both deposits and card charges represent external money coming in\n        dailyData[dateStr].deposits += amount;\n      } else if (tx.type === 'withdrawal') {\n        dailyData[dateStr].withdrawals += amount;\n      }\n    });\n\n    // Convert to array format for chart\n    const trends = Object.entries(dailyData)\n      .sort(([a], [b]) => a.localeCompare(b))\n      .map(([date, data]) => ({\n        date,\n        deposits: data.deposits,\n        withdrawals: data.withdrawals\n      }));\n\n    res.json({ trends });\n  } catch (error: any) {\n    console.error('Trends error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.get('/transactions', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const limit = parseInt(req.query.limit as string) || 50;\n    const offset = parseInt(req.query.offset as string) || 0;\n    const type = req.query.type as string || null;\n\n    // Use fresh client to avoid stale connection issues\n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    // Build query\n    let query = freshClient\n      .from('transactions')\n      .select('*', { count: 'exact' });\n    \n    if (type) {\n      query = query.eq('type', type);\n    }\n    \n    const { data: txData, error: txError, count } = await query\n      .order('created_at', { ascending: false })\n      .range(offset, offset + limit - 1);\n\n    if (txError) {\n      return res.status(500).json({ error: txError.message });\n    }\n\n    // Get user info for each transaction\n    const userIds = [...new Set(txData?.map(tx => tx.user_id) || [])];\n    \n    const { data: usersData } = await freshClient\n      .from('users')\n      .select('id, name, email, phone, unique_id')\n      .in('id', userIds);\n\n    const userMap = new Map(usersData?.map(u => [u.id, u]) || []);\n\n    // Combine transaction data with user info\n    const transactions = txData?.map(tx => {\n      const user = userMap.get(tx.user_id);\n      const amount = Number(tx.amount);\n      \n      // Calculate Stripe fee estimate: 2.9% + 30c for deposits and card payments\n      const isCardTransaction = tx.type === 'deposit' || \n        (tx.type === 'split_payment' && tx.description?.includes('from card'));\n      const stripeFee = isCardTransaction ? (amount * 0.029 + 0.30) : 0;\n      \n      // Get fast withdrawal fee from metadata\n      const fastFee = tx.metadata?.fee_amount || 0;\n      \n      return {\n        id: tx.id,\n        user_id: tx.user_id,\n        user_name: user?.name || 'Unknown',\n        user_email: user?.email || '',\n        user_unique_id: user?.unique_id || '',\n        type: tx.type,\n        amount: amount,\n        description: tx.description,\n        direction: tx.direction,\n        metadata: tx.metadata,\n        estimated_stripe_fee: stripeFee,\n        fast_withdrawal_fee: fastFee,\n        created_at: tx.created_at\n      };\n    }) || [];\n\n    res.json({\n      transactions,\n      total_count: count || 0\n    });\n  } catch (error: any) {\n    console.error('Transactions error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.get('/admins', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { data, error } = await supabaseAdmin\n      .from('admin_roles')\n      .select('*')\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      console.error('Admins list error:', error);\n      return res.status(500).json({ error: error.message });\n    }\n\n    res.json(data);\n  } catch (error: any) {\n    console.error('Admins list error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/admins', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { email, name, role } = req.body;\n\n    if (!email) {\n      return res.status(400).json({ error: 'Email is required' });\n    }\n\n    const { data, error } = await supabaseAdmin\n      .from('admin_roles')\n      .insert({\n        email: email.toLowerCase(),\n        name: name || null,\n        role: role || 'admin'\n      })\n      .select()\n      .single();\n\n    if (error) {\n      console.error('Add admin error:', error);\n      return res.status(500).json({ error: error.message });\n    }\n\n    res.json(data);\n  } catch (error: any) {\n    console.error('Add admin error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.delete('/admins/:email', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const emailToDelete = req.params.email;\n\n    if (emailToDelete.toLowerCase() === 'admin@spline.nz') {\n      return res.status(400).json({ error: 'Cannot delete the primary admin' });\n    }\n\n    const { error } = await supabaseAdmin\n      .from('admin_roles')\n      .delete()\n      .eq('email', emailToDelete.toLowerCase());\n\n    if (error) {\n      console.error('Delete admin error:', error);\n      return res.status(500).json({ error: error.message });\n    }\n\n    res.json({ success: true });\n  } catch (error: any) {\n    console.error('Delete admin error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.get('/export/transactions', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    // Query transactions directly\n    const { data: txData, error: txError } = await supabaseAdmin\n      .from('transactions')\n      .select('*')\n      .order('created_at', { ascending: false })\n      .limit(10000);\n\n    if (txError) {\n      return res.status(500).json({ error: txError.message });\n    }\n\n    // Get user info\n    const userIds = [...new Set(txData?.map(tx => tx.user_id) || [])];\n    const { data: usersData } = await supabaseAdmin\n      .from('users')\n      .select('id, name, email')\n      .in('id', userIds);\n    const userMap = new Map(usersData?.map(u => [u.id, u]) || []);\n\n    const transactions = txData?.map(tx => {\n      const user = userMap.get(tx.user_id);\n      const amount = Number(tx.amount);\n      // Stripe fee: 2.9% + 30c for deposits and card payments\n      const isCardTransaction = tx.type === 'deposit' || \n        (tx.type === 'split_payment' && tx.description?.includes('from card'));\n      const stripeFee = isCardTransaction ? (amount * 0.029 + 0.30) : 0;\n      const fastFee = tx.metadata?.fee_amount || 0;\n      return { ...tx, user_name: user?.name, user_email: user?.email, stripeFee, fastFee };\n    }) || [];\n\n    const csvHeader = 'ID,User ID,User Name,User Email,Type,Amount,Description,Direction,Stripe Fee,Fast Fee,Created At\\n';\n    const csvRows = transactions.map((tx: any) => \n      `\"${tx.id}\",\"${tx.user_id}\",\"${tx.user_name || ''}\",\"${tx.user_email || ''}\",\"${tx.type}\",\"${tx.amount}\",\"${tx.description || ''}\",\"${tx.direction}\",\"${tx.stripeFee || 0}\",\"${tx.fastFee || 0}\",\"${tx.created_at}\"`\n    ).join('\\n');\n\n    res.setHeader('Content-Type', 'text/csv');\n    res.setHeader('Content-Disposition', `attachment; filename=spline-transactions-${new Date().toISOString().split('T')[0]}.csv`);\n    res.send(csvHeader + csvRows);\n  } catch (error: any) {\n    console.error('Export error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// ======== WITHDRAWAL TRACKING ========\n// Get all pending withdrawal requests with user details for manual processing\nrouter.get('/withdrawals', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const status = req.query.status as string || 'all'; // pending, processing, completed, failed, all\n    const limit = parseInt(req.query.limit as string) || 50;\n    const offset = parseInt(req.query.offset as string) || 0;\n\n    // Use fresh client to avoid stale connection issues\n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    // Query withdrawal transactions\n    let query = freshClient\n      .from('transactions')\n      .select('*', { count: 'exact' })\n      .eq('type', 'withdrawal');\n\n    // Filter by status if specified\n    if (status !== 'all') {\n      query = query.eq('metadata->>status', status);\n    }\n\n    const { data: withdrawals, error: wError, count } = await query\n      .order('created_at', { ascending: false })\n      .range(offset, offset + limit - 1);\n\n    if (wError) {\n      return res.status(500).json({ error: wError.message });\n    }\n\n    // Get user and wallet info for each withdrawal\n    const userIds = [...new Set(withdrawals?.map(w => w.user_id) || [])];\n    \n    const [usersResult, walletsResult] = await Promise.all([\n      freshClient\n        .from('users')\n        .select('id, unique_id, name, email, phone')\n        .in('id', userIds),\n      freshClient\n        .from('wallets')\n        .select('user_id, bank_details')\n        .in('user_id', userIds)\n    ]);\n\n    const userMap = new Map(usersResult.data?.map(u => [u.id, u]) || []);\n    const walletMap = new Map(walletsResult.data?.map(w => [w.user_id, w]) || []);\n\n    // Build detailed withdrawal records\n    const withdrawalRecords = withdrawals?.map(w => {\n      const user = userMap.get(w.user_id);\n      const wallet = walletMap.get(w.user_id);\n      const metadata = w.metadata || {};\n      \n      const amount = Number(w.amount);\n      const withdrawalType = metadata.withdrawal_type || 'normal';\n      const feeAmount = metadata.fee_amount || 0;\n      const feePercentage = withdrawalType === 'fast' ? 0.02 : 0;\n      \n      // Net amount = what admin needs to transfer to user's bank\n      // For fast transfer: user requested $X, fee is included, so net = X - fee\n      // For normal transfer: no fee, net = X\n      const netAmount = withdrawalType === 'fast' ? amount - feeAmount : amount;\n      \n      return {\n        transaction_id: w.id,\n        created_at: w.created_at,\n        status: metadata.status || 'pending',\n        \n        // User info\n        user_id: w.user_id,\n        user_unique_id: user?.unique_id || '',\n        user_name: user?.name || 'Unknown',\n        user_email: user?.email || '',\n        user_phone: user?.phone || 'Not provided',\n        \n        // Withdrawal details\n        withdrawal_type: withdrawalType,\n        amount_requested: amount,\n        fee_percentage: feePercentage * 100,\n        fee_amount: feeAmount,\n        net_amount_to_transfer: netAmount,\n        \n        // Bank details - FULL info for admin to process transfers\n        bank_name: wallet?.bank_details?.bank_name || 'Unknown',\n        account_number: wallet?.bank_details?.account_number || 'Not provided',\n        account_holder_name: wallet?.bank_details?.account_holder_name || 'Not provided',\n        account_last4: wallet?.bank_details?.account_last4 || '****',\n        account_type: wallet?.bank_details?.account_type || 'Unknown',\n        \n        // Estimated arrival\n        estimated_arrival: metadata.estimated_arrival || 'Not specified',\n        \n        // Description\n        description: w.description\n      };\n    }) || [];\n\n    res.json({\n      withdrawals: withdrawalRecords,\n      total_count: count || 0,\n      pending_count: withdrawalRecords.filter(w => w.status === 'pending').length,\n      processing_count: withdrawalRecords.filter(w => w.status === 'processing').length\n    });\n  } catch (error: any) {\n    console.error('Withdrawals fetch error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Update withdrawal status (e.g., mark as processing, completed, or failed)\nrouter.patch('/withdrawals/:transactionId', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { transactionId } = req.params;\n    const { status, note } = req.body;\n\n    console.log(`Updating withdrawal ${transactionId} to status: ${status}`);\n\n    if (!['pending', 'processing', 'completed', 'failed'].includes(status)) {\n      return res.status(400).json({ error: 'Invalid status. Must be pending, processing, completed, or failed' });\n    }\n\n    // Use fresh client to avoid stale connection issues (same pattern as GET /withdrawals)\n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    // Get current transaction\n    const { data: currentTx, error: fetchError } = await freshClient\n      .from('transactions')\n      .select('metadata')\n      .eq('id', transactionId)\n      .eq('type', 'withdrawal')\n      .single();\n\n    console.log('Fetch result:', { currentTx, fetchError });\n\n    if (fetchError || !currentTx) {\n      console.error('Withdrawal transaction not found:', transactionId, fetchError);\n      return res.status(404).json({ error: 'Withdrawal transaction not found' });\n    }\n\n    // Update metadata with new status\n    const updatedMetadata = {\n      ...currentTx.metadata,\n      status,\n      updated_at: new Date().toISOString(),\n      updated_by: req.adminUser?.email,\n      admin_note: note || currentTx.metadata?.admin_note\n    };\n\n    const { error: updateError } = await freshClient\n      .from('transactions')\n      .update({ metadata: updatedMetadata })\n      .eq('id', transactionId);\n\n    if (updateError) {\n      return res.status(500).json({ error: updateError.message });\n    }\n\n    res.json({ success: true, status, message: `Withdrawal marked as ${status}` });\n  } catch (error: any) {\n    console.error('Withdrawal update error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// ======== REAL-TIME UPDATES VIA SERVER-SENT EVENTS ========\n// Store active SSE connections for broadcasting updates\nconst sseClients: Set<express.Response> = new Set();\n\n// Helper function to fetch all metrics data (reused from /metrics and /buffer)\nasync function fetchAllMetrics() {\n  // Create fresh client to avoid connection state issues\n  const client = createClient(supabaseUrl, supabaseServiceKey || '', {\n    db: { schema: 'public' },\n    auth: { autoRefreshToken: false, persistSession: false }\n  });\n  \n  // Get wallet data\n  const { data: walletData } = await client\n    .from('wallets')\n    .select('balance');\n  \n  const totalLiabilities = walletData?.reduce((sum, w) => sum + Number(w.balance || 0), 0) || 0;\n  const activeWalletCount = walletData?.filter(w => Number(w.balance || 0) > 0).length || 0;\n\n  // Get transaction data\n  const { data: txData } = await client\n    .from('transactions')\n    .select('type, amount, metadata, created_at, description');\n\n  const now = new Date();\n  const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n  const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n  let totalDeposits = 0;\n  let totalWithdrawals = 0;\n  let deposits7d = 0;\n  let withdrawals7d = 0;\n  let deposits30d = 0;\n  let withdrawals30d = 0;\n  let fastWithdrawalFeeRevenue = 0;\n  let depositTransactionCount = 0;\n  let cardPaymentTransactionCount = 0;\n  let cardPaymentVolume = 0;\n\n  txData?.forEach(tx => {\n    const amount = Number(tx.amount || 0);\n    const createdAt = new Date(tx.created_at);\n\n    if (tx.type === 'deposit') {\n      totalDeposits += amount;\n      depositTransactionCount++;\n      if (createdAt >= thirtyDaysAgo) deposits30d += amount;\n      if (createdAt >= sevenDaysAgo) deposits7d += amount;\n    } else if (tx.type === 'card_charge') {\n      // Card charges for split payments - external money coming into business\n      totalDeposits += amount;\n      cardPaymentTransactionCount++;\n      cardPaymentVolume += amount;\n      if (createdAt >= thirtyDaysAgo) deposits30d += amount;\n      if (createdAt >= sevenDaysAgo) deposits7d += amount;\n    } else if (tx.type === 'withdrawal') {\n      totalWithdrawals += amount;\n      if (createdAt >= thirtyDaysAgo) withdrawals30d += amount;\n      if (createdAt >= sevenDaysAgo) withdrawals7d += amount;\n      \n      if (tx.metadata?.withdrawal_type === 'fast' && tx.metadata?.fee_amount) {\n        fastWithdrawalFeeRevenue += Number(tx.metadata.fee_amount);\n      }\n    } else if (tx.type === 'split_payment' && tx.description?.includes('from card')) {\n      // Legacy: old card payments logged as split_payment\n      cardPaymentTransactionCount++;\n      cardPaymentVolume += amount;\n    }\n  });\n\n  // Stripe fee calculations\n  // Note: card_charge transactions are already included in totalDeposits\n  // So totalCardVolume = totalDeposits (not totalDeposits + cardPaymentVolume to avoid double-counting)\n  const totalCardTransactions = depositTransactionCount + cardPaymentTransactionCount;\n  const totalCardVolume = totalDeposits;\n  const stripeBasePercentageFee = totalCardVolume * 0.029;\n  const stripeFixedFee = totalCardTransactions * 0.30;\n  const disputeRate = 0.005;\n  const estimatedDisputes = Math.floor(totalCardTransactions * disputeRate);\n  const disputeFeeReserve = estimatedDisputes * 15;\n  const refundRate = 0.02;\n  const refundFeeLoss = totalCardVolume * refundRate * 0.029;\n  const stripeBaseFeesAbsorbed = stripeBasePercentageFee + stripeFixedFee;\n  const stripeAdditionalFees = disputeFeeReserve + refundFeeLoss;\n  const stripeFeesAbsorbed = stripeBaseFeesAbsorbed + stripeAdditionalFees;\n  const netFeePosition = fastWithdrawalFeeRevenue - stripeFeesAbsorbed;\n\n  // Buffer calculations\n  const netCashPosition = totalDeposits - stripeFeesAbsorbed - totalWithdrawals;\n  const bufferRequired = Math.max(0, totalLiabilities - netCashPosition);\n  const safetyMargin = totalLiabilities * 0.10;\n  const recommendedBuffer = bufferRequired + safetyMargin;\n  const avgDaily7d = withdrawals7d / 7;\n  const avgDaily30d = withdrawals30d / 30;\n  const projection7d = recommendedBuffer + (avgDaily7d * 7);\n  const projection30d = recommendedBuffer + (avgDaily30d * 30);\n\n  let status = 'healthy';\n  let statusMessage = 'Cash position covers all liabilities with safety margin';\n  if (bufferRequired > 0) {\n    if (bufferRequired > totalLiabilities * 0.3) {\n      status = 'critical';\n      statusMessage = 'Significant buffer shortfall - immediate action required';\n    } else if (bufferRequired > totalLiabilities * 0.05) {\n      status = 'warning';\n      statusMessage = 'Buffer shortfall detected - monitor closely';\n    }\n  } else if (netCashPosition < safetyMargin) {\n    status = 'warning';\n    statusMessage = 'Cash position below recommended safety margin';\n  }\n\n  // Get pending withdrawal count\n  const { count: pendingWithdrawals } = await client\n    .from('transactions')\n    .select('*', { count: 'exact', head: true })\n    .eq('type', 'withdrawal')\n    .eq('metadata->>status', 'pending');\n\n  return {\n    metrics: {\n      total_wallet_liabilities: totalLiabilities,\n      total_deposits: totalDeposits,\n      total_withdrawals: totalWithdrawals,\n      active_wallet_count: activeWalletCount,\n      stripe_fees_absorbed: stripeFeesAbsorbed,\n      fast_withdrawal_fee_revenue: fastWithdrawalFeeRevenue,\n      net_fee_position: netFeePosition,\n      deposits_7days: deposits7d,\n      withdrawals_7days: withdrawals7d,\n      deposits_30days: deposits30d,\n      withdrawals_30days: withdrawals30d\n    },\n    buffer: {\n      total_liabilities: totalLiabilities,\n      net_cash_position: netCashPosition,\n      stripe_fees_paid: stripeFeesAbsorbed,\n      stripe_base_fees: stripeBaseFeesAbsorbed,\n      stripe_additional_fees: stripeAdditionalFees,\n      fast_fee_revenue: fastWithdrawalFeeRevenue,\n      buffer_required: bufferRequired,\n      recommended_buffer: recommendedBuffer,\n      safety_margin: safetyMargin,\n      projection_7d: projection7d,\n      projection_30d: projection30d,\n      avg_daily_withdrawal_7d: avgDaily7d,\n      avg_daily_withdrawal_30d: avgDaily30d,\n      status,\n      status_message: statusMessage,\n      fee_breakdown: {\n        base_percentage: stripeBasePercentageFee,\n        fixed_per_transaction: stripeFixedFee,\n        international_cards: 0,\n        cross_border: 0,\n        currency_conversion: 0,\n        dispute_reserve: disputeFeeReserve,\n        refund_loss: refundFeeLoss\n      }\n    },\n    pending_withdrawals: pendingWithdrawals || 0,\n    timestamp: new Date().toISOString()\n  };\n}\n\n// SSE endpoint for real-time updates\n// Note: EventSource doesn't support custom headers, so we accept token via query param\nrouter.get('/stream', async (req: express.Request, res: express.Response) => {\n  // Manual auth since EventSource can't send headers\n  const token = req.query.token as string;\n  \n  if (!token) {\n    return res.status(401).json({ error: 'Authentication required' });\n  }\n  \n  const user = await verifyAuthToken(token);\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid or expired token' });\n  }\n  \n  const adminCheck = await checkAdminRole(user.email);\n  if (!adminCheck.authorized) {\n    return res.status(403).json({ error: 'Admin access denied' });\n  }\n  // Set SSE headers\n  res.setHeader('Content-Type', 'text/event-stream');\n  res.setHeader('Cache-Control', 'no-cache');\n  res.setHeader('Connection', 'keep-alive');\n  res.setHeader('X-Accel-Buffering', 'no'); // Disable nginx buffering\n  \n  // Add client to active connections\n  sseClients.add(res);\n  console.log(`SSE client connected. Total clients: ${sseClients.size}`);\n  \n  // Send initial data immediately\n  try {\n    const data = await fetchAllMetrics();\n    res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n  } catch (err) {\n    console.error('Error sending initial SSE data:', err);\n  }\n\n  // Send heartbeat every 30 seconds to keep connection alive\n  const heartbeatInterval = setInterval(() => {\n    try {\n      res.write(`:heartbeat\\n\\n`);\n    } catch (err) {\n      clearInterval(heartbeatInterval);\n    }\n  }, 30000);\n\n  // Send updates every 5 seconds\n  const updateInterval = setInterval(async () => {\n    try {\n      const data = await fetchAllMetrics();\n      res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n    } catch (err) {\n      console.error('Error sending SSE update:', err);\n    }\n  }, 5000);\n\n  // Clean up on client disconnect\n  req.on('close', () => {\n    clearInterval(heartbeatInterval);\n    clearInterval(updateInterval);\n    sseClients.delete(res);\n    console.log(`SSE client disconnected. Total clients: ${sseClients.size}`);\n  });\n});\n\n// Export function to broadcast updates to all connected clients\nexport async function broadcastMetricsUpdate() {\n  if (sseClients.size === 0) return;\n  \n  try {\n    const data = await fetchAllMetrics();\n    const message = `data: ${JSON.stringify(data)}\\n\\n`;\n    \n    sseClients.forEach(client => {\n      try {\n        client.write(message);\n      } catch (err) {\n        sseClients.delete(client);\n      }\n    });\n  } catch (err) {\n    console.error('Error broadcasting metrics update:', err);\n  }\n}\n\n// ======== GAMIFICATION ENDPOINTS ========\n\n// Get all users with their gamification stats\nrouter.get('/gamification/users', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { sortBy = 'current_level', order = 'desc', page = '1', limit = '50' } = req.query;\n    const pageNum = parseInt(page as string) || 1;\n    const limitNum = Math.min(parseInt(limit as string) || 50, 100);\n    const offset = (pageNum - 1) * limitNum;\n\n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    // Get users first\n    const { data: users, error: usersError, count } = await freshClient\n      .from('users')\n      .select('id, email, name, unique_id, created_at', { count: 'exact' })\n      .range(offset, offset + limitNum - 1);\n\n    if (usersError) {\n      console.error('Users fetch error:', usersError);\n      return res.status(500).json({ error: usersError.message });\n    }\n\n    // Get gamification data separately for robustness\n    const userIds = (users || []).map((u: any) => u.id);\n    let gamificationData: any[] = [];\n    \n    if (userIds.length > 0) {\n      const { data: gamData, error: gamError } = await freshClient\n        .from('user_gamification')\n        .select('user_id, current_level, total_xp, current_streak, longest_streak')\n        .in('user_id', userIds);\n      \n      if (!gamError) {\n        gamificationData = gamData || [];\n      } else {\n        console.log('Gamification fetch failed, continuing without:', gamError.message);\n      }\n    }\n\n    // Create a lookup map\n    const gamificationMap = new Map(gamificationData.map((g: any) => [g.user_id, g]));\n\n    // Transform and sort the data\n    const transformedUsers = (users || []).map((u: any) => {\n      const gam = gamificationMap.get(u.id);\n      return {\n        id: u.id,\n        email: u.email,\n        name: u.name || 'Unknown',\n        unique_id: u.unique_id,\n        joined: u.created_at,\n        current_level: gam?.current_level || 1,\n        total_xp: gam?.total_xp || 0,\n        splits_paid: 0,\n        splits_created: 0,\n        current_streak: gam?.current_streak || 0,\n        longest_streak: gam?.longest_streak || 0,\n        friends_referred: 0,\n        total_completed_splits: 0\n      };\n    });\n\n    // Sort locally (Supabase can't sort on joined table columns directly)\n    const validSortFields = ['current_level', 'total_xp', 'splits_paid', 'splits_created', 'current_streak', 'joined'];\n    const sortField = validSortFields.includes(sortBy as string) ? sortBy as string : 'current_level';\n    const sortOrder = order === 'asc' ? 1 : -1;\n\n    transformedUsers.sort((a: any, b: any) => {\n      const aVal = a[sortField];\n      const bVal = b[sortField];\n      if (typeof aVal === 'number' && typeof bVal === 'number') {\n        return (aVal - bVal) * sortOrder;\n      }\n      return String(aVal).localeCompare(String(bVal)) * sortOrder;\n    });\n\n    res.json({\n      users: transformedUsers,\n      total_count: count || 0,\n      page: pageNum,\n      limit: limitNum,\n      total_pages: Math.ceil((count || 0) / limitNum)\n    });\n  } catch (error: any) {\n    console.error('Gamification users error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Get gamification summary statistics\nrouter.get('/gamification/stats', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    // Get all gamification profiles with progressive fallback for different schemas\n    let profiles: any[] | null = null;\n\n    // Try with all possible columns first\n    const result1 = await freshClient\n      .from('user_gamification')\n      .select('current_level, total_xp, splits_paid_on_time, splits_created, current_streak, longest_streak, balance_momentum_tier');\n\n    if (!result1.error) {\n      profiles = result1.data;\n    } else {\n      console.log('Full query failed, trying basic columns:', result1.error.message);\n      // Try with minimal columns that should exist\n      const result2 = await freshClient\n        .from('user_gamification')\n        .select('current_level, total_xp, current_streak, longest_streak');\n      \n      if (!result2.error) {\n        profiles = result2.data;\n      } else {\n        console.log('Basic query failed, trying ultra-minimal:', result2.error.message);\n        // Ultra-minimal fallback\n        const result3 = await freshClient\n          .from('user_gamification')\n          .select('current_level, total_xp');\n        \n        if (result3.error) {\n          console.error('Gamification stats fetch error:', result3.error);\n          // Return empty data instead of error to not break the dashboard\n          profiles = [];\n        } else {\n          profiles = result3.data;\n        }\n      }\n    }\n\n    // Calculate level distribution\n    const levelDistribution: Record<number, number> = {};\n    let totalXP = 0;\n    let totalSplitsPaid = 0;\n    let totalSplitsCreated = 0;\n    let activeStreaks = 0;\n    let longestStreak = 0;\n\n    (profiles || []).forEach(p => {\n      const level = p.current_level || 1;\n      levelDistribution[level] = (levelDistribution[level] || 0) + 1;\n      totalXP += p.total_xp || 0;\n      totalSplitsPaid += p.splits_paid_on_time || 0;\n      totalSplitsCreated += p.splits_created || 0;\n      if ((p.current_streak || 0) > 0) activeStreaks++;\n      if ((p.longest_streak || 0) > longestStreak) longestStreak = p.longest_streak;\n    });\n\n    const totalUsers = profiles?.length || 0;\n    const avgLevel = totalUsers > 0 \n      ? (profiles || []).reduce((sum, p) => sum + (p.current_level || 1), 0) / totalUsers \n      : 1;\n    const avgXP = totalUsers > 0 ? totalXP / totalUsers : 0;\n\n    // Get XP history for recent activity\n    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();\n    const { data: recentXP, error: recentXPError } = await freshClient\n      .from('xp_history')\n      .select('xp_amount, created_at')\n      .gte('created_at', sevenDaysAgo);\n\n    const xpAwarded7d = (recentXP || []).reduce((sum, x) => sum + (x.xp_amount || 0), 0);\n\n    // Get badges statistics\n    const { data: badges, error: badgesError } = await freshClient\n      .from('user_badges')\n      .select('badge_id');\n\n    const badgeCounts: Record<string, number> = {};\n    (badges || []).forEach(b => {\n      badgeCounts[b.badge_id] = (badgeCounts[b.badge_id] || 0) + 1;\n    });\n\n    // Get Balance Momentum tier counts based on current wallet balances (potential eligibility)\n    // Bronze: $50+, Silver: $200+, Gold: $500+\n    const { data: wallets, error: walletsError } = await freshClient\n      .from('wallets')\n      .select('balance');\n\n    let momentumBronze = 0;\n    let momentumSilver = 0;\n    let momentumGold = 0;\n\n    (wallets || []).forEach(w => {\n      const balance = Number(w.balance) || 0;\n      if (balance >= 500) {\n        momentumGold++;\n      } else if (balance >= 200) {\n        momentumSilver++;\n      } else if (balance >= 50) {\n        momentumBronze++;\n      }\n    });\n\n    // Also get the actual processed momentum tiers from user_gamification\n    let processedBronze = 0;\n    let processedSilver = 0;\n    let processedGold = 0;\n    \n    (profiles || []).forEach(p => {\n      const tier = p.balance_momentum_tier || 'none';\n      if (tier === 'gold') processedGold++;\n      else if (tier === 'silver') processedSilver++;\n      else if (tier === 'bronze') processedBronze++;\n    });\n\n    // Determine if momentum has been processed (processed tiers > 0)\n    const momentumProcessed = processedBronze + processedSilver + processedGold > 0;\n\n    res.json({\n      total_users_with_gamification: totalUsers,\n      average_level: Math.round(avgLevel * 100) / 100,\n      average_xp: Math.round(avgXP),\n      total_xp_awarded: totalXP,\n      total_xp_in_system: totalXP,\n      xp_awarded_7days: xpAwarded7d,\n      total_splits_paid: totalSplitsPaid,\n      total_splits_created: totalSplitsCreated,\n      users_with_active_streak: activeStreaks,\n      users_with_active_streaks: activeStreaks,\n      longest_streak_ever: longestStreak,\n      level_distribution: levelDistribution,\n      badge_distribution: badgeCounts,\n      // Use processed tiers if momentum has been run, otherwise fall back to eligible counts\n      momentum_tier_bronze: momentumProcessed ? processedBronze : momentumBronze,\n      momentum_tier_silver: momentumProcessed ? processedSilver : momentumSilver,\n      momentum_tier_gold: momentumProcessed ? processedGold : momentumGold,\n      // Also provide both groups for transparency\n      momentum_processed: {\n        bronze: processedBronze,\n        silver: processedSilver,\n        gold: processedGold,\n        is_active: momentumProcessed\n      },\n      momentum_eligible: {\n        bronze: momentumBronze,\n        silver: momentumSilver,\n        gold: momentumGold\n      },\n      total_wallets_with_balance: (wallets || []).filter(w => Number(w.balance) > 0).length\n    });\n  } catch (error: any) {\n    console.error('Gamification stats error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Get XP history for a specific user\nrouter.get('/gamification/users/:userId/xp-history', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { userId } = req.params;\n    const { limit = '50' } = req.query;\n\n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    const { data: history, error: historyError } = await freshClient\n      .from('xp_history')\n      .select('*')\n      .eq('user_id', userId)\n      .order('created_at', { ascending: false })\n      .limit(parseInt(limit as string) || 50);\n\n    if (historyError) {\n      return res.status(500).json({ error: historyError.message });\n    }\n\n    res.json({ xp_history: history || [] });\n  } catch (error: any) {\n    console.error('XP history fetch error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Get badges for a specific user\nrouter.get('/gamification/users/:userId/badges', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { userId } = req.params;\n\n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    const { data: badges, error: badgesError } = await freshClient\n      .from('user_badges')\n      .select('*')\n      .eq('user_id', userId)\n      .order('earned_at', { ascending: false });\n\n    if (badgesError) {\n      return res.status(500).json({ error: badgesError.message });\n    }\n\n    res.json({ badges: badges || [] });\n  } catch (error: any) {\n    console.error('Badges fetch error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Manually award XP to a user (admin tool)\nrouter.post('/gamification/users/:userId/award-xp', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { userId } = req.params;\n    const { xp_amount, reason } = req.body;\n\n    if (!xp_amount || typeof xp_amount !== 'number' || xp_amount <= 0) {\n      return res.status(400).json({ error: 'Invalid XP amount' });\n    }\n\n    if (!reason) {\n      return res.status(400).json({ error: 'Reason is required' });\n    }\n\n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    // Get current gamification profile\n    const { data: profile, error: profileError } = await freshClient\n      .from('user_gamification')\n      .select('current_level, total_xp')\n      .eq('user_id', userId)\n      .single();\n\n    if (profileError) {\n      return res.status(404).json({ error: 'User gamification profile not found' });\n    }\n\n    const newTotalXP = (profile.total_xp || 0) + xp_amount;\n    \n    // Calculate new level based on XP\n    const LEVEL_THRESHOLDS = [0, 100, 300, 600, 1000, 1500, 2100, 2800];\n    let newLevel = 1;\n    for (let i = LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {\n      if (newTotalXP >= LEVEL_THRESHOLDS[i]) {\n        newLevel = i + 1;\n        break;\n      }\n    }\n\n    // Update profile\n    const { error: updateError } = await freshClient\n      .from('user_gamification')\n      .update({\n        total_xp: newTotalXP,\n        current_level: newLevel,\n        updated_at: new Date().toISOString()\n      })\n      .eq('user_id', userId);\n\n    if (updateError) {\n      return res.status(500).json({ error: updateError.message });\n    }\n\n    // Log XP history\n    await freshClient\n      .from('xp_history')\n      .insert({\n        user_id: userId,\n        action_type: 'admin_award',\n        xp_amount: xp_amount,\n        description: `Admin award: ${reason}`,\n        metadata: {\n          awarded_by: req.adminUser?.email,\n          reason\n        }\n      });\n\n    res.json({\n      success: true,\n      message: `Awarded ${xp_amount} XP to user`,\n      new_total_xp: newTotalXP,\n      new_level: newLevel,\n      leveled_up: newLevel > (profile.current_level || 1)\n    });\n  } catch (error: any) {\n    console.error('XP award error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Trigger Balance Momentum processing for all users (admin tool - can be called by cron)\nrouter.post('/gamification/process-balance-momentum', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    // First, backfill history if this is the first time running\n    // This seeds the past 7 days with current balances so averages work immediately\n    let backfillResult = null;\n    try {\n      const { data: backfillData, error: backfillError } = await freshClient.rpc('backfill_balance_history');\n      if (!backfillError) {\n        backfillResult = backfillData;\n        console.log('Balance history backfilled:', backfillData);\n      }\n    } catch (backfillErr) {\n      // Backfill may fail if function doesn't exist (older migration) - that's ok\n      console.log('Backfill skipped (function may not exist yet)');\n    }\n\n    // Call the PostgreSQL function to process all users\n    const { data, error } = await freshClient.rpc('process_all_balance_momentum');\n\n    if (error) {\n      // If the function doesn't exist, provide a helpful message\n      if (error.message.includes('does not exist')) {\n        return res.status(400).json({ \n          error: 'Balance Momentum feature not set up. Please run GAMIFICATION_MIGRATION.sql in Supabase.',\n          details: error.message\n        });\n      }\n      throw error;\n    }\n\n    console.log('Balance Momentum processed:', data);\n    res.json({\n      success: true,\n      message: 'Balance Momentum processing completed',\n      result: data,\n      backfill: backfillResult\n    });\n  } catch (error: any) {\n    console.error('Balance Momentum processing error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Get Balance Momentum stats for admin dashboard\nrouter.get('/gamification/balance-momentum/stats', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    // Get momentum tier distribution from user_gamification\n    const { data: profiles, error: profilesError } = await freshClient\n      .from('user_gamification')\n      .select('balance_momentum_tier, avg_balance_7d, balance_streak_days');\n\n    const tierCounts = { none: 0, bronze: 0, silver: 0, gold: 0 };\n    let totalStreakDays = 0;\n    let usersWithStreak = 0;\n\n    (profiles || []).forEach(p => {\n      const tier = (p.balance_momentum_tier || 'none') as keyof typeof tierCounts;\n      tierCounts[tier] = (tierCounts[tier] || 0) + 1;\n      if (p.balance_streak_days > 0) {\n        totalStreakDays += p.balance_streak_days;\n        usersWithStreak++;\n      }\n    });\n\n    // Get recent balance momentum XP awards\n    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();\n    const { data: recentAwards, error: awardsError } = await freshClient\n      .from('xp_history')\n      .select('xp_amount')\n      .eq('action_type', 'balance_momentum')\n      .gte('created_at', sevenDaysAgo);\n\n    const momentumXP7d = (recentAwards || []).reduce((sum, x) => sum + (x.xp_amount || 0), 0);\n\n    res.json({\n      tier_distribution: tierCounts,\n      total_momentum_xp_7d: momentumXP7d,\n      users_with_momentum_streak: usersWithStreak,\n      average_streak_days: usersWithStreak > 0 ? Math.round(totalStreakDays / usersWithStreak) : 0,\n      total_enrolled: (profiles || []).length\n    });\n  } catch (error: any) {\n    console.error('Balance Momentum stats error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// =============================================\n// USER REPORTS MANAGEMENT (with admin auth)\n// =============================================\n\n// Get all user reports\nrouter.get('/reports', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { status } = req.query;\n    \n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n    \n    // First get reports without FK joins (FK references auth.users, not public.users)\n    let query = freshClient\n      .from('user_reports')\n      .select('id, reporter_id, reported_user_id, reason, status, admin_notes, created_at, updated_at')\n      .order('created_at', { ascending: false });\n    \n    if (status && status !== 'all') {\n      query = query.eq('status', status as string);\n    }\n    \n    const { data: reports, error } = await query;\n    \n    if (error) {\n      console.error('Error fetching reports:', error);\n      return res.status(500).json({ error: 'Failed to fetch reports', details: error.message });\n    }\n    \n    if (!reports || reports.length === 0) {\n      return res.json({ reports: [] });\n    }\n    \n    // Get unique user IDs and fetch user details separately\n    const userIds = [...new Set([\n      ...reports.map(r => r.reporter_id),\n      ...reports.map(r => r.reported_user_id)\n    ])];\n    \n    const { data: users } = await freshClient\n      .from('users')\n      .select('id, unique_id, name, email')\n      .in('id', userIds);\n    \n    const usersMap = new Map((users || []).map(u => [u.id, u]));\n    \n    // Combine data\n    const enrichedReports = reports.map(r => ({\n      ...r,\n      reporter: usersMap.get(r.reporter_id) || null,\n      reported_user: usersMap.get(r.reported_user_id) || null\n    }));\n    \n    res.json({ reports: enrichedReports });\n    \n  } catch (error: any) {\n    console.error('Get reports error:', error);\n    res.status(500).json({ error: 'An error occurred while fetching reports' });\n  }\n});\n\n// Update report status\nrouter.patch('/reports/:reportId', adminAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { reportId } = req.params;\n    const { status, adminNotes } = req.body;\n    \n    if (!reportId) {\n      return res.status(400).json({ error: 'Missing report ID' });\n    }\n    \n    const validStatuses = ['open', 'reviewed', 'resolved', 'dismissed'];\n    if (status && !validStatuses.includes(status)) {\n      return res.status(400).json({ error: 'Invalid status' });\n    }\n    \n    const freshClient = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n    \n    const updateData: any = { updated_at: new Date().toISOString() };\n    if (status) updateData.status = status;\n    if (adminNotes !== undefined) updateData.admin_notes = adminNotes;\n    \n    const { data, error } = await freshClient\n      .from('user_reports')\n      .update(updateData)\n      .eq('id', reportId)\n      .select()\n      .single();\n    \n    if (error) {\n      console.error('Error updating report:', error);\n      return res.status(500).json({ error: 'Failed to update report', details: error.message });\n    }\n    \n    console.log(`Report ${reportId} updated by admin ${req.adminUser?.email}: status=${status}`);\n    res.json({ success: true, report: data });\n    \n  } catch (error: any) {\n    console.error('Update report error:', error);\n    res.status(500).json({ error: 'An error occurred while updating report' });\n  }\n});\n\nexport default router;\n","path":null,"size_bytes":68636,"size_tokens":null},"supabase/functions/admin-dashboard/index.ts":{"content":"import { createClient } from \"https://esm.sh/@supabase/supabase-js@2\";\nimport { Client } from \"https://deno.land/x/postgres@v0.19.3/mod.ts\";\n\nconst corsHeaders = {\n  \"Access-Control-Allow-Origin\": \"*\",\n  \"Access-Control-Allow-Headers\": \"authorization, x-client-info, apikey, content-type\",\n  \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n};\n\nconst supabaseUrl = Deno.env.get(\"SUPABASE_URL\") ?? \"\";\nconst supabaseServiceKey = Deno.env.get(\"SUPABASE_SERVICE_ROLE_KEY\") ?? \"\";\nconst databaseUrl = Deno.env.get(\"SUPABASE_DB_URL\") ?? \"\";\n\nconst supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {\n  auth: { autoRefreshToken: false, persistSession: false }\n});\n\nasync function runQuery(query: string, params: any[] = []): Promise<{ rows: any[]; error: string | null }> {\n  const client = new Client(databaseUrl);\n  try {\n    await client.connect();\n    const result = await client.queryObject(query, params);\n    return { rows: result.rows as any[], error: null };\n  } catch (err) {\n    return { rows: [], error: err instanceof Error ? err.message : \"Database error\" };\n  } finally {\n    try { await client.end(); } catch {}\n  }\n}\n\nlet dbInitialized = false;\n\nasync function initializeDatabase(): Promise<void> {\n  if (dbInitialized) return;\n  \n  const client = new Client(databaseUrl);\n  try {\n    await client.connect();\n    \n    await client.queryObject(`\n      CREATE TABLE IF NOT EXISTS public.admin_roles (\n        id SERIAL PRIMARY KEY,\n        email VARCHAR(255) UNIQUE NOT NULL,\n        role VARCHAR(50) NOT NULL DEFAULT 'admin',\n        name VARCHAR(255),\n        created_at TIMESTAMPTZ DEFAULT NOW(),\n        created_by VARCHAR(255)\n      )\n    `);\n    \n    await client.queryObject(`\n      INSERT INTO public.admin_roles (email, role, name, created_by)\n      VALUES ('admin@spline.nz', 'super_admin', 'System Admin', 'system')\n      ON CONFLICT (email) DO NOTHING\n    `);\n    \n    console.log(\"Database initialized successfully\");\n    dbInitialized = true;\n  } catch (err) {\n    console.error(\"Database init error:\", err);\n  } finally {\n    try { await client.end(); } catch {}\n  }\n}\n\n\nasync function callRpc(functionName: string, params: Record<string, any> = {}): Promise<{ data: any; error: string | null }> {\n  try {\n    const response = await fetch(`${supabaseUrl}/rest/v1/rpc/${functionName}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"apikey\": supabaseServiceKey,\n        \"Authorization\": `Bearer ${supabaseServiceKey}`,\n        \"Prefer\": \"return=representation\"\n      },\n      body: JSON.stringify(params)\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      return { data: null, error: errorText };\n    }\n    \n    const data = await response.json();\n    return { data, error: null };\n  } catch (err) {\n    return { data: null, error: err instanceof Error ? err.message : \"Unknown error\" };\n  }\n}\n\nasync function verifyAdmin(authHeader: string | null): Promise<{ user: any; error: string | null }> {\n  if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n    return { user: null, error: \"No authorization header\" };\n  }\n\n  const token = authHeader.replace(\"Bearer \", \"\");\n  \n  const { data: userData, error: userError } = await supabaseAdmin.auth.getUser(token);\n  if (userError || !userData?.user) {\n    return { user: null, error: \"Invalid token\" };\n  }\n\n  await initializeDatabase();\n\n  const { rows, error: dbError } = await runQuery(\n    \"SELECT id, email, role, name FROM public.admin_roles WHERE email = LOWER($1)\",\n    [userData.user.email]\n  );\n\n  if (dbError || rows.length === 0) {\n    return { user: null, error: \"Not an admin\" };\n  }\n\n  const adminRole = rows[0];\n  return { user: { ...userData.user, role: adminRole.role, name: adminRole.name }, error: null };\n}\n\nasync function handleLogin(body: any): Promise<Response> {\n  const { email, password } = body;\n\n  if (!email || !password) {\n    return new Response(JSON.stringify({ success: false, error: \"Email and password required\" }), {\n      status: 400,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  await initializeDatabase();\n\n  const { rows, error: dbError } = await runQuery(\n    \"SELECT id, email, role, name FROM public.admin_roles WHERE email = LOWER($1)\",\n    [email]\n  );\n\n  if (dbError || rows.length === 0) {\n    return new Response(JSON.stringify({ success: false, error: \"Not authorized as admin\" }), {\n      status: 403,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  const adminRole = rows[0];\n\n  const { data: authData, error: authError } = await supabaseAdmin.auth.signInWithPassword({\n    email,\n    password\n  });\n\n  if (authError || !authData.session) {\n    return new Response(JSON.stringify({ success: false, error: authError?.message || \"Authentication failed\" }), {\n      status: 401,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  return new Response(JSON.stringify({\n    success: true,\n    session: {\n      access_token: authData.session.access_token,\n      expires_at: authData.session.expires_at\n    },\n    user: {\n      id: authData.user.id,\n      email: authData.user.email,\n      role: adminRole.role,\n      name: adminRole.name\n    }\n  }), {\n    headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n  });\n}\n\nasync function handleLogout(authHeader: string | null): Promise<Response> {\n  if (authHeader && authHeader.startsWith(\"Bearer \")) {\n    const token = authHeader.replace(\"Bearer \", \"\");\n    try {\n      const { data: userData } = await supabaseAdmin.auth.getUser(token);\n      if (userData?.user?.id) {\n        const revokeMethod = (supabaseAdmin.auth.admin as any).invalidateRefreshTokens;\n        if (typeof revokeMethod === \"function\") {\n          await revokeMethod.call(supabaseAdmin.auth.admin, userData.user.id);\n        }\n      }\n    } catch (err) {\n      console.error(\"Logout error:\", err);\n    }\n  }\n  return new Response(JSON.stringify({ success: true }), {\n    headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n  });\n}\n\nasync function handleMetrics(authHeader: string | null): Promise<Response> {\n  const { user, error } = await verifyAdmin(authHeader);\n  if (error) {\n    return new Response(JSON.stringify({ error }), {\n      status: 401,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  try {\n    const { rows: liabilityRows } = await runQuery(`SELECT COALESCE(SUM(balance), 0) as total FROM wallets`);\n    const { rows: depositRows } = await runQuery(`SELECT COALESCE(SUM(amount), 0) as total FROM transactions WHERE type = 'deposit'`);\n    const { rows: withdrawalRows } = await runQuery(`SELECT COALESCE(SUM(amount), 0) as total FROM transactions WHERE type = 'withdrawal'`);\n    const { rows: walletRows } = await runQuery(`SELECT COUNT(*) as count FROM wallets WHERE balance > 0`);\n    const { rows: blinkFeeRows } = await runQuery(`SELECT COALESCE(SUM((metadata->>'blinkpay_fee')::numeric), 0) as total FROM transactions WHERE type = 'deposit' AND metadata->>'blinkpay_fee' IS NOT NULL`);\n    const { rows: fastWithdrawalRows } = await runQuery(`SELECT COALESCE(SUM((metadata->>'fee_amount')::numeric), 0) as total FROM transactions WHERE type = 'withdrawal' AND metadata->>'withdrawal_type' = 'fast'`);\n    const { rows: normalWithdrawalRows } = await runQuery(`SELECT COALESCE(SUM(amount), 0) as total FROM transactions WHERE type = 'withdrawal' AND (metadata->>'withdrawal_type' IS NULL OR metadata->>'withdrawal_type' = 'normal')`);\n    const { rows: fastWithdrawalCountRows } = await runQuery(`SELECT COALESCE(SUM((metadata->>'net_amount')::numeric), 0) as total FROM transactions WHERE type = 'withdrawal' AND metadata->>'withdrawal_type' = 'fast'`);\n\n    const metrics = {\n      total_liabilities: parseFloat(liabilityRows[0]?.total || '0'),\n      total_deposits: parseFloat(depositRows[0]?.total || '0'),\n      total_withdrawals: parseFloat(withdrawalRows[0]?.total || '0'),\n      active_wallets: parseInt(walletRows[0]?.count || '0'),\n      blinkpay_fees_absorbed: parseFloat(blinkFeeRows[0]?.total || '0'),\n      fast_withdrawal_revenue: parseFloat(fastWithdrawalRows[0]?.total || '0'),\n      normal_withdrawals: parseFloat(normalWithdrawalRows[0]?.total || '0'),\n      fast_withdrawals: parseFloat(fastWithdrawalCountRows[0]?.total || '0')\n    };\n\n    return new Response(JSON.stringify(metrics), {\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  } catch (err) {\n    return new Response(JSON.stringify({ error: err instanceof Error ? err.message : \"Failed to fetch metrics\" }), {\n      status: 500,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n}\n\nasync function handleBuffer(authHeader: string | null): Promise<Response> {\n  const { user, error } = await verifyAdmin(authHeader);\n  if (error) {\n    return new Response(JSON.stringify({ error }), {\n      status: 401,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  try {\n    const { rows: liabilityRows } = await runQuery(`SELECT COALESCE(SUM(balance), 0) as total FROM wallets`);\n    const { rows: revenueRows } = await runQuery(`SELECT COALESCE(SUM((metadata->>'fee_amount')::numeric), 0) as total FROM transactions WHERE type = 'withdrawal' AND metadata->>'withdrawal_type' = 'fast'`);\n    \n    const { rows: avgDaily7Rows } = await runQuery(`\n      SELECT COALESCE(AVG(daily_total), 0) as avg FROM (\n        SELECT DATE(created_at) as day, SUM(amount) as daily_total \n        FROM transactions \n        WHERE type = 'withdrawal' AND created_at >= NOW() - INTERVAL '7 days'\n        GROUP BY DATE(created_at)\n      ) daily\n    `);\n    \n    const { rows: avgDaily30Rows } = await runQuery(`\n      SELECT COALESCE(AVG(daily_total), 0) as avg FROM (\n        SELECT DATE(created_at) as day, SUM(amount) as daily_total \n        FROM transactions \n        WHERE type = 'withdrawal' AND created_at >= NOW() - INTERVAL '30 days'\n        GROUP BY DATE(created_at)\n      ) daily\n    `);\n\n    const totalLiabilities = parseFloat(liabilityRows[0]?.total || '0');\n    const totalRevenue = parseFloat(revenueRows[0]?.total || '0');\n    const avgDailyWithdrawals7 = parseFloat(avgDaily7Rows[0]?.avg || '0');\n    const avgDailyWithdrawals30 = parseFloat(avgDaily30Rows[0]?.avg || '0');\n\n    const bufferData = {\n      current_buffer: totalRevenue,\n      total_liabilities: totalLiabilities,\n      buffer_ratio: totalLiabilities > 0 ? (totalRevenue / totalLiabilities) * 100 : 0,\n      avg_daily_withdrawals_7d: avgDailyWithdrawals7,\n      avg_daily_withdrawals_30d: avgDailyWithdrawals30,\n      days_of_runway_7d: avgDailyWithdrawals7 > 0 ? totalRevenue / avgDailyWithdrawals7 : 0,\n      days_of_runway_30d: avgDailyWithdrawals30 > 0 ? totalRevenue / avgDailyWithdrawals30 : 0\n    };\n\n    return new Response(JSON.stringify(bufferData), {\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  } catch (err) {\n    return new Response(JSON.stringify({ error: err instanceof Error ? err.message : \"Failed to fetch buffer data\" }), {\n      status: 500,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n}\n\nasync function handleTrends(authHeader: string | null): Promise<Response> {\n  const { user, error } = await verifyAdmin(authHeader);\n  if (error) {\n    return new Response(JSON.stringify({ error }), {\n      status: 401,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  try {\n    const { rows } = await runQuery(`\n      SELECT \n        DATE(created_at) as date,\n        type,\n        COUNT(*) as count,\n        COALESCE(SUM(amount), 0) as total\n      FROM transactions\n      WHERE created_at >= NOW() - INTERVAL '30 days'\n      GROUP BY DATE(created_at), type\n      ORDER BY date DESC\n    `);\n\n    const trends = rows.map(row => ({\n      date: row.date,\n      type: row.type,\n      count: parseInt(row.count || '0'),\n      total: parseFloat(row.total || '0')\n    }));\n\n    return new Response(JSON.stringify(trends), {\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  } catch (err) {\n    return new Response(JSON.stringify({ error: err instanceof Error ? err.message : \"Failed to fetch trends\" }), {\n      status: 500,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n}\n\nasync function handleTransactions(authHeader: string | null, url: URL): Promise<Response> {\n  const { user, error } = await verifyAdmin(authHeader);\n  if (error) {\n    return new Response(JSON.stringify({ error }), {\n      status: 401,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  try {\n    const type = url.searchParams.get(\"type\") || null;\n    const limit = Math.min(Math.max(parseInt(url.searchParams.get(\"limit\") || \"50\"), 1), 100);\n    const offset = Math.max(parseInt(url.searchParams.get(\"offset\") || \"0\"), 0);\n\n    let countQuery = \"SELECT COUNT(*) as total FROM transactions\";\n    let dataQuery = `SELECT id, user_id, type, amount, description, metadata, created_at FROM transactions`;\n    const params: any[] = [];\n    \n    if (type) {\n      countQuery += \" WHERE type = $1\";\n      dataQuery += \" WHERE type = $1\";\n      params.push(type);\n    }\n\n    dataQuery += ` ORDER BY created_at DESC LIMIT ${limit} OFFSET ${offset}`;\n\n    const { rows: countRows } = await runQuery(countQuery, params);\n    const { rows, error: dataError } = await runQuery(dataQuery, params);\n\n    if (dataError) {\n      return new Response(JSON.stringify({ error: dataError }), {\n        status: 500,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n      });\n    }\n\n    return new Response(JSON.stringify({\n      transactions: rows,\n      total: parseInt(countRows[0]?.total || '0')\n    }), {\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  } catch (err) {\n    return new Response(JSON.stringify({ error: err instanceof Error ? err.message : \"Failed to fetch transactions\" }), {\n      status: 500,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n}\n\nasync function handleAdmins(authHeader: string | null): Promise<Response> {\n  const { user, error } = await verifyAdmin(authHeader);\n  if (error) {\n    return new Response(JSON.stringify({ error }), {\n      status: 401,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  try {\n    const { rows } = await runQuery(`\n      SELECT id, email, role, name, created_at, created_by\n      FROM admin_roles\n      ORDER BY created_at DESC\n    `);\n\n    return new Response(JSON.stringify(rows), {\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  } catch (err) {\n    return new Response(JSON.stringify({ error: err instanceof Error ? err.message : \"Failed to fetch admins\" }), {\n      status: 500,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n}\n\nasync function handleAddAdmin(authHeader: string | null, body: any): Promise<Response> {\n  const { user, error } = await verifyAdmin(authHeader);\n  if (error || user?.role !== \"super_admin\") {\n    return new Response(JSON.stringify({ error: \"Super admin access required\" }), {\n      status: 403,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  const { email, name } = body;\n  if (!email) {\n    return new Response(JSON.stringify({ error: \"Email required\" }), {\n      status: 400,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  try {\n    const { rows: existing } = await runQuery(\n      `SELECT id FROM admin_roles WHERE email = LOWER($1)`,\n      [email]\n    );\n\n    if (existing.length > 0) {\n      return new Response(JSON.stringify({ error: \"Admin already exists\" }), {\n        status: 400,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n      });\n    }\n\n    await runQuery(\n      `INSERT INTO admin_roles (email, role, name, created_by)\n       VALUES (LOWER($1), 'admin', $2, $3)`,\n      [email, name || null, user.email]\n    );\n\n    return new Response(JSON.stringify({ success: true }), {\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  } catch (err) {\n    return new Response(JSON.stringify({ error: err instanceof Error ? err.message : \"Failed to add admin\" }), {\n      status: 500,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n}\n\nasync function handleRemoveAdmin(authHeader: string | null, body: any): Promise<Response> {\n  const { user, error } = await verifyAdmin(authHeader);\n  if (error || user?.role !== \"super_admin\") {\n    return new Response(JSON.stringify({ error: \"Super admin access required\" }), {\n      status: 403,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  const { email } = body;\n  if (!email || email.toLowerCase() === user.email?.toLowerCase()) {\n    return new Response(JSON.stringify({ error: \"Cannot remove yourself\" }), {\n      status: 400,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n\n  try {\n    const { rows: existing } = await runQuery(\n      `SELECT id, role FROM admin_roles WHERE email = LOWER($1)`,\n      [email]\n    );\n\n    if (existing.length === 0) {\n      return new Response(JSON.stringify({ error: \"Admin not found\" }), {\n        status: 404,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n      });\n    }\n\n    if (existing[0].role === 'super_admin') {\n      return new Response(JSON.stringify({ error: \"Cannot remove super admin\" }), {\n        status: 400,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n      });\n    }\n\n    await runQuery(\n      `DELETE FROM admin_roles WHERE email = LOWER($1)`,\n      [email]\n    );\n\n    return new Response(JSON.stringify({ success: true }), {\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  } catch (err) {\n    return new Response(JSON.stringify({ error: err instanceof Error ? err.message : \"Failed to remove admin\" }), {\n      status: 500,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n}\n\nfunction getAdminDashboardHTML(): string {\n  return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Spline Admin Dashboard</title>\n  <script src=\"https://cdn.tailwindcss.com\"></script>\n  <script src=\"https://cdn.jsdelivr.net/npm/chart.js\"></script>\n  <style>\n    .status-healthy { background-color: #10B981; }\n    .status-warning { background-color: #F59E0B; }\n    .status-critical { background-color: #EF4444; }\n    .glass-card { background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }\n    body { background: linear-gradient(135deg, #1e40af 0%, #3b82f6 50%, #60a5fa 100%); min-height: 100vh; }\n    .tab-active { background-color: #2563EB; color: white; }\n    .loading-spinner { border: 3px solid #f3f3f3; border-top: 3px solid #2563EB; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }\n    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }\n  </style>\n</head>\n<body class=\"font-sans\">\n  <div id=\"login-screen\" class=\"min-h-screen flex items-center justify-center p-4\">\n    <div class=\"glass-card rounded-2xl p-8 w-full max-w-md shadow-2xl\">\n      <div class=\"text-center mb-8\">\n        <h1 class=\"text-3xl font-bold text-gray-800\">Spline Admin</h1>\n        <p class=\"text-gray-600 mt-2\">Business Management Dashboard</p>\n      </div>\n      <div class=\"space-y-4\">\n        <div>\n          <label class=\"block text-sm font-medium text-gray-700 mb-1\">Admin Email</label>\n          <input type=\"email\" id=\"admin-email\" placeholder=\"admin@spline.nz\" class=\"w-full px-4 py-3 rounded-xl border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none\">\n        </div>\n        <div>\n          <label class=\"block text-sm font-medium text-gray-700 mb-1\">Password</label>\n          <input type=\"password\" id=\"admin-password\" placeholder=\"Enter your password\" class=\"w-full px-4 py-3 rounded-xl border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none\">\n        </div>\n        <button onclick=\"login()\" id=\"login-btn\" class=\"w-full bg-blue-600 text-white py-3 rounded-xl font-semibold hover:bg-blue-700 transition-colors flex items-center justify-center gap-2\">\n          <span>Sign In</span>\n        </button>\n        <p id=\"login-error\" class=\"text-red-500 text-sm text-center hidden\"></p>\n      </div>\n      <p class=\"text-xs text-gray-500 text-center mt-6\">Sign in with your Supabase account. Only authorized admin emails can access.</p>\n    </div>\n  </div>\n\n  <div id=\"dashboard\" class=\"hidden\">\n    <nav class=\"bg-white/90 backdrop-blur-md shadow-sm sticky top-0 z-50\">\n      <div class=\"max-w-7xl mx-auto px-4 py-3 flex items-center justify-between\">\n        <div class=\"flex items-center gap-4\">\n          <h1 class=\"text-xl font-bold text-blue-600\">Spline Admin</h1>\n          <span id=\"admin-name\" class=\"text-sm text-gray-500\"></span>\n        </div>\n        <div class=\"flex items-center gap-4\">\n          <span id=\"last-updated\" class=\"text-xs text-gray-400\"></span>\n          <button onclick=\"refreshData()\" class=\"text-blue-600 hover:text-blue-800 text-sm flex items-center gap-1\">\n            <svg class=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15\"></path></svg>\n            Refresh\n          </button>\n          <button onclick=\"logout()\" class=\"text-gray-500 hover:text-gray-700 text-sm\">Logout</button>\n        </div>\n      </div>\n    </nav>\n\n    <div class=\"max-w-7xl mx-auto px-4 py-6\">\n      <div class=\"flex gap-2 mb-6 overflow-x-auto pb-2\">\n        <button onclick=\"showTab('overview')\" id=\"tab-overview\" class=\"tab-active px-4 py-2 rounded-lg text-sm font-medium whitespace-nowrap\">Overview</button>\n        <button onclick=\"showTab('buffer')\" id=\"tab-buffer\" class=\"px-4 py-2 rounded-lg text-sm font-medium bg-white/80 whitespace-nowrap\">Buffer Analysis</button>\n        <button onclick=\"showTab('transactions')\" id=\"tab-transactions\" class=\"px-4 py-2 rounded-lg text-sm font-medium bg-white/80 whitespace-nowrap\">Transactions</button>\n        <button onclick=\"showTab('settings')\" id=\"tab-settings\" class=\"px-4 py-2 rounded-lg text-sm font-medium bg-white/80 whitespace-nowrap\">Settings</button>\n      </div>\n\n      <div id=\"content-overview\">\n        <div class=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6\">\n          <div class=\"glass-card rounded-xl p-5\">\n            <p class=\"text-sm text-gray-500\">Total Wallet Liabilities</p>\n            <p id=\"metric-liabilities\" class=\"text-2xl font-bold text-gray-800 mt-1\">$0.00</p>\n            <p class=\"text-xs text-gray-400 mt-1\">What we owe users</p>\n          </div>\n          <div class=\"glass-card rounded-xl p-5\">\n            <p class=\"text-sm text-gray-500\">Total Deposits</p>\n            <p id=\"metric-deposits\" class=\"text-2xl font-bold text-green-600 mt-1\">$0.00</p>\n            <p class=\"text-xs text-gray-400 mt-1\">All time</p>\n          </div>\n          <div class=\"glass-card rounded-xl p-5\">\n            <p class=\"text-sm text-gray-500\">Total Withdrawals</p>\n            <p id=\"metric-withdrawals\" class=\"text-2xl font-bold text-red-600 mt-1\">$0.00</p>\n            <p class=\"text-xs text-gray-400 mt-1\">All time</p>\n          </div>\n          <div class=\"glass-card rounded-xl p-5\">\n            <p class=\"text-sm text-gray-500\">Active Wallets</p>\n            <p id=\"metric-wallets\" class=\"text-2xl font-bold text-blue-600 mt-1\">0</p>\n            <p class=\"text-xs text-gray-400 mt-1\">With balance > $0</p>\n          </div>\n        </div>\n\n        <div class=\"grid grid-cols-1 md:grid-cols-3 gap-4 mb-6\">\n          <div class=\"glass-card rounded-xl p-5\">\n            <p class=\"text-sm text-gray-500\">BlinkPay Fees Absorbed</p>\n            <p id=\"metric-blinkpay-fees\" class=\"text-2xl font-bold text-orange-600 mt-1\">$0.00</p>\n            <p class=\"text-xs text-gray-400 mt-1\">0.1% of deposits (our cost)</p>\n          </div>\n          <div class=\"glass-card rounded-xl p-5\">\n            <p class=\"text-sm text-gray-500\">Fast Withdrawal Revenue</p>\n            <p id=\"metric-fast-fees\" class=\"text-2xl font-bold text-green-600 mt-1\">$0.00</p>\n            <p class=\"text-xs text-gray-400 mt-1\">2% fee on fast transfers</p>\n          </div>\n          <div class=\"glass-card rounded-xl p-5\">\n            <p class=\"text-sm text-gray-500\">Net Fee Position</p>\n            <p id=\"metric-net-fees\" class=\"text-2xl font-bold mt-1\">$0.00</p>\n            <p class=\"text-xs text-gray-400 mt-1\">Revenue - Costs</p>\n          </div>\n        </div>\n\n        <div class=\"grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6\">\n          <div class=\"glass-card rounded-xl p-5\">\n            <h3 class=\"font-semibold text-gray-800 mb-4\">Activity (Last 7 Days)</h3>\n            <div class=\"grid grid-cols-2 gap-4\">\n              <div class=\"bg-green-50 rounded-lg p-3\">\n                <p class=\"text-xs text-green-600\">Deposits</p>\n                <p id=\"metric-deposits-7d\" class=\"text-xl font-bold text-green-700\">$0.00</p>\n              </div>\n              <div class=\"bg-red-50 rounded-lg p-3\">\n                <p class=\"text-xs text-red-600\">Withdrawals</p>\n                <p id=\"metric-withdrawals-7d\" class=\"text-xl font-bold text-red-700\">$0.00</p>\n              </div>\n            </div>\n          </div>\n          <div class=\"glass-card rounded-xl p-5\">\n            <h3 class=\"font-semibold text-gray-800 mb-4\">Activity (Last 30 Days)</h3>\n            <div class=\"grid grid-cols-2 gap-4\">\n              <div class=\"bg-green-50 rounded-lg p-3\">\n                <p class=\"text-xs text-green-600\">Deposits</p>\n                <p id=\"metric-deposits-30d\" class=\"text-xl font-bold text-green-700\">$0.00</p>\n              </div>\n              <div class=\"bg-red-50 rounded-lg p-3\">\n                <p class=\"text-xs text-red-600\">Withdrawals</p>\n                <p id=\"metric-withdrawals-30d\" class=\"text-xl font-bold text-red-700\">$0.00</p>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"glass-card rounded-xl p-5\">\n          <h3 class=\"font-semibold text-gray-800 mb-4\">Transaction Trends (30 Days)</h3>\n          <div style=\"height: 300px;\"><canvas id=\"trends-chart\"></canvas></div>\n        </div>\n      </div>\n\n      <div id=\"content-buffer\" class=\"hidden\">\n        <div class=\"glass-card rounded-xl p-6 mb-6\">\n          <div class=\"flex items-center justify-between mb-6\">\n            <h3 class=\"text-xl font-bold text-gray-800\">Buffer/Cushion Status</h3>\n            <div id=\"buffer-status-badge\" class=\"px-4 py-2 rounded-full text-white font-semibold text-sm\">Loading...</div>\n          </div>\n          \n          <div class=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6\">\n            <div class=\"bg-blue-50 rounded-lg p-4\">\n              <p class=\"text-xs text-blue-600\">Total Wallet Liabilities</p>\n              <p id=\"buffer-liabilities\" class=\"text-xl font-bold text-blue-800\">$0.00</p>\n            </div>\n            <div class=\"bg-green-50 rounded-lg p-4\">\n              <p class=\"text-xs text-green-600\">Net Cash Position</p>\n              <p id=\"buffer-cash\" class=\"text-xl font-bold text-green-800\">$0.00</p>\n            </div>\n            <div class=\"bg-orange-50 rounded-lg p-4\">\n              <p class=\"text-xs text-orange-600\">BlinkPay Fees Paid</p>\n              <p id=\"buffer-blinkpay\" class=\"text-xl font-bold text-orange-800\">$0.00</p>\n            </div>\n            <div class=\"bg-purple-50 rounded-lg p-4\">\n              <p class=\"text-xs text-purple-600\">Fast Fee Revenue</p>\n              <p id=\"buffer-fast-fees\" class=\"text-xl font-bold text-purple-800\">$0.00</p>\n            </div>\n          </div>\n\n          <div class=\"bg-gray-50 rounded-xl p-6 mb-6\">\n            <h4 class=\"font-semibold text-gray-700 mb-4\">Buffer Requirement Calculator</h4>\n            <div class=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n              <div class=\"text-center\">\n                <p class=\"text-sm text-gray-500\">Current Buffer Required</p>\n                <p id=\"buffer-required\" class=\"text-3xl font-bold text-gray-800 mt-2\">$0.00</p>\n              </div>\n              <div class=\"text-center\">\n                <p class=\"text-sm text-gray-500\">7-Day Projection</p>\n                <p id=\"buffer-7d\" class=\"text-3xl font-bold text-gray-800 mt-2\">$0.00</p>\n              </div>\n              <div class=\"text-center\">\n                <p class=\"text-sm text-gray-500\">30-Day Projection</p>\n                <p id=\"buffer-30d\" class=\"text-3xl font-bold text-gray-800 mt-2\">$0.00</p>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div id=\"content-transactions\" class=\"hidden\">\n        <div class=\"glass-card rounded-xl p-5 mb-6\">\n          <div class=\"flex flex-wrap items-center justify-between gap-4 mb-4\">\n            <h3 class=\"font-semibold text-gray-800\">Transaction History</h3>\n            <div class=\"flex gap-2\">\n              <select id=\"tx-filter\" onchange=\"loadTransactions()\" class=\"px-3 py-2 rounded-lg border border-gray-300 text-sm\">\n                <option value=\"\">All Types</option>\n                <option value=\"deposit\">Deposits</option>\n                <option value=\"withdrawal\">Withdrawals</option>\n                <option value=\"split_payment\">Split Payments</option>\n                <option value=\"split_received\">Split Received</option>\n              </select>\n            </div>\n          </div>\n          \n          <div class=\"overflow-x-auto\">\n            <table class=\"w-full text-sm\">\n              <thead>\n                <tr class=\"text-left text-gray-500 border-b\">\n                  <th class=\"pb-3 pr-4\">Date</th>\n                  <th class=\"pb-3 pr-4\">User</th>\n                  <th class=\"pb-3 pr-4\">Type</th>\n                  <th class=\"pb-3 pr-4\">Amount</th>\n                  <th class=\"pb-3\">Description</th>\n                </tr>\n              </thead>\n              <tbody id=\"transactions-table\">\n                <tr><td colspan=\"5\" class=\"py-8 text-center text-gray-400\">Loading...</td></tr>\n              </tbody>\n            </table>\n          </div>\n          \n          <div class=\"flex items-center justify-between mt-4 pt-4 border-t\">\n            <p id=\"tx-count\" class=\"text-sm text-gray-500\">Showing 0 of 0 transactions</p>\n            <div class=\"flex gap-2\">\n              <button onclick=\"prevPage()\" id=\"btn-prev\" class=\"px-3 py-1 rounded border border-gray-300 text-sm disabled:opacity-50\" disabled>Previous</button>\n              <button onclick=\"nextPage()\" id=\"btn-next\" class=\"px-3 py-1 rounded border border-gray-300 text-sm disabled:opacity-50\" disabled>Next</button>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div id=\"content-settings\" class=\"hidden\">\n        <div class=\"glass-card rounded-xl p-6 mb-6\">\n          <h3 class=\"font-semibold text-gray-800 mb-4\">Admin Users</h3>\n          <div id=\"admin-list\" class=\"space-y-3 mb-4\"><p class=\"text-gray-400\">Loading...</p></div>\n          \n          <div class=\"border-t pt-4 mt-4\">\n            <h4 class=\"font-medium text-gray-700 mb-3\">Add New Admin</h4>\n            <div class=\"flex flex-wrap gap-2\">\n              <input type=\"email\" id=\"new-admin-email\" placeholder=\"email@example.com\" class=\"flex-1 min-w-48 px-3 py-2 rounded-lg border border-gray-300 text-sm\">\n              <input type=\"text\" id=\"new-admin-name\" placeholder=\"Name (optional)\" class=\"flex-1 min-w-32 px-3 py-2 rounded-lg border border-gray-300 text-sm\">\n              <button onclick=\"addAdmin()\" class=\"bg-blue-600 text-white px-4 py-2 rounded-lg text-sm hover:bg-blue-700\">Add Admin</button>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"glass-card rounded-xl p-6\">\n          <h3 class=\"font-semibold text-gray-800 mb-4\">Fee Configuration</h3>\n          <div class=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            <div class=\"bg-gray-50 rounded-lg p-4\">\n              <p class=\"text-sm text-gray-600\">BlinkPay Fee Rate</p>\n              <p class=\"text-xl font-bold text-gray-800\">0.1%</p>\n              <p class=\"text-xs text-gray-400\">Charged on deposits</p>\n            </div>\n            <div class=\"bg-gray-50 rounded-lg p-4\">\n              <p class=\"text-sm text-gray-600\">Fast Withdrawal Fee</p>\n              <p class=\"text-xl font-bold text-gray-800\">2%</p>\n              <p class=\"text-xs text-gray-400\">Included in withdrawal amount</p>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    const API_BASE = '';\n    let accessToken = '';\n    let adminUser = null;\n    let tokenExpiresAt = null;\n    let currentPage = 0;\n    let totalTransactions = 0;\n    const PAGE_SIZE = 50;\n    let trendsChart = null;\n    \n    function isTokenExpired() {\n      if (!tokenExpiresAt) return true;\n      return Date.now() > tokenExpiresAt * 1000 - 60000;\n    }\n\n    function formatCurrency(amount) {\n      return new Intl.NumberFormat('en-NZ', { style: 'currency', currency: 'NZD' }).format(amount || 0);\n    }\n\n    function formatDate(dateStr) {\n      return new Date(dateStr).toLocaleString('en-NZ', { dateStyle: 'medium', timeStyle: 'short' });\n    }\n\n    async function login() {\n      const email = document.getElementById('admin-email').value.trim();\n      const password = document.getElementById('admin-password').value;\n      const loginBtn = document.getElementById('login-btn');\n      const errorEl = document.getElementById('login-error');\n      \n      if (!email || !password) {\n        errorEl.textContent = 'Please enter email and password';\n        errorEl.classList.remove('hidden');\n        return;\n      }\n\n      loginBtn.innerHTML = '<div class=\"loading-spinner\"></div>';\n      loginBtn.disabled = true;\n      errorEl.classList.add('hidden');\n\n      try {\n        const res = await fetch(API_BASE + '/login', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ email, password })\n        });\n        const data = await res.json();\n\n        if (data.success && data.session?.access_token) {\n          accessToken = data.session.access_token;\n          tokenExpiresAt = data.session.expires_at;\n          adminUser = data.user;\n          \n          sessionStorage.setItem('adminAccessToken', accessToken);\n          sessionStorage.setItem('adminUser', JSON.stringify(adminUser));\n          sessionStorage.setItem('tokenExpiresAt', tokenExpiresAt.toString());\n          \n          document.getElementById('admin-name').textContent = adminUser.name || adminUser.email;\n          document.getElementById('login-screen').classList.add('hidden');\n          document.getElementById('dashboard').classList.remove('hidden');\n          document.getElementById('admin-password').value = '';\n          refreshData();\n        } else {\n          errorEl.textContent = data.error || 'Login failed';\n          errorEl.classList.remove('hidden');\n        }\n      } catch (err) {\n        errorEl.textContent = 'Connection error. Please try again.';\n        errorEl.classList.remove('hidden');\n      }\n\n      loginBtn.innerHTML = '<span>Sign In</span>';\n      loginBtn.disabled = false;\n    }\n\n    async function logout() {\n      try {\n        if (accessToken) {\n          await fetch(API_BASE + '/logout', {\n            method: 'POST',\n            headers: { 'Authorization': 'Bearer ' + accessToken }\n          });\n        }\n      } catch (err) {}\n      \n      accessToken = '';\n      adminUser = null;\n      tokenExpiresAt = null;\n      sessionStorage.removeItem('adminAccessToken');\n      sessionStorage.removeItem('adminUser');\n      sessionStorage.removeItem('tokenExpiresAt');\n      document.getElementById('dashboard').classList.add('hidden');\n      document.getElementById('login-screen').classList.remove('hidden');\n    }\n\n    async function fetchWithAuth(endpoint) {\n      if (!accessToken || isTokenExpired()) {\n        await logout();\n        throw new Error('Session expired');\n      }\n      \n      const res = await fetch(API_BASE + endpoint, {\n        headers: { 'Authorization': 'Bearer ' + accessToken, 'Content-Type': 'application/json' }\n      });\n      if (res.status === 401) {\n        await logout();\n        throw new Error('Session expired');\n      }\n      if (!res.ok) throw new Error('Request failed');\n      return res.json();\n    }\n\n    function showTab(tab) {\n      ['overview', 'buffer', 'transactions', 'settings'].forEach(t => {\n        document.getElementById('content-' + t).classList.toggle('hidden', t !== tab);\n        document.getElementById('tab-' + t).classList.toggle('tab-active', t === tab);\n        document.getElementById('tab-' + t).classList.toggle('bg-white/80', t !== tab);\n      });\n    }\n\n    async function refreshData() {\n      document.getElementById('last-updated').textContent = 'Updating...';\n      try {\n        await Promise.all([loadMetrics(), loadBuffer(), loadTrends(), loadTransactions(), loadAdmins()]);\n        document.getElementById('last-updated').textContent = 'Updated: ' + new Date().toLocaleTimeString();\n      } catch (err) {\n        document.getElementById('last-updated').textContent = 'Update failed';\n      }\n    }\n\n    async function loadMetrics() {\n      try {\n        const data = await fetchWithAuth('/metrics');\n        document.getElementById('metric-liabilities').textContent = formatCurrency(data.total_wallet_liabilities);\n        document.getElementById('metric-deposits').textContent = formatCurrency(data.total_deposits);\n        document.getElementById('metric-withdrawals').textContent = formatCurrency(data.total_withdrawals);\n        document.getElementById('metric-wallets').textContent = data.active_wallet_count || 0;\n        document.getElementById('metric-blinkpay-fees').textContent = formatCurrency(data.blinkpay_fees_absorbed);\n        document.getElementById('metric-fast-fees').textContent = formatCurrency(data.fast_withdrawal_fee_revenue);\n        \n        const netFees = data.net_fee_position || 0;\n        const netFeesEl = document.getElementById('metric-net-fees');\n        netFeesEl.textContent = formatCurrency(netFees);\n        netFeesEl.className = 'text-2xl font-bold mt-1 ' + (netFees >= 0 ? 'text-green-600' : 'text-red-600');\n        \n        document.getElementById('metric-deposits-7d').textContent = formatCurrency(data.deposits_7days);\n        document.getElementById('metric-withdrawals-7d').textContent = formatCurrency(data.withdrawals_7days);\n        document.getElementById('metric-deposits-30d').textContent = formatCurrency(data.deposits_30days);\n        document.getElementById('metric-withdrawals-30d').textContent = formatCurrency(data.withdrawals_30days);\n      } catch (err) {}\n    }\n\n    async function loadBuffer() {\n      try {\n        const data = await fetchWithAuth('/buffer');\n        document.getElementById('buffer-liabilities').textContent = formatCurrency(data.total_wallet_liabilities);\n        document.getElementById('buffer-cash').textContent = formatCurrency(data.net_cash_position);\n        document.getElementById('buffer-blinkpay').textContent = formatCurrency(data.blinkpay_fees_paid);\n        document.getElementById('buffer-fast-fees').textContent = formatCurrency(data.fast_fee_revenue);\n        document.getElementById('buffer-required').textContent = formatCurrency(data.buffer_required);\n        document.getElementById('buffer-7d').textContent = formatCurrency(data.buffer_7day_projection);\n        document.getElementById('buffer-30d').textContent = formatCurrency(data.buffer_30day_projection);\n        \n        const badge = document.getElementById('buffer-status-badge');\n        const bufferReq = data.buffer_required || 0;\n        if (bufferReq <= 0) {\n          badge.textContent = 'Healthy';\n          badge.className = 'px-4 py-2 rounded-full text-white font-semibold text-sm status-healthy';\n        } else if (bufferReq < 1000) {\n          badge.textContent = 'Warning';\n          badge.className = 'px-4 py-2 rounded-full text-white font-semibold text-sm status-warning';\n        } else {\n          badge.textContent = 'Critical';\n          badge.className = 'px-4 py-2 rounded-full text-white font-semibold text-sm status-critical';\n        }\n      } catch (err) {}\n    }\n\n    async function loadTrends() {\n      try {\n        const data = await fetchWithAuth('/trends');\n        const ctx = document.getElementById('trends-chart').getContext('2d');\n        if (trendsChart) trendsChart.destroy();\n        trendsChart = new Chart(ctx, {\n          type: 'line',\n          data: {\n            labels: data.map(d => d.date),\n            datasets: [\n              { label: 'Deposits', data: data.map(d => d.deposits), borderColor: '#10B981', tension: 0.3 },\n              { label: 'Withdrawals', data: data.map(d => d.withdrawals), borderColor: '#EF4444', tension: 0.3 }\n            ]\n          },\n          options: { responsive: true, maintainAspectRatio: false }\n        });\n      } catch (err) {}\n    }\n\n    async function loadTransactions() {\n      try {\n        const filter = document.getElementById('tx-filter').value;\n        const url = '/transactions?limit=' + PAGE_SIZE + '&offset=' + (currentPage * PAGE_SIZE) + (filter ? '&type=' + filter : '');\n        const data = await fetchWithAuth(url);\n        totalTransactions = data.total;\n        \n        const tbody = document.getElementById('transactions-table');\n        if (!data.transactions?.length) {\n          tbody.innerHTML = '<tr><td colspan=\"5\" class=\"py-8 text-center text-gray-400\">No transactions found</td></tr>';\n        } else {\n          tbody.innerHTML = data.transactions.map(tx => {\n            const user = tx.users || {};\n            const userName = [user.first_name, user.last_name].filter(Boolean).join(' ') || user.email || 'Unknown';\n            return '<tr class=\"border-b\"><td class=\"py-3 pr-4\">' + formatDate(tx.created_at) + '</td><td class=\"py-3 pr-4\">' + userName + '</td><td class=\"py-3 pr-4\"><span class=\"px-2 py-1 rounded text-xs ' + (tx.type === 'deposit' ? 'bg-green-100 text-green-700' : tx.type === 'withdrawal' ? 'bg-red-100 text-red-700' : 'bg-blue-100 text-blue-700') + '\">' + tx.type + '</span></td><td class=\"py-3 pr-4 font-medium\">' + formatCurrency(tx.amount) + '</td><td class=\"py-3 text-gray-500\">' + (tx.description || '-') + '</td></tr>';\n          }).join('');\n        }\n        \n        document.getElementById('tx-count').textContent = 'Showing ' + Math.min((currentPage + 1) * PAGE_SIZE, totalTransactions) + ' of ' + totalTransactions;\n        document.getElementById('btn-prev').disabled = currentPage === 0;\n        document.getElementById('btn-next').disabled = (currentPage + 1) * PAGE_SIZE >= totalTransactions;\n      } catch (err) {}\n    }\n\n    function prevPage() { if (currentPage > 0) { currentPage--; loadTransactions(); } }\n    function nextPage() { if ((currentPage + 1) * PAGE_SIZE < totalTransactions) { currentPage++; loadTransactions(); } }\n\n    async function loadAdmins() {\n      try {\n        const data = await fetchWithAuth('/admins');\n        const list = document.getElementById('admin-list');\n        if (!data?.length) {\n          list.innerHTML = '<p class=\"text-gray-400\">No admins found</p>';\n        } else {\n          list.innerHTML = data.map(a => '<div class=\"flex items-center justify-between p-3 bg-gray-50 rounded-lg\"><div><p class=\"font-medium\">' + (a.name || a.email) + '</p><p class=\"text-xs text-gray-500\">' + a.email + ' - ' + a.role + '</p></div>' + (adminUser?.role === 'super_admin' && a.email !== adminUser?.email ? '<button onclick=\"removeAdmin(\\\\'' + a.email + '\\\\')\" class=\"text-red-500 text-sm hover:text-red-700\">Remove</button>' : '') + '</div>').join('');\n        }\n      } catch (err) {}\n    }\n\n    async function addAdmin() {\n      const email = document.getElementById('new-admin-email').value.trim();\n      const name = document.getElementById('new-admin-name').value.trim();\n      if (!email) return alert('Please enter an email');\n      \n      try {\n        const res = await fetch(API_BASE + '/admins/add', {\n          method: 'POST',\n          headers: { 'Authorization': 'Bearer ' + accessToken, 'Content-Type': 'application/json' },\n          body: JSON.stringify({ email, name })\n        });\n        const data = await res.json();\n        if (data.success) {\n          document.getElementById('new-admin-email').value = '';\n          document.getElementById('new-admin-name').value = '';\n          loadAdmins();\n        } else {\n          alert(data.error || 'Failed to add admin');\n        }\n      } catch (err) {\n        alert('Error adding admin');\n      }\n    }\n\n    async function removeAdmin(email) {\n      if (!confirm('Remove admin access for ' + email + '?')) return;\n      \n      try {\n        const res = await fetch(API_BASE + '/admins/remove', {\n          method: 'POST',\n          headers: { 'Authorization': 'Bearer ' + accessToken, 'Content-Type': 'application/json' },\n          body: JSON.stringify({ email })\n        });\n        const data = await res.json();\n        if (data.success) loadAdmins();\n        else alert(data.error || 'Failed to remove admin');\n      } catch (err) {\n        alert('Error removing admin');\n      }\n    }\n\n    window.onload = function() {\n      const savedToken = sessionStorage.getItem('adminAccessToken');\n      const savedUser = sessionStorage.getItem('adminUser');\n      const savedExpiry = sessionStorage.getItem('tokenExpiresAt');\n      \n      if (savedToken && savedUser && savedExpiry) {\n        accessToken = savedToken;\n        adminUser = JSON.parse(savedUser);\n        tokenExpiresAt = parseInt(savedExpiry);\n        \n        if (!isTokenExpired()) {\n          document.getElementById('admin-name').textContent = adminUser.name || adminUser.email;\n          document.getElementById('login-screen').classList.add('hidden');\n          document.getElementById('dashboard').classList.remove('hidden');\n          refreshData();\n        } else {\n          logout();\n        }\n      }\n    };\n  </script>\n</body>\n</html>`;\n}\n\nDeno.serve(async (req) => {\n  const url = new URL(req.url);\n  const path = url.pathname.replace(/^\\/admin-dashboard/, \"\");\n  const method = req.method;\n  const authHeader = req.headers.get(\"authorization\");\n\n  if (method === \"OPTIONS\") {\n    return new Response(null, { headers: corsHeaders });\n  }\n\n  try {\n    if (method === \"GET\" && (path === \"\" || path === \"/\")) {\n      const htmlHeaders = new Headers();\n      htmlHeaders.set(\"Content-Type\", \"text/html; charset=utf-8\");\n      htmlHeaders.set(\"Access-Control-Allow-Origin\", \"*\");\n      htmlHeaders.set(\"Access-Control-Allow-Headers\", \"authorization, x-client-info, apikey, content-type\");\n      htmlHeaders.set(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\");\n      return new Response(getAdminDashboardHTML(), { \n        status: 200,\n        headers: htmlHeaders \n      });\n    }\n\n    if (method === \"POST\" && path === \"/login\") {\n      const body = await req.json();\n      return handleLogin(body);\n    }\n\n    if (method === \"POST\" && path === \"/logout\") {\n      return handleLogout(authHeader);\n    }\n\n    if (method === \"GET\" && path === \"/metrics\") {\n      return handleMetrics(authHeader);\n    }\n\n    if (method === \"GET\" && path === \"/buffer\") {\n      return handleBuffer(authHeader);\n    }\n\n    if (method === \"GET\" && path === \"/trends\") {\n      return handleTrends(authHeader);\n    }\n\n    if (method === \"GET\" && path === \"/transactions\") {\n      return handleTransactions(authHeader, url);\n    }\n\n    if (method === \"GET\" && path === \"/admins\") {\n      return handleAdmins(authHeader);\n    }\n\n    if (method === \"POST\" && path === \"/admins/add\") {\n      const body = await req.json();\n      return handleAddAdmin(authHeader, body);\n    }\n\n    if (method === \"POST\" && path === \"/admins/remove\") {\n      const body = await req.json();\n      return handleRemoveAdmin(authHeader, body);\n    }\n\n    return new Response(JSON.stringify({ error: \"Not found\" }), {\n      status: 404,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  } catch (err) {\n    console.error(\"Admin dashboard error:\", err);\n    return new Response(JSON.stringify({ error: \"Internal server error\" }), {\n      status: 500,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" }\n    });\n  }\n});\n","path":null,"size_bytes":48812,"size_tokens":null},"server/services/email.service.ts":{"content":"import nodemailer from 'nodemailer';\n\nconst ADMIN_EMAIL = 'hzeng1217@gmail.com';\n\ninterface WithdrawalEmailData {\n  userId: string;\n  userDatabaseId: string;\n  userName: string;\n  userEmail: string;\n  userPhone: string;\n  amount: number;\n  feeAmount: number;\n  netAmount: number;\n  withdrawalType: 'fast' | 'normal';\n  bankName: string;\n  accountNumber: string;      // Full account number for transfer\n  accountHolderName: string;  // Account holder name\n  accountLast4: string;\n  estimatedArrival: string;\n  transactionId: string;\n  remainingBalance: number;   // User's remaining wallet balance after withdrawal\n}\n\nconst createTransporter = () => {\n  const host = process.env.SMTP_HOST || 'smtp.gmail.com';\n  const port = parseInt(process.env.SMTP_PORT || '587');\n  const user = process.env.SMTP_USER;\n  const pass = process.env.SMTP_PASS;\n\n  if (!user || !pass) {\n    console.warn('Email service: SMTP credentials not configured. Emails will be logged only.');\n    return null;\n  }\n\n  return nodemailer.createTransport({\n    host,\n    port,\n    secure: port === 465,\n    auth: { user, pass }\n  });\n};\n\nexport async function sendWithdrawalNotification(data: WithdrawalEmailData): Promise<boolean> {\n  const transporter = createTransporter();\n\n  const emailContent = `\nNEW WITHDRAWAL REQUEST - SPLINE PAY\n====================================\n\nTransaction ID: ${data.transactionId}\nTime: ${new Date().toLocaleString('en-NZ', { timeZone: 'Pacific/Auckland' })}\n\nUSER DETAILS\n------------\nName: ${data.userName}\nEmail: ${data.userEmail}\nPhone: ${data.userPhone}\nUser ID (Spline ID): ${data.userId}\nDatabase ID: ${data.userDatabaseId}\n\nWITHDRAWAL DETAILS\n------------------\nTransfer Type: ${data.withdrawalType.toUpperCase()} ${data.withdrawalType === 'fast' ? '(3.5% fee)' : '(Free)'}\nAmount Requested: $${data.amount.toFixed(2)}\nFee Deducted: $${data.feeAmount.toFixed(2)}\nNet Amount to Transfer: $${data.netAmount.toFixed(2)}\nRemaining Balance: $${data.remainingBalance.toFixed(2)}\n\nBANK DETAILS (FOR TRANSFER)\n---------------------------\nBank: ${data.bankName}\nAccount Number: ${data.accountNumber || 'Not provided'}\nAccount Holder: ${data.accountHolderName || 'Not provided'}\nEstimated Arrival: ${data.estimatedArrival}\n\nACTION REQUIRED\n---------------\nPlease process this ${data.withdrawalType === 'fast' ? 'FAST (priority)' : 'NORMAL'} transfer of $${data.netAmount.toFixed(2)} to the user's bank account.\n\nOnce processed, update the status in the Admin Dashboard:\nhttps://splinepay.replit.app/admin → Withdrawals → Mark as Completed\n\n====================================\nThis is an automated notification from Spline Pay.\n`;\n\n  const htmlContent = `\n<!DOCTYPE html>\n<html>\n<head>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; }\n    .container { max-width: 600px; margin: 0 auto; padding: 20px; }\n    .header { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: white; padding: 20px; border-radius: 12px 12px 0 0; }\n    .content { background: #f8f9fa; padding: 20px; border-radius: 0 0 12px 12px; }\n    .section { background: white; padding: 15px; margin: 10px 0; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n    .section-title { font-weight: 600; color: #6366f1; margin-bottom: 10px; font-size: 14px; text-transform: uppercase; }\n    .label { color: #666; font-size: 12px; }\n    .value { font-weight: 500; color: #333; }\n    .amount { font-size: 24px; font-weight: 700; color: #10b981; }\n    .fast-badge { background: #8b5cf6; color: white; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; }\n    .normal-badge { background: #6b7280; color: white; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; }\n    .action-box { background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; margin-top: 15px; border-radius: 0 8px 8px 0; }\n    .btn { display: inline-block; background: #6366f1; color: white; padding: 12px 24px; border-radius: 8px; text-decoration: none; font-weight: 600; margin-top: 10px; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <h1 style=\"margin: 0; font-size: 20px;\">New Withdrawal Request</h1>\n      <p style=\"margin: 5px 0 0; opacity: 0.9; font-size: 14px;\">Transaction ID: ${data.transactionId}</p>\n    </div>\n    <div class=\"content\">\n      <div class=\"section\">\n        <div class=\"section-title\">Amount to Transfer</div>\n        <span class=\"${data.withdrawalType === 'fast' ? 'fast-badge' : 'normal-badge'}\">${data.withdrawalType.toUpperCase()}</span>\n        <div class=\"amount\" style=\"margin-top: 10px;\">$${data.netAmount.toFixed(2)}</div>\n        <div class=\"label\" style=\"margin-top: 5px;\">\n          Requested: $${data.amount.toFixed(2)} | Fee: $${data.feeAmount.toFixed(2)}\n        </div>\n      </div>\n      \n      <div class=\"section\">\n        <div class=\"section-title\">User Details</div>\n        <p><span class=\"label\">Name:</span> <span class=\"value\">${data.userName}</span></p>\n        <p><span class=\"label\">Email:</span> <span class=\"value\">${data.userEmail}</span></p>\n        <p><span class=\"label\">Phone:</span> <span class=\"value\">${data.userPhone}</span></p>\n        <p><span class=\"label\">Spline ID:</span> <span class=\"value\" style=\"font-family: monospace; background: #f3f4f6; padding: 2px 6px; border-radius: 4px;\">${data.userId}</span></p>\n        <p><span class=\"label\">Database ID:</span> <span class=\"value\" style=\"font-family: monospace; font-size: 11px; color: #6b7280;\">${data.userDatabaseId}</span></p>\n        <p><span class=\"label\">Remaining Balance:</span> <span class=\"value\" style=\"font-weight: 700; color: #059669;\">$${data.remainingBalance.toFixed(2)}</span></p>\n      </div>\n      \n      <div class=\"section\" style=\"background: #eff6ff; border: 1px solid #3b82f6;\">\n        <div class=\"section-title\" style=\"color: #1d4ed8;\">Bank Details (For Transfer)</div>\n        <p><span class=\"label\">Bank:</span> <span class=\"value\" style=\"font-weight: 700;\">${data.bankName}</span></p>\n        <p><span class=\"label\">Account Number:</span> <span class=\"value\" style=\"font-family: monospace; background: #dbeafe; padding: 4px 8px; border-radius: 4px; font-weight: 700;\">${data.accountNumber || 'Not provided'}</span></p>\n        <p><span class=\"label\">Account Holder:</span> <span class=\"value\" style=\"font-weight: 600;\">${data.accountHolderName || 'Not provided'}</span></p>\n        <p><span class=\"label\">Estimated Arrival:</span> <span class=\"value\">${data.estimatedArrival}</span></p>\n      </div>\n      \n      <div class=\"action-box\">\n        <strong>Action Required</strong>\n        <p style=\"margin: 5px 0 0; font-size: 14px;\">\n          Process this ${data.withdrawalType === 'fast' ? '<strong>PRIORITY</strong>' : 'standard'} transfer of <strong>$${data.netAmount.toFixed(2)}</strong> to the user's bank account.\n        </p>\n        <a href=\"https://splinepay.replit.app/admin\" class=\"btn\">Open Admin Dashboard</a>\n      </div>\n    </div>\n  </div>\n</body>\n</html>\n`;\n\n  if (!transporter) {\n    // Log minimal info without PII when email not configured\n    console.log(`[Email] Withdrawal notification for transaction ${data.transactionId} - SMTP not configured`);\n    console.log(`[Email] Amount: $${data.netAmount.toFixed(2)} (${data.withdrawalType})`);\n    return false;\n  }\n\n  try {\n    await transporter.sendMail({\n      from: process.env.SMTP_FROM || process.env.SMTP_USER,\n      to: ADMIN_EMAIL,\n      subject: `[Spline] New ${data.withdrawalType.toUpperCase()} Withdrawal: $${data.netAmount.toFixed(2)} - ${data.userName}`,\n      text: emailContent,\n      html: htmlContent\n    });\n\n    console.log(`Withdrawal notification email sent to ${ADMIN_EMAIL} for transaction ${data.transactionId}`);\n    return true;\n  } catch (error) {\n    console.error('Failed to send withdrawal notification email:', error);\n    // Log minimal info without PII on failure\n    console.log(`[Email] FALLBACK - Transaction ${data.transactionId}, Amount: $${data.netAmount.toFixed(2)}`);\n    return false;\n  }\n}\n\nexport async function testEmailConnection(): Promise<boolean> {\n  const transporter = createTransporter();\n  if (!transporter) {\n    console.log('Email service not configured - SMTP credentials missing');\n    return false;\n  }\n\n  try {\n    await transporter.verify();\n    console.log('Email service connected successfully');\n    return true;\n  } catch (error) {\n    console.error('Email service connection failed:', error);\n    return false;\n  }\n}\n\ninterface SuspiciousActivityData {\n  userId: string;\n  userName: string;\n  userEmail: string;\n  activityType: string;\n  details: string;\n  timestamp: string;\n}\n\nexport async function sendSuspiciousActivityNotification(data: SuspiciousActivityData): Promise<boolean> {\n  const transporter = createTransporter();\n\n  const emailContent = `\nSUSPICIOUS ACTIVITY DETECTED - SPLINE PAY\n==========================================\n\nTime: ${data.timestamp}\n\nUSER DETAILS\n------------\nName: ${data.userName}\nEmail: ${data.userEmail}\nUser ID: ${data.userId}\n\nACTIVITY DETAILS\n----------------\nType: ${data.activityType}\nDetails: ${data.details}\n\nACTION REQUIRED\n---------------\nReview this user's activity in the Admin Dashboard.\n\n==========================================\nThis is an automated security notification from Spline Pay.\n`;\n\n  const htmlContent = `\n<!DOCTYPE html>\n<html>\n<head>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; }\n    .container { max-width: 600px; margin: 0 auto; padding: 20px; }\n    .header { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; padding: 20px; border-radius: 12px 12px 0 0; }\n    .content { background: #f8f9fa; padding: 20px; border-radius: 0 0 12px 12px; }\n    .section { background: white; padding: 15px; margin: 10px 0; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n    .section-title { font-weight: 600; color: #ef4444; margin-bottom: 10px; font-size: 14px; text-transform: uppercase; }\n    .label { color: #666; font-size: 12px; }\n    .value { font-weight: 500; color: #333; }\n    .warning-box { background: #fef2f2; border-left: 4px solid #ef4444; padding: 15px; margin-top: 15px; border-radius: 0 8px 8px 0; }\n    .btn { display: inline-block; background: #ef4444; color: white; padding: 12px 24px; border-radius: 8px; text-decoration: none; font-weight: 600; margin-top: 10px; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <h1 style=\"margin: 0; font-size: 20px;\">Suspicious Activity Alert</h1>\n      <p style=\"margin: 5px 0 0; opacity: 0.9; font-size: 14px;\">${data.activityType}</p>\n    </div>\n    <div class=\"content\">\n      <div class=\"section\">\n        <div class=\"section-title\">User Details</div>\n        <p><span class=\"label\">Name:</span> <span class=\"value\">${data.userName}</span></p>\n        <p><span class=\"label\">Email:</span> <span class=\"value\">${data.userEmail}</span></p>\n        <p><span class=\"label\">User ID:</span> <span class=\"value\" style=\"font-family: monospace;\">${data.userId}</span></p>\n      </div>\n      \n      <div class=\"section\" style=\"border: 1px solid #fecaca;\">\n        <div class=\"section-title\">Activity Details</div>\n        <p><span class=\"label\">Type:</span> <span class=\"value\" style=\"font-weight: 700; color: #ef4444;\">${data.activityType}</span></p>\n        <p><span class=\"label\">Details:</span> <span class=\"value\">${data.details}</span></p>\n        <p><span class=\"label\">Time:</span> <span class=\"value\">${data.timestamp}</span></p>\n      </div>\n      \n      <div class=\"warning-box\">\n        <strong>Action Required</strong>\n        <p style=\"margin: 5px 0 0; font-size: 14px;\">\n          Review this user's activity in the Admin Dashboard.\n        </p>\n        <a href=\"https://splinepay.replit.app/admin\" class=\"btn\">Open Admin Dashboard</a>\n      </div>\n    </div>\n  </div>\n</body>\n</html>\n`;\n\n  if (!transporter) {\n    console.log(`[Email] Suspicious activity notification - SMTP not configured`);\n    console.log(`[Email] User: ${data.userId}, Type: ${data.activityType}`);\n    return false;\n  }\n\n  try {\n    await transporter.sendMail({\n      from: process.env.SMTP_FROM || process.env.SMTP_USER,\n      to: ADMIN_EMAIL,\n      subject: `[Spline ALERT] Suspicious Activity: ${data.activityType} - ${data.userName}`,\n      text: emailContent,\n      html: htmlContent\n    });\n\n    console.log(`Suspicious activity notification sent for user ${data.userId}`);\n    return true;\n  } catch (error) {\n    console.error('Failed to send suspicious activity notification:', error);\n    return false;\n  }\n}\n\ninterface UserReportData {\n  reportId: string;\n  reporterId: string;\n  reporterName: string;\n  reporterEmail: string;\n  reportedUserId: string;\n  reportedUserName: string;\n  reportedUserEmail: string;\n  reason: string;\n  timestamp: string;\n}\n\nexport async function sendUserReportNotification(data: UserReportData): Promise<boolean> {\n  const transporter = createTransporter();\n\n  const emailContent = `\nNEW USER REPORT - SPLINE PAY\n============================\n\nReport ID: ${data.reportId}\nTime: ${data.timestamp}\n\nREPORTER DETAILS\n----------------\nName: ${data.reporterName}\nEmail: ${data.reporterEmail}\nUser ID: ${data.reporterId}\n\nREPORTED USER\n-------------\nName: ${data.reportedUserName}\nEmail: ${data.reportedUserEmail}\nUser ID: ${data.reportedUserId}\n\nREPORT REASON\n-------------\n${data.reason}\n\nACTION REQUIRED\n---------------\nReview this report in the Admin Dashboard under the Reports tab.\n\n============================\nThis is an automated notification from Spline Pay.\n`;\n\n  const htmlContent = `\n<!DOCTYPE html>\n<html>\n<head>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; }\n    .container { max-width: 600px; margin: 0 auto; padding: 20px; }\n    .header { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; padding: 20px; border-radius: 12px 12px 0 0; }\n    .content { background: #f8f9fa; padding: 20px; border-radius: 0 0 12px 12px; }\n    .section { background: white; padding: 15px; margin: 10px 0; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n    .section-title { font-weight: 600; color: #f59e0b; margin-bottom: 10px; font-size: 14px; text-transform: uppercase; }\n    .label { color: #666; font-size: 12px; }\n    .value { font-weight: 500; color: #333; }\n    .reason-box { background: #fef3c7; border: 1px solid #f59e0b; padding: 15px; border-radius: 8px; margin-top: 10px; }\n    .action-box { background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; margin-top: 15px; border-radius: 0 8px 8px 0; }\n    .btn { display: inline-block; background: #f59e0b; color: white; padding: 12px 24px; border-radius: 8px; text-decoration: none; font-weight: 600; margin-top: 10px; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <h1 style=\"margin: 0; font-size: 20px;\">User Report Submitted</h1>\n      <p style=\"margin: 5px 0 0; opacity: 0.9; font-size: 14px;\">Report ID: ${data.reportId}</p>\n    </div>\n    <div class=\"content\">\n      <div class=\"section\">\n        <div class=\"section-title\">Reporter</div>\n        <p><span class=\"label\">Name:</span> <span class=\"value\">${data.reporterName}</span></p>\n        <p><span class=\"label\">Email:</span> <span class=\"value\">${data.reporterEmail}</span></p>\n        <p><span class=\"label\">User ID:</span> <span class=\"value\" style=\"font-family: monospace; font-size: 11px;\">${data.reporterId}</span></p>\n      </div>\n      \n      <div class=\"section\" style=\"border: 1px solid #fecaca;\">\n        <div class=\"section-title\" style=\"color: #dc2626;\">Reported User</div>\n        <p><span class=\"label\">Name:</span> <span class=\"value\" style=\"font-weight: 700;\">${data.reportedUserName}</span></p>\n        <p><span class=\"label\">Email:</span> <span class=\"value\">${data.reportedUserEmail}</span></p>\n        <p><span class=\"label\">User ID:</span> <span class=\"value\" style=\"font-family: monospace; font-size: 11px;\">${data.reportedUserId}</span></p>\n      </div>\n      \n      <div class=\"section\">\n        <div class=\"section-title\">Report Reason</div>\n        <div class=\"reason-box\">\n          ${data.reason}\n        </div>\n      </div>\n      \n      <div class=\"action-box\">\n        <strong>Action Required</strong>\n        <p style=\"margin: 5px 0 0; font-size: 14px;\">\n          Review this report in the Admin Dashboard.\n        </p>\n        <a href=\"https://splinepay.replit.app/admin\" class=\"btn\">Open Admin Dashboard</a>\n      </div>\n    </div>\n  </div>\n</body>\n</html>\n`;\n\n  if (!transporter) {\n    console.log(`[Email] User report notification - SMTP not configured`);\n    console.log(`[Email] Report ID: ${data.reportId}, Reporter: ${data.reporterId}, Reported: ${data.reportedUserId}`);\n    return false;\n  }\n\n  try {\n    await transporter.sendMail({\n      from: process.env.SMTP_FROM || process.env.SMTP_USER,\n      to: ADMIN_EMAIL,\n      subject: `[Spline REPORT] User Reported: ${data.reportedUserName} by ${data.reporterName}`,\n      text: emailContent,\n      html: htmlContent\n    });\n\n    console.log(`User report notification sent for report ${data.reportId}`);\n    return true;\n  } catch (error) {\n    console.error('Failed to send user report notification:', error);\n    return false;\n  }\n}\n\ninterface VoucherClaimData {\n  userId: string;\n  userName: string;\n  userEmail: string;\n  userPhone: string;\n  level: number;\n  voucherType: string;\n  voucherValue: string;\n  claimedAt: string;\n}\n\nexport async function sendVoucherClaimNotification(data: VoucherClaimData): Promise<boolean> {\n  const transporter = createTransporter();\n\n  const emailContent = `\nNEW VOUCHER CLAIM - SPLINE PAY\n==============================\n\nTime: ${data.claimedAt}\n\nUSER DETAILS\n------------\nName: ${data.userName}\nEmail: ${data.userEmail}\nPhone: ${data.userPhone}\nUser ID: ${data.userId}\nLevel: ${data.level}\n\nVOUCHER DETAILS\n---------------\nType: ${data.voucherType}\nValue: ${data.voucherValue}\n\nACTION REQUIRED\n---------------\nContact the user to arrange their personalized dining experience.\nCollect dietary requirements and preferences.\n\n==============================\nThis is an automated notification from Spline Pay.\n`;\n\n  const htmlContent = `\n<!DOCTYPE html>\n<html>\n<head>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; }\n    .container { max-width: 600px; margin: 0 auto; padding: 20px; }\n    .header { background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 20px; border-radius: 12px 12px 0 0; }\n    .content { background: #f8f9fa; padding: 20px; border-radius: 0 0 12px 12px; }\n    .section { background: white; padding: 15px; margin: 10px 0; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n    .section-title { font-weight: 600; color: #10b981; margin-bottom: 10px; font-size: 14px; text-transform: uppercase; }\n    .label { color: #666; font-size: 12px; }\n    .value { font-weight: 500; color: #333; }\n    .voucher-value { font-size: 24px; font-weight: 700; color: #10b981; }\n    .level-badge { background: #9370DB; color: white; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; }\n    .action-box { background: #ecfdf5; border-left: 4px solid #10b981; padding: 15px; margin-top: 15px; border-radius: 0 8px 8px 0; }\n    .btn { display: inline-block; background: #10b981; color: white; padding: 12px 24px; border-radius: 8px; text-decoration: none; font-weight: 600; margin-top: 10px; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <h1 style=\"margin: 0; font-size: 20px;\">New Voucher Claim</h1>\n      <p style=\"margin: 5px 0 0; opacity: 0.9; font-size: 14px;\">${data.voucherType}</p>\n    </div>\n    <div class=\"content\">\n      <div class=\"section\">\n        <div class=\"section-title\">Voucher Details</div>\n        <div class=\"voucher-value\">${data.voucherValue}</div>\n        <p style=\"margin-top: 10px;\"><span class=\"label\">Type:</span> <span class=\"value\">${data.voucherType}</span></p>\n      </div>\n      \n      <div class=\"section\">\n        <div class=\"section-title\">User Details</div>\n        <p><span class=\"label\">Name:</span> <span class=\"value\">${data.userName}</span></p>\n        <p><span class=\"label\">Email:</span> <span class=\"value\">${data.userEmail}</span></p>\n        <p><span class=\"label\">Phone:</span> <span class=\"value\">${data.userPhone}</span></p>\n        <p><span class=\"label\">Level:</span> <span class=\"level-badge\">Level ${data.level}</span></p>\n        <p><span class=\"label\">User ID:</span> <span class=\"value\" style=\"font-family: monospace; font-size: 11px;\">${data.userId}</span></p>\n      </div>\n      \n      <div class=\"action-box\">\n        <strong>Action Required</strong>\n        <p style=\"margin: 5px 0 0; font-size: 14px;\">\n          Contact the user to arrange their personalized dining experience.\n          <br/>Collect dietary requirements and preferences.\n        </p>\n        <a href=\"mailto:${data.userEmail}\" class=\"btn\">Email User</a>\n      </div>\n    </div>\n  </div>\n</body>\n</html>\n`;\n\n  if (!transporter) {\n    console.log(`[Email] Voucher claim notification - SMTP not configured`);\n    console.log(`[Email] User: ${data.userId}, Voucher: ${data.voucherValue}`);\n    return false;\n  }\n\n  try {\n    await transporter.sendMail({\n      from: process.env.SMTP_FROM || process.env.SMTP_USER,\n      to: ADMIN_EMAIL,\n      subject: `[Spline] Voucher Claimed: ${data.voucherValue} - ${data.userName}`,\n      text: emailContent,\n      html: htmlContent\n    });\n\n    console.log(`Voucher claim notification sent for user ${data.userId}`);\n    return true;\n  } catch (error) {\n    console.error('Failed to send voucher claim notification:', error);\n    return false;\n  }\n}\n","path":null,"size_bytes":21918,"size_tokens":null},"server/routes/stripe.routes.ts":{"content":"import express from 'express';\nimport Stripe from 'stripe';\nimport { createClient } from '@supabase/supabase-js';\n\nconst router = express.Router();\n\nconst stripeLive = new Stripe(process.env.STRIPE_SECRET_KEY || '');\nconst stripeTest = new Stripe(process.env.STRIPE_TEST_SECRET_KEY || '');\n\nfunction getStripeInstance(testMode: boolean): Stripe {\n  return testMode ? stripeTest : stripeLive;\n}\n\nfunction getPublishableKey(testMode: boolean): string {\n  return testMode \n    ? (process.env.STRIPE_TEST_PUBLISHABLE_KEY || '')\n    : (process.env.STRIPE_PUBLISHABLE_KEY || '');\n}\n\nconst supabaseAdmin = createClient(\n  process.env.EXPO_PUBLIC_SUPABASE_URL || '',\n  process.env.SUPABASE_SERVICE_ROLE_KEY || ''\n);\n\ninterface AuthenticatedRequest extends express.Request {\n  user?: { id: string; email: string };\n  stripeTestMode?: boolean;\n}\n\nasync function verifyUserToken(token: string): Promise<{ id: string; email: string } | null> {\n  try {\n    const { data, error } = await supabaseAdmin.auth.getUser(token);\n    \n    if (error || !data.user) {\n      console.error('Token verification failed:', error?.message);\n      return null;\n    }\n    \n    return { id: data.user.id, email: data.user.email || '' };\n  } catch (err) {\n    console.error('Token verification error:', err);\n    return null;\n  }\n}\n\nasync function checkUserTestMode(userId: string): Promise<boolean> {\n  try {\n    const { data: wallet } = await supabaseAdmin\n      .from('wallets')\n      .select('stripe_test_mode')\n      .eq('user_id', userId)\n      .single();\n    \n    return wallet?.stripe_test_mode === true;\n  } catch (err) {\n    return false;\n  }\n}\n\nrouter.get('/publishable-key', (req, res) => {\n  const publishableKey = process.env.STRIPE_PUBLISHABLE_KEY || '';\n  if (!publishableKey) {\n    return res.status(500).json({ error: 'Stripe publishable key not configured' });\n  }\n  res.json({ publishableKey });\n});\n\nrouter.get('/user-publishable-key', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  const testMode = req.stripeTestMode || false;\n  const publishableKey = getPublishableKey(testMode);\n  \n  if (!publishableKey) {\n    return res.status(500).json({ error: 'Stripe publishable key not configured' });\n  }\n  \n  res.json({ publishableKey, testMode });\n});\n\nfunction userAuthMiddleware(\n  req: AuthenticatedRequest,\n  res: express.Response,\n  next: express.NextFunction\n) {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return res.status(401).json({ error: 'Authentication required' });\n  }\n  \n  const token = authHeader.replace('Bearer ', '');\n  \n  verifyUserToken(token).then(async user => {\n    if (!user) {\n      return res.status(401).json({ error: 'Invalid or expired token' });\n    }\n    \n    req.user = user;\n    req.stripeTestMode = await checkUserTestMode(user.id);\n    next();\n  }).catch(err => {\n    console.error('Auth middleware error:', err);\n    res.status(500).json({ error: 'Authentication error' });\n  });\n}\n\n\nrouter.post('/create-customer', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { email, name } = req.body;\n    const userId = req.user!.id;\n    const testMode = req.stripeTestMode || false;\n    const stripe = getStripeInstance(testMode);\n\n    const customer = await stripe.customers.create({\n      email: email || req.user!.email,\n      name,\n      metadata: {\n        spline_user_id: userId,\n        test_mode: testMode ? 'true' : 'false',\n      },\n    });\n\n    console.log(`Created Stripe customer ${customer.id} for user ${userId} (testMode: ${testMode})`);\n\n    res.json({ customerId: customer.id, testMode });\n  } catch (error: any) {\n    console.error('Error creating Stripe customer:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/create-setup-intent', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { customerId } = req.body;\n    const userId = req.user!.id;\n    const testMode = req.stripeTestMode || false;\n\n    if (!customerId) {\n      return res.status(400).json({ error: 'Customer ID is required' });\n    }\n\n    const stripe = getStripeInstance(testMode);\n\n    const setupIntent = await stripe.setupIntents.create({\n      customer: customerId,\n      payment_method_types: ['card'],\n      usage: 'off_session',\n    });\n\n    console.log(`Created SetupIntent ${setupIntent.id} for user ${userId} (testMode: ${testMode})`);\n\n    res.json({\n      clientSecret: setupIntent.client_secret,\n      setupIntentId: setupIntent.id,\n      testMode,\n    });\n  } catch (error: any) {\n    console.error('Error creating SetupIntent:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/confirm-setup', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { setupIntentId } = req.body;\n    const userId = req.user!.id;\n    const testMode = req.stripeTestMode || false;\n\n    if (!setupIntentId) {\n      return res.status(400).json({ error: 'SetupIntent ID is required' });\n    }\n\n    const stripe = getStripeInstance(testMode);\n\n    const setupIntent = await stripe.setupIntents.retrieve(setupIntentId);\n\n    if (setupIntent.status !== 'succeeded') {\n      return res.status(400).json({ \n        error: 'SetupIntent not confirmed',\n        status: setupIntent.status \n      });\n    }\n\n    const paymentMethodId = setupIntent.payment_method as string;\n    const paymentMethod = await stripe.paymentMethods.retrieve(paymentMethodId);\n\n    console.log(`Confirmed setup ${setupIntentId} for user ${userId} (testMode: ${testMode})`);\n\n    res.json({\n      paymentMethodId,\n      card: {\n        brand: paymentMethod.card?.brand,\n        last4: paymentMethod.card?.last4,\n        exp_month: paymentMethod.card?.exp_month,\n        exp_year: paymentMethod.card?.exp_year,\n      },\n      testMode,\n    });\n  } catch (error: any) {\n    console.error('Error confirming setup:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/charge', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { customerId, paymentMethodId, amount, description, metadata } = req.body;\n    const userId = req.user?.id;\n    const testMode = req.stripeTestMode || false;\n\n    if (!customerId || !paymentMethodId || !amount) {\n      return res.status(400).json({ \n        error: 'Customer ID, payment method ID, and amount are required' \n      });\n    }\n\n    const stripe = getStripeInstance(testMode);\n    const amountInCents = Math.round(amount * 100);\n\n    const paymentIntent = await stripe.paymentIntents.create({\n      amount: amountInCents,\n      currency: 'nzd',\n      customer: customerId,\n      payment_method: paymentMethodId,\n      off_session: true,\n      confirm: true,\n      description: description || 'Spline payment',\n      metadata: { ...(metadata || {}), test_mode: testMode ? 'true' : 'false', user_id: userId || '' },\n    });\n\n    console.log(`Stripe charge ${paymentIntent.id}: $${amount} by user ${userId} (testMode: ${testMode})`);\n\n    if (paymentIntent.status === 'succeeded') {\n      res.json({\n        success: true,\n        paymentIntentId: paymentIntent.id,\n        status: paymentIntent.status,\n        testMode,\n      });\n    } else {\n      res.status(400).json({\n        success: false,\n        status: paymentIntent.status,\n        error: 'Payment not completed',\n      });\n    }\n  } catch (error: any) {\n    console.error('Error charging card:', error);\n    \n    if (error.type === 'StripeCardError') {\n      res.status(400).json({\n        error: error.message,\n        code: error.code,\n        decline_code: error.decline_code,\n      });\n    } else {\n      res.status(500).json({ error: error.message });\n    }\n  }\n});\n\nrouter.get('/payment-method/:id', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { id } = req.params;\n    const testMode = req.stripeTestMode || false;\n    const stripe = getStripeInstance(testMode);\n    \n    const paymentMethod = await stripe.paymentMethods.retrieve(id);\n\n    res.json({\n      id: paymentMethod.id,\n      card: {\n        brand: paymentMethod.card?.brand,\n        last4: paymentMethod.card?.last4,\n        exp_month: paymentMethod.card?.exp_month,\n        exp_year: paymentMethod.card?.exp_year,\n      },\n    });\n  } catch (error: any) {\n    console.error('Error retrieving payment method:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.delete('/payment-method/:id', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { id } = req.params;\n    const testMode = req.stripeTestMode || false;\n    const stripe = getStripeInstance(testMode);\n    \n    await stripe.paymentMethods.detach(id);\n    res.json({ success: true });\n  } catch (error: any) {\n    console.error('Error detaching payment method:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/initiate-card-setup', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { email, name, customerId: existingCustomerId } = req.body;\n    const userId = req.user!.id;\n    const testMode = req.stripeTestMode || false;\n    const stripe = getStripeInstance(testMode);\n    const publishableKey = getPublishableKey(testMode);\n\n    let customerId = existingCustomerId;\n\n    if (!customerId) {\n      const customer = await stripe.customers.create({\n        email: email || req.user!.email,\n        name,\n        metadata: {\n          spline_user_id: userId,\n          test_mode: testMode ? 'true' : 'false',\n        },\n      });\n      customerId = customer.id;\n    }\n\n    const setupIntent = await stripe.setupIntents.create({\n      customer: customerId,\n      payment_method_types: ['card'],\n      usage: 'off_session',\n    });\n\n    const forwardedHost = req.get('x-forwarded-host');\n    const forwardedProto = req.get('x-forwarded-proto') || 'https';\n    const directHost = req.get('host') || 'localhost:8082';\n    \n    let baseUrl: string;\n    if (forwardedHost) {\n      baseUrl = `${forwardedProto}://${forwardedHost}`;\n    } else if (directHost.includes('localhost')) {\n      baseUrl = `http://${directHost}`;\n    } else {\n      baseUrl = 'https://splinepay.replit.app';\n    }\n    \n    console.log(`Card setup for user ${userId}: ${setupIntent.id} (testMode: ${testMode})`);\n\n    const cardSetupUrl = `${baseUrl}/card-setup.html?` + \n      `client_secret=${setupIntent.client_secret}` +\n      `&setup_intent_id=${setupIntent.id}` +\n      `&user_id=${userId}` +\n      `&pk=${publishableKey}` +\n      `&return_url=splitpaymentapp://stripe-callback`;\n\n    res.json({\n      customerId,\n      setupIntentId: setupIntent.id,\n      cardSetupUrl,\n      testMode,\n    });\n  } catch (error: any) {\n    console.error('Error initiating card setup:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/create-native-setup-intent', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { email, name, customerId: existingCustomerId } = req.body;\n    const userId = req.user!.id;\n    const testMode = req.stripeTestMode || false;\n    const stripe = getStripeInstance(testMode);\n    const publishableKey = getPublishableKey(testMode);\n\n    let customerId = existingCustomerId;\n\n    if (!customerId) {\n      const customer = await stripe.customers.create({\n        email: email || req.user!.email,\n        name,\n        metadata: {\n          spline_user_id: userId,\n          test_mode: testMode ? 'true' : 'false',\n        },\n      });\n      customerId = customer.id;\n    }\n\n    const setupIntent = await stripe.setupIntents.create({\n      customer: customerId,\n      payment_method_types: ['card'],\n      usage: 'off_session',\n    });\n\n    console.log(`Native setup intent for user ${userId}: ${setupIntent.id} (testMode: ${testMode})`);\n\n    res.json({\n      customerId,\n      setupIntentId: setupIntent.id,\n      clientSecret: setupIntent.client_secret,\n      publishableKey,\n      testMode,\n    });\n  } catch (error: any) {\n    console.error('Error creating native setup intent:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/verify-native-setup', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { paymentMethodId, customerId, setupIntentId } = req.body;\n    const authenticatedUserId = req.user!.id;\n    const testMode = req.stripeTestMode || false;\n    const stripe = getStripeInstance(testMode);\n\n    if (!paymentMethodId || !customerId || !setupIntentId) {\n      return res.status(400).json({ error: 'Payment method ID, customer ID, and setup intent ID are required' });\n    }\n\n    const customer = await stripe.customers.retrieve(customerId);\n    if (!customer || customer.deleted) {\n      return res.status(400).json({ error: 'Invalid customer' });\n    }\n\n    if ((customer as Stripe.Customer).metadata?.spline_user_id !== authenticatedUserId) {\n      console.error(`User ID mismatch: authenticated ${authenticatedUserId}, customer metadata ${(customer as Stripe.Customer).metadata?.spline_user_id}`);\n      return res.status(403).json({ error: 'Unauthorized: You do not own this payment customer' });\n    }\n\n    const setupIntent = await stripe.setupIntents.retrieve(setupIntentId);\n\n    if (setupIntent.status !== 'succeeded') {\n      return res.status(400).json({ \n        error: 'Setup intent not confirmed',\n        status: setupIntent.status \n      });\n    }\n\n    if (setupIntent.customer !== customerId) {\n      return res.status(400).json({ error: 'Customer mismatch' });\n    }\n\n    if (setupIntent.payment_method !== paymentMethodId) {\n      return res.status(400).json({ error: 'Payment method mismatch' });\n    }\n\n    const paymentMethod = await stripe.paymentMethods.retrieve(paymentMethodId);\n\n    if (!paymentMethod || !paymentMethod.card) {\n      return res.status(400).json({ error: 'Invalid payment method' });\n    }\n\n    await stripe.customers.update(customerId, {\n      invoice_settings: {\n        default_payment_method: paymentMethodId,\n      },\n    });\n\n    console.log(`Verified native setup for user ${authenticatedUserId}: ${paymentMethodId} (testMode: ${testMode})`);\n\n    res.json({\n      success: true,\n      paymentMethodId,\n      card: {\n        brand: paymentMethod.card.brand || 'card',\n        last4: paymentMethod.card.last4 || '****',\n        exp_month: paymentMethod.card.exp_month,\n        exp_year: paymentMethod.card.exp_year,\n      },\n      testMode,\n    });\n  } catch (error: any) {\n    console.error('Error verifying native setup:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/process-split-payment', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const userId = req.user?.id;\n    if (!userId) {\n      return res.status(401).json({ error: 'User not authenticated' });\n    }\n\n    const { amount, splitEventId, description } = req.body;\n\n    if (!amount || amount <= 0) {\n      return res.status(400).json({ success: false, error: 'Amount must be greater than zero' });\n    }\n\n    if (!splitEventId) {\n      return res.status(400).json({ success: false, error: 'Split event ID is required' });\n    }\n\n    const { data: wallet, error: walletError } = await supabaseAdmin\n      .from('wallets')\n      .select('id, balance')\n      .eq('user_id', userId)\n      .single();\n\n    if (walletError || !wallet) {\n      console.error('Wallet not found:', walletError);\n      return res.status(400).json({ success: false, error: 'Wallet not found' });\n    }\n\n    const currentBalance = parseFloat(wallet.balance?.toString() || '0');\n\n    if (currentBalance < amount) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Insufficient balance',\n        current_balance: currentBalance\n      });\n    }\n\n    const newBalance = currentBalance - amount;\n\n    const { error: updateError } = await supabaseAdmin\n      .from('wallets')\n      .update({ \n        balance: newBalance,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', wallet.id)\n      .eq('balance', currentBalance);\n\n    if (updateError) {\n      console.error('Failed to update wallet:', updateError);\n      return res.status(500).json({ success: false, error: 'Failed to update wallet balance' });\n    }\n\n    const { data: transaction, error: txError } = await supabaseAdmin\n      .from('transactions')\n      .insert({\n        user_id: userId,\n        type: 'split_payment',\n        amount: amount,\n        description: description || 'Split payment',\n        direction: 'out',\n        split_event_id: splitEventId,\n        metadata: { split_event_id: splitEventId, payer_id: userId }\n      })\n      .select('id')\n      .single();\n\n    if (txError) {\n      console.error('Failed to log transaction:', txError);\n      await supabaseAdmin\n        .from('wallets')\n        .update({ balance: currentBalance })\n        .eq('id', wallet.id);\n      return res.status(500).json({ success: false, error: 'Failed to log transaction' });\n    }\n\n    console.log(`Split payment: $${amount} from user ${userId}, new balance: $${newBalance}`);\n\n    res.json({\n      success: true,\n      new_balance: newBalance,\n      transaction_id: transaction.id\n    });\n  } catch (error: any) {\n    console.error('Error processing split payment:', error);\n    res.status(500).json({ success: false, error: error.message });\n  }\n});\n\nexport default router;\n","path":null,"size_bytes":17420,"size_tokens":null},"services/stripe.service.ts":{"content":"import { supabase } from './supabase';\nimport { Platform } from 'react-native';\nimport Constants from 'expo-constants';\nimport { resolveBackendOrigin } from '../utils/backend';\n\n// Use centralized backend URL resolution that handles all platforms properly\nconst SERVER_URL = resolveBackendOrigin();\n\ninterface CardDetails {\n  brand: string;\n  last4: string;\n  exp_month: number;\n  exp_year: number;\n}\n\ninterface StripeCustomerResponse {\n  customerId: string;\n}\n\ninterface SetupIntentResponse {\n  clientSecret: string;\n  setupIntentId: string;\n}\n\ninterface ConfirmSetupResponse {\n  paymentMethodId: string;\n  card: CardDetails;\n}\n\ninterface ChargeResponse {\n  success: boolean;\n  paymentIntentId: string;\n  status: string;\n}\n\nexport class StripeService {\n  private static async getAuthToken(): Promise<string> {\n    const { data: sessionData } = await supabase.auth.getSession();\n    const accessToken = sessionData?.session?.access_token;\n    if (!accessToken) {\n      throw new Error('Authentication required. Please log in again.');\n    }\n    return accessToken;\n  }\n\n  static async createCustomer(\n    email: string, \n    name: string\n  ): Promise<string> {\n    const accessToken = await this.getAuthToken();\n    \n    const response = await fetch(`${SERVER_URL}/api/stripe/create-customer`, {\n      method: 'POST',\n      headers: { \n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({ email, name }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to create Stripe customer');\n    }\n\n    const data: StripeCustomerResponse = await response.json();\n    return data.customerId;\n  }\n\n  static async createSetupIntent(customerId: string): Promise<SetupIntentResponse> {\n    const accessToken = await this.getAuthToken();\n    \n    const response = await fetch(`${SERVER_URL}/api/stripe/create-setup-intent`, {\n      method: 'POST',\n      headers: { \n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({ customerId }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to create SetupIntent');\n    }\n\n    return response.json();\n  }\n\n  static async confirmSetup(setupIntentId: string): Promise<ConfirmSetupResponse> {\n    const accessToken = await this.getAuthToken();\n    \n    const response = await fetch(`${SERVER_URL}/api/stripe/confirm-setup`, {\n      method: 'POST',\n      headers: { \n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({ setupIntentId }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to confirm card setup');\n    }\n\n    return response.json();\n  }\n\n  static async chargeCard(\n    customerId: string,\n    paymentMethodId: string,\n    amount: number,\n    description: string,\n    metadata?: Record<string, string>\n  ): Promise<ChargeResponse> {\n    const { data: sessionData } = await supabase.auth.getSession();\n    const accessToken = sessionData?.session?.access_token;\n    \n    if (!accessToken) {\n      throw new Error('Authentication required. Please log in again.');\n    }\n    \n    const response = await fetch(`${SERVER_URL}/api/stripe/charge`, {\n      method: 'POST',\n      headers: { \n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({\n        customerId,\n        paymentMethodId,\n        amount,\n        description,\n        metadata,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Payment failed');\n    }\n\n    return response.json();\n  }\n\n  static async getOrCreateCustomer(\n    userId: string,\n    email: string,\n    name: string\n  ): Promise<string> {\n    const { data: wallet } = await supabase\n      .from('wallets')\n      .select('stripe_customer_id')\n      .eq('user_id', userId)\n      .single();\n\n    if (wallet?.stripe_customer_id) {\n      return wallet.stripe_customer_id;\n    }\n\n    const customerId = await this.createCustomer(email, name);\n\n    await supabase\n      .from('wallets')\n      .update({ stripe_customer_id: customerId })\n      .eq('user_id', userId);\n\n    return customerId;\n  }\n\n  static async savePaymentMethod(\n    userId: string,\n    paymentMethodId: string,\n    cardBrand: string,\n    cardLast4: string\n  ): Promise<void> {\n    const { error } = await supabase\n      .from('wallets')\n      .update({\n        stripe_payment_method_id: paymentMethodId,\n        card_brand: cardBrand,\n        card_last4: cardLast4,\n        bank_connected: true,\n      })\n      .eq('user_id', userId);\n\n    if (error) {\n      throw new Error('Failed to save payment method');\n    }\n  }\n\n  static async removePaymentMethod(userId: string): Promise<void> {\n    const { data: wallet } = await supabase\n      .from('wallets')\n      .select('stripe_payment_method_id')\n      .eq('user_id', userId)\n      .single();\n\n    if (wallet?.stripe_payment_method_id) {\n      try {\n        const { data: sessionData } = await supabase.auth.getSession();\n        const accessToken = sessionData?.session?.access_token;\n        \n        if (accessToken) {\n          await fetch(`${SERVER_URL}/api/stripe/payment-method/${wallet.stripe_payment_method_id}`, {\n            method: 'DELETE',\n            headers: {\n              'Authorization': `Bearer ${accessToken}`,\n            },\n          });\n        }\n      } catch (error) {\n        console.error('Error removing payment method from Stripe:', error);\n      }\n    }\n\n    await supabase\n      .from('wallets')\n      .update({\n        stripe_payment_method_id: null,\n        card_brand: null,\n        card_last4: null,\n        bank_connected: false,\n      })\n      .eq('user_id', userId);\n  }\n\n  static async hasPaymentMethod(userId: string): Promise<boolean> {\n    const { data: wallet } = await supabase\n      .from('wallets')\n      .select('stripe_payment_method_id')\n      .eq('user_id', userId)\n      .single();\n\n    return !!wallet?.stripe_payment_method_id;\n  }\n\n  static async getPaymentMethodDetails(userId: string): Promise<{\n    brand: string;\n    last4: string;\n  } | null> {\n    const { data: wallet } = await supabase\n      .from('wallets')\n      .select('card_brand, card_last4')\n      .eq('user_id', userId)\n      .single();\n\n    if (!wallet?.card_brand || !wallet?.card_last4) {\n      return null;\n    }\n\n    return {\n      brand: wallet.card_brand,\n      last4: wallet.card_last4,\n    };\n  }\n\n  static async initiateCardSetup(\n    email: string,\n    name: string,\n    existingCustomerId?: string\n  ): Promise<{ customerId: string; setupIntentId: string; cardSetupUrl: string }> {\n    console.log('Initiating card setup with SERVER_URL:', SERVER_URL);\n    \n    const accessToken = await this.getAuthToken();\n    \n    const response = await fetch(`${SERVER_URL}/api/stripe/initiate-card-setup`, {\n      method: 'POST',\n      headers: { \n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({ \n        email, \n        name,\n        customerId: existingCustomerId \n      }),\n    });\n\n    const contentType = response.headers.get('content-type');\n    if (!contentType || !contentType.includes('application/json')) {\n      console.error('Server returned non-JSON response:', contentType);\n      throw new Error('Server connection error. Please try again.');\n    }\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to initiate card setup');\n    }\n\n    return response.json();\n  }\n\n  static async createNativeSetupIntent(\n    email: string,\n    name: string,\n    existingCustomerId?: string\n  ): Promise<{ customerId: string; setupIntentId: string; clientSecret: string; publishableKey?: string; testMode?: boolean }> {\n    console.log('Creating native setup intent with SERVER_URL:', SERVER_URL);\n    \n    const accessToken = await this.getAuthToken();\n    \n    const response = await fetch(`${SERVER_URL}/api/stripe/create-native-setup-intent`, {\n      method: 'POST',\n      headers: { \n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({ \n        email, \n        name,\n        customerId: existingCustomerId \n      }),\n    });\n\n    const contentType = response.headers.get('content-type');\n    if (!contentType || !contentType.includes('application/json')) {\n      console.error('Server returned non-JSON response:', contentType);\n      throw new Error('Server connection error. Please try again.');\n    }\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to create setup intent');\n    }\n\n    return response.json();\n  }\n\n  static async verifyAndSaveNativeCardSetup(\n    userId: string,\n    paymentMethodId: string,\n    customerId: string,\n    setupIntentId: string\n  ): Promise<{ brand: string; last4: string }> {\n    const { data: sessionData } = await supabase.auth.getSession();\n    const accessToken = sessionData?.session?.access_token;\n    \n    if (!accessToken) {\n      throw new Error('Authentication required. Please log in again.');\n    }\n    \n    let response: Response;\n    try {\n      response = await fetch(`${SERVER_URL}/api/stripe/verify-native-setup`, {\n        method: 'POST',\n        headers: { \n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${accessToken}`,\n        },\n        body: JSON.stringify({ paymentMethodId, customerId, setupIntentId }),\n      });\n    } catch (networkError) {\n      console.error('Network error during verification:', networkError);\n      throw new Error('Network error. Please check your connection and try again.');\n    }\n\n    const contentType = response.headers.get('content-type');\n    if (!contentType || !contentType.includes('application/json')) {\n      console.error('Server returned non-JSON response:', contentType);\n      throw new Error('Server connection error. Please try again.');\n    }\n\n    let responseData;\n    try {\n      responseData = await response.json();\n    } catch (parseError) {\n      console.error('Failed to parse server response:', parseError);\n      throw new Error('Invalid server response. Please try again.');\n    }\n\n    if (!response.ok) {\n      throw new Error(responseData.error || 'Failed to verify card setup');\n    }\n\n    const { card } = responseData;\n    if (!card || !card.brand || !card.last4) {\n      throw new Error('Invalid card details received from server');\n    }\n\n    const { error: updateError } = await supabase\n      .from('wallets')\n      .update({\n        stripe_customer_id: customerId,\n        stripe_payment_method_id: paymentMethodId,\n        card_brand: card.brand,\n        card_last4: card.last4,\n        bank_connected: true,\n      })\n      .eq('user_id', userId);\n\n    if (updateError) {\n      console.error('Failed to update wallet:', updateError);\n      throw new Error('Failed to save card details. Please try again.');\n    }\n\n    return { brand: card.brand, last4: card.last4 };\n  }\n\n  static async completeCardSetup(\n    userId: string,\n    setupIntentId: string,\n    paymentMethodId: string,\n    customerId: string\n  ): Promise<void> {\n    const response = await fetch(`${SERVER_URL}/api/stripe/confirm-setup`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ setupIntentId }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to confirm card setup');\n    }\n\n    const { card } = await response.json();\n\n    await supabase\n      .from('wallets')\n      .update({\n        stripe_customer_id: customerId,\n        stripe_payment_method_id: paymentMethodId,\n        card_brand: card.brand,\n        card_last4: card.last4,\n        bank_connected: true,\n      })\n      .eq('user_id', userId);\n  }\n\n  /**\n   * Process split payment via server-side API\n   * This bypasses Supabase RPC schema cache issues\n   */\n  static async processSplitPayment(\n    amount: number,\n    splitEventId: string,\n    description: string\n  ): Promise<{ success: boolean; new_balance?: number; transaction_id?: string; error?: string }> {\n    try {\n      // Get auth token\n      const { data: { session } } = await supabase.auth.getSession();\n      if (!session?.access_token) {\n        return { success: false, error: 'Not authenticated' };\n      }\n\n      const response = await fetch(`${SERVER_URL}/api/stripe/process-split-payment`, {\n        method: 'POST',\n        headers: { \n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session.access_token}`\n        },\n        body: JSON.stringify({ amount, splitEventId, description }),\n      });\n\n      const data = await response.json();\n      \n      if (!response.ok) {\n        return { \n          success: false, \n          error: data.error || 'Failed to process payment'\n        };\n      }\n\n      return data;\n    } catch (error: any) {\n      console.error('Split payment API error:', error);\n      return { success: false, error: error.message || 'Network error' };\n    }\n  }\n}\n","path":null,"size_bytes":13406,"size_tokens":null},"components/CardInputModal.tsx":{"content":"import React, { useState } from 'react';\nimport { View, StyleSheet, Modal, Pressable, Platform } from 'react-native';\nimport { ThemedText } from '@/components/ThemedText';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { Feather } from '@expo/vector-icons';\n\ninterface CardInputModalProps {\n  visible: boolean;\n  onClose: () => void;\n  onSuccess: (paymentMethodId: string, cardDetails: { brand: string; last4: string }) => void;\n  clientSecret: string;\n  customerId: string;\n  setupIntentId: string;\n}\n\nlet NativeCardInputModal: React.ComponentType<CardInputModalProps> | null = null;\n\nif (Platform.OS !== 'web') {\n  NativeCardInputModal = require('./CardInputModal.native').CardInputModal;\n}\n\nexport function CardInputModal(props: CardInputModalProps) {\n  const { theme } = useTheme();\n\n  if (Platform.OS !== 'web' && NativeCardInputModal) {\n    return <NativeCardInputModal {...props} />;\n  }\n\n  const handleClose = () => {\n    props.onClose();\n  };\n\n  return (\n    <Modal\n      visible={props.visible}\n      animationType=\"slide\"\n      transparent={true}\n      onRequestClose={handleClose}\n    >\n      <View style={[styles.overlay, { backgroundColor: 'rgba(0,0,0,0.5)' }]}>\n        <View style={[styles.modalContent, { backgroundColor: theme.background }]}>\n          <View style={styles.header}>\n            <ThemedText style={[Typography.h2, { color: theme.text }]}>\n              Add Payment Card\n            </ThemedText>\n            <Pressable onPress={handleClose}>\n              <Feather name=\"x\" size={24} color={theme.textSecondary} />\n            </Pressable>\n          </View>\n          \n          <View style={[styles.webNotice, { backgroundColor: theme.backgroundSecondary }]}>\n            <Feather name=\"info\" size={20} color={theme.primary} />\n            <ThemedText style={[Typography.body, { color: theme.textSecondary, marginLeft: Spacing.sm, flex: 1 }]}>\n              Native card input is not available on web. Please use the Expo Go app on your phone to add a card securely.\n            </ThemedText>\n          </View>\n          \n          <Pressable\n            style={[styles.button, { backgroundColor: theme.backgroundSecondary }]}\n            onPress={handleClose}\n          >\n            <ThemedText style={[Typography.body, { color: theme.text }]}>\n              Close\n            </ThemedText>\n          </Pressable>\n        </View>\n      </View>\n    </Modal>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    flex: 1,\n    justifyContent: 'flex-end',\n  },\n  modalContent: {\n    borderTopLeftRadius: BorderRadius.xl,\n    borderTopRightRadius: BorderRadius.xl,\n    padding: Spacing.lg,\n    paddingBottom: Spacing.xl + 20,\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: Spacing.lg,\n  },\n  webNotice: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    padding: Spacing.md,\n    borderRadius: BorderRadius.md,\n    marginBottom: Spacing.lg,\n  },\n  button: {\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.md,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n});\n","path":null,"size_bytes":3190,"size_tokens":null},"components/CardInputModal.web.tsx":{"content":"import React from 'react';\nimport { View, StyleSheet, Modal, Pressable } from 'react-native';\nimport { ThemedText } from '@/components/ThemedText';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { Feather } from '@expo/vector-icons';\n\ninterface CardInputModalProps {\n  visible: boolean;\n  onClose: () => void;\n  onSuccess: (paymentMethodId: string, cardDetails: { brand: string; last4: string }) => void;\n  clientSecret: string;\n  customerId: string;\n  setupIntentId: string;\n}\n\nexport function CardInputModal({\n  visible,\n  onClose,\n  onSuccess,\n  clientSecret,\n  customerId,\n  setupIntentId,\n}: CardInputModalProps) {\n  const { theme } = useTheme();\n\n  const handleClose = () => {\n    onClose();\n  };\n\n  return (\n    <Modal\n      visible={visible}\n      animationType=\"slide\"\n      transparent={true}\n      onRequestClose={handleClose}\n    >\n      <View style={[styles.overlay, { backgroundColor: 'rgba(0,0,0,0.5)' }]}>\n        <View style={[styles.modalContent, { backgroundColor: theme.background }]}>\n          <View style={styles.header}>\n            <ThemedText style={[Typography.h2, { color: theme.text }]}>\n              Add Payment Card\n            </ThemedText>\n            <Pressable onPress={handleClose}>\n              <Feather name=\"x\" size={24} color={theme.textSecondary} />\n            </Pressable>\n          </View>\n          \n          <View style={[styles.webNotice, { backgroundColor: theme.backgroundSecondary }]}>\n            <Feather name=\"info\" size={20} color={theme.primary} />\n            <ThemedText style={[Typography.body, { color: theme.textSecondary, marginLeft: Spacing.sm, flex: 1 }]}>\n              Native card input is not available on web. Please use the Expo Go app on your phone to add a card securely.\n            </ThemedText>\n          </View>\n          \n          <Pressable\n            style={[styles.button, { backgroundColor: theme.backgroundSecondary }]}\n            onPress={handleClose}\n          >\n            <ThemedText style={[Typography.body, { color: theme.text }]}>\n              Close\n            </ThemedText>\n          </Pressable>\n        </View>\n      </View>\n    </Modal>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    flex: 1,\n    justifyContent: 'flex-end',\n  },\n  modalContent: {\n    borderTopLeftRadius: BorderRadius.xl,\n    borderTopRightRadius: BorderRadius.xl,\n    padding: Spacing.lg,\n    paddingBottom: Spacing.xl + 20,\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: Spacing.lg,\n  },\n  webNotice: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    padding: Spacing.md,\n    borderRadius: BorderRadius.md,\n    marginBottom: Spacing.lg,\n  },\n  button: {\n    flex: 1,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.md,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n});\n","path":null,"size_bytes":2948,"size_tokens":null},"components/StripeWrapper.native.tsx":{"content":"import React, { ReactElement, useEffect, useState, useCallback } from 'react';\nimport { StripeProvider } from '@stripe/stripe-react-native';\nimport { Platform, View, ActivityIndicator, Text, StyleSheet } from 'react-native';\nimport { supabase } from '@/services/supabase';\n\nconst getServerUrl = () => {\n  if (Platform.OS === 'web') {\n    if (typeof window !== 'undefined' && window.location?.origin) {\n      const origin = window.location.origin;\n      if (origin.includes('replit') || origin.includes('localhost')) {\n        return origin;\n      }\n    }\n    return 'http://localhost:8082';\n  }\n  return 'https://splinepay.replit.app';\n};\n\ninterface StripeWrapperProps {\n  children: ReactElement;\n}\n\nexport function StripeWrapper({ children }: StripeWrapperProps) {\n  const [publishableKey, setPublishableKey] = useState<string | null>(null);\n  const [testMode, setTestMode] = useState<boolean>(false);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [isAuthenticated, setIsAuthenticated] = useState<boolean | null>(null);\n\n  const fetchUserSpecificKey = useCallback(async () => {\n    try {\n      const { data: sessionData } = await supabase.auth.getSession();\n      const accessToken = sessionData?.session?.access_token;\n      \n      if (accessToken) {\n        const response = await fetch(`${getServerUrl()}/api/stripe/user-publishable-key`, {\n          headers: {\n            'Authorization': `Bearer ${accessToken}`,\n          },\n        });\n        \n        if (response.ok) {\n          const data = await response.json();\n          if (data.publishableKey) {\n            setPublishableKey(data.publishableKey);\n            setTestMode(data.testMode || false);\n            setError(null);\n            return;\n          }\n        }\n      }\n      \n      const response = await fetch(`${getServerUrl()}/api/stripe/publishable-key`);\n      if (response.ok) {\n        const data = await response.json();\n        if (data.publishableKey) {\n          setPublishableKey(data.publishableKey);\n          setTestMode(false);\n          setError(null);\n        } else {\n          setError('Invalid key response');\n        }\n      } else {\n        setError('Failed to fetch payment configuration');\n      }\n    } catch (err) {\n      console.error('Error fetching Stripe publishable key:', err);\n      setError('Network error fetching payment configuration');\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    fetchUserSpecificKey();\n    \n    const { data: authListener } = supabase.auth.onAuthStateChange((event, session) => {\n      const wasAuthenticated = isAuthenticated;\n      const nowAuthenticated = !!session;\n      setIsAuthenticated(nowAuthenticated);\n      \n      if (wasAuthenticated !== nowAuthenticated || event === 'SIGNED_IN') {\n        setLoading(true);\n        fetchUserSpecificKey();\n      }\n    });\n\n    return () => {\n      authListener.subscription.unsubscribe();\n    };\n  }, [fetchUserSpecificKey, isAuthenticated]);\n\n  if (loading) {\n    return (\n      <View style={styles.loadingContainer}>\n        <ActivityIndicator size=\"large\" color=\"#2563EB\" />\n      </View>\n    );\n  }\n\n  if (error || !publishableKey) {\n    return (\n      <View style={styles.errorContainer}>\n        <Text style={styles.errorTitle}>Payment Setup Error</Text>\n        <Text style={styles.errorText}>\n          {error || 'Unable to initialize payment system. Please try again later.'}\n        </Text>\n      </View>\n    );\n  }\n\n  return (\n    <StripeProvider\n      key={`stripe-${testMode ? 'test' : 'live'}`}\n      publishableKey={publishableKey}\n      merchantIdentifier=\"merchant.com.splinepay.app\"\n    >\n      {children}\n    </StripeProvider>\n  );\n}\n\nconst styles = StyleSheet.create({\n  loadingContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#FFFFFF',\n  },\n  errorContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#FFFFFF',\n    padding: 24,\n  },\n  errorTitle: {\n    fontSize: 18,\n    fontWeight: '600',\n    color: '#DC2626',\n    marginBottom: 8,\n  },\n  errorText: {\n    fontSize: 14,\n    color: '#6B7280',\n    textAlign: 'center',\n  },\n});\n","path":null,"size_bytes":4241,"size_tokens":null},"components/CardInputModal.native.tsx":{"content":"import React, { useState } from 'react';\nimport { View, StyleSheet, Modal, Pressable, ActivityIndicator, Alert, KeyboardAvoidingView, Platform, ScrollView } from 'react-native';\nimport { CardField, useStripe, CardFieldInput } from '@stripe/stripe-react-native';\nimport { ThemedText } from '@/components/ThemedText';\nimport { LoadingOverlay } from '@/components/LoadingOverlay';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { Feather } from '@expo/vector-icons';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\n\ninterface CardInputModalProps {\n  visible: boolean;\n  onClose: () => void;\n  onSuccess: (paymentMethodId: string, cardDetails: { brand: string; last4: string }) => Promise<void> | void;\n  clientSecret: string;\n  customerId: string;\n  setupIntentId: string;\n}\n\nexport function CardInputModal({\n  visible,\n  onClose,\n  onSuccess,\n  clientSecret,\n  customerId,\n  setupIntentId,\n}: CardInputModalProps) {\n  const { theme } = useTheme();\n  const { confirmSetupIntent } = useStripe();\n  const [cardComplete, setCardComplete] = useState(false);\n  const [processing, setProcessing] = useState(false);\n  const [cardDetails, setCardDetails] = useState<CardFieldInput.Details | null>(null);\n  const insets = useSafeAreaInsets();\n\n  const handleCardChange = (details: CardFieldInput.Details) => {\n    setCardComplete(details.complete);\n    setCardDetails(details);\n  };\n\n  const getFriendlyErrorMessage = (error: any): string => {\n    const message = error?.message?.toLowerCase() || '';\n    const code = error?.code?.toLowerCase() || '';\n    \n    if (message.includes('test card') || message.includes('test mode') || \n        message.includes('known test') || code === 'card_declined') {\n      return 'Please enter a valid card number. The card you entered cannot be used.';\n    }\n    \n    if (message.includes('expired')) {\n      return 'Your card has expired. Please use a different card.';\n    }\n    \n    if (message.includes('insufficient funds') || code === 'insufficient_funds') {\n      return 'Your card was declined due to insufficient funds.';\n    }\n    \n    if (message.includes('incorrect cvc') || code === 'incorrect_cvc') {\n      return 'The security code (CVC) is incorrect. Please check and try again.';\n    }\n    \n    if (message.includes('no such setupintent') || message.includes('resource_missing')) {\n      return 'Card setup session expired. Please try again.';\n    }\n    \n    if (message.includes('declined')) {\n      return 'Your card was declined. Please try a different card.';\n    }\n    \n    return error?.message || 'Failed to add card. Please try again.';\n  };\n\n  const handleConfirm = async () => {\n    if (!cardComplete || !clientSecret) {\n      Alert.alert('Error', 'Please enter valid card details');\n      return;\n    }\n\n    setProcessing(true);\n    try {\n      const { setupIntent, error } = await confirmSetupIntent(clientSecret, {\n        paymentMethodType: 'Card',\n      });\n\n      if (error) {\n        console.error('Setup Intent Error:', error);\n        Alert.alert('Error', getFriendlyErrorMessage(error));\n        setProcessing(false);\n        return;\n      }\n\n      if (setupIntent && setupIntent.paymentMethodId) {\n        const brand = cardDetails?.brand || 'card';\n        const last4 = cardDetails?.last4 || '****';\n        // Await the full onSuccess flow (including backend verification)\n        // This keeps the loading overlay visible until everything is complete\n        await onSuccess(setupIntent.paymentMethodId, { brand, last4 });\n      }\n    } catch (error: any) {\n      console.error('Card setup error:', error);\n      Alert.alert('Error', getFriendlyErrorMessage(error));\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  const handleClose = () => {\n    if (!processing) {\n      setCardComplete(false);\n      setCardDetails(null);\n      onClose();\n    }\n  };\n\n  return (\n    <Modal\n      visible={visible}\n      animationType=\"fade\"\n      transparent={true}\n      onRequestClose={handleClose}\n    >\n      <LoadingOverlay visible={processing} message=\"Adding your card...\" fullScreen />\n      <KeyboardAvoidingView \n        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n        style={styles.keyboardAvoidingView}\n      >\n        <Pressable \n          style={[styles.overlay, { backgroundColor: 'rgba(0,0,0,0.5)' }]} \n          onPress={handleClose}\n        >\n          <ScrollView\n            contentContainerStyle={styles.scrollContent}\n            bounces={false}\n            keyboardShouldPersistTaps=\"handled\"\n            showsVerticalScrollIndicator={false}\n          >\n            <Pressable \n              style={[\n                styles.modalContent, \n                { \n                  backgroundColor: theme.background,\n                  marginTop: Math.max(insets.top, Spacing.xl),\n                  marginBottom: Math.max(insets.bottom, Spacing.xl),\n                }\n              ]}\n              onPress={(e) => e.stopPropagation()}\n            >\n              <View style={styles.header}>\n                <ThemedText style={[Typography.h2, { color: theme.text }]}>\n                  Add Payment Card\n                </ThemedText>\n                <Pressable onPress={handleClose} disabled={processing} hitSlop={8}>\n                  <Feather name=\"x\" size={24} color={theme.textSecondary} />\n                </Pressable>\n              </View>\n\n              <View style={styles.cardFieldContainer}>\n                <ThemedText style={[Typography.small, { color: theme.textSecondary, marginBottom: Spacing.xs }]}>\n                  Card Details\n                </ThemedText>\n                <CardField\n                  postalCodeEnabled={false}\n                  placeholders={{\n                    number: '4242 4242 4242 4242',\n                  }}\n                  cardStyle={{\n                    backgroundColor: theme.backgroundSecondary,\n                    textColor: theme.text,\n                    borderColor: theme.border,\n                    borderWidth: 1,\n                    borderRadius: BorderRadius.md,\n                    fontSize: 16,\n                    placeholderColor: theme.textSecondary,\n                  }}\n                  style={styles.cardField}\n                  onCardChange={handleCardChange}\n                />\n              </View>\n\n              <View style={[styles.securityNotice, { backgroundColor: theme.backgroundSecondary }]}>\n                <Feather name=\"lock\" size={16} color={theme.success} />\n                <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginLeft: Spacing.xs, flex: 1 }]}>\n                  Your card details are securely processed. We never store your full card number.\n                </ThemedText>\n              </View>\n\n              <View style={styles.buttonContainer}>\n                <Pressable\n                  style={[styles.button, styles.cancelButton, { backgroundColor: theme.backgroundSecondary }]}\n                  onPress={handleClose}\n                  disabled={processing}\n                >\n                  <ThemedText style={[Typography.body, { color: theme.text }]}>\n                    Cancel\n                  </ThemedText>\n                </Pressable>\n                \n                <Pressable\n                  style={[\n                    styles.button,\n                    styles.confirmButton,\n                    { backgroundColor: cardComplete && !processing ? theme.primary : theme.border }\n                  ]}\n                  onPress={handleConfirm}\n                  disabled={!cardComplete || processing}\n                >\n                  {processing ? (\n                    <ActivityIndicator size=\"small\" color=\"#FFFFFF\" />\n                  ) : (\n                    <ThemedText style={[Typography.body, { color: '#FFFFFF', fontWeight: '600' }]}>\n                      Add Card\n                    </ThemedText>\n                  )}\n                </Pressable>\n              </View>\n            </Pressable>\n          </ScrollView>\n        </Pressable>\n      </KeyboardAvoidingView>\n    </Modal>\n  );\n}\n\nconst styles = StyleSheet.create({\n  keyboardAvoidingView: {\n    flex: 1,\n  },\n  overlay: {\n    flex: 1,\n  },\n  scrollContent: {\n    flexGrow: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.lg,\n  },\n  modalContent: {\n    width: '100%',\n    maxWidth: 400,\n    borderRadius: BorderRadius.xl,\n    padding: Spacing.lg,\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.25,\n    shadowRadius: 12,\n    elevation: 8,\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: Spacing.lg,\n  },\n  cardFieldContainer: {\n    marginBottom: Spacing.lg,\n  },\n  cardField: {\n    width: '100%',\n    height: 50,\n  },\n  securityNotice: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    padding: Spacing.md,\n    borderRadius: BorderRadius.md,\n    marginBottom: Spacing.lg,\n  },\n  buttonContainer: {\n    flexDirection: 'row',\n    gap: Spacing.md,\n  },\n  button: {\n    flex: 1,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.md,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  cancelButton: {},\n  confirmButton: {},\n});\n","path":null,"size_bytes":9329,"size_tokens":null},"components/StripeWrapper.tsx":{"content":"import React, { ReactElement } from 'react';\nimport { Platform } from 'react-native';\n\ninterface StripeWrapperProps {\n  children: ReactElement;\n}\n\nlet NativeStripeWrapper: React.ComponentType<StripeWrapperProps> | null = null;\n\nif (Platform.OS !== 'web') {\n  NativeStripeWrapper = require('./StripeWrapper.native').StripeWrapper;\n}\n\nexport function StripeWrapper({ children }: StripeWrapperProps) {\n  if (Platform.OS === 'web' || !NativeStripeWrapper) {\n    return <>{children}</>;\n  }\n  \n  return <NativeStripeWrapper>{children}</NativeStripeWrapper>;\n}\n","path":null,"size_bytes":555,"size_tokens":null},"components/StripeWrapper.web.tsx":{"content":"import React from 'react';\n\ninterface StripeWrapperProps {\n  children: React.ReactNode;\n}\n\nexport function StripeWrapper({ children }: StripeWrapperProps) {\n  return <>{children}</>;\n}\n","path":null,"size_bytes":185,"size_tokens":null},"scripts/create-demo-accounts.ts":{"content":"import { createClient } from '@supabase/supabase-js';\nimport 'dotenv/config';\n\nconst supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseServiceKey) {\n  console.error('Missing Supabase credentials');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey, {\n  auth: {\n    autoRefreshToken: false,\n    persistSession: false\n  }\n});\n\nfunction generateUniqueId(): string {\n  const min = 10000;\n  const max = 9999999999;\n  return String(Math.floor(Math.random() * (max - min + 1)) + min);\n}\n\nasync function createDemoAccount(email: string, password: string, name: string) {\n  console.log(`Creating demo account for ${email}...`);\n\n  const { data: existingUsers } = await supabase\n    .from('users')\n    .select('id')\n    .eq('email', email)\n    .single();\n\n  if (existingUsers) {\n    console.log(`User ${email} already exists, updating stripe_test_mode...`);\n    \n    const { error: walletError } = await supabase\n      .from('wallets')\n      .update({ \n        stripe_test_mode: true,\n        balance: 100\n      })\n      .eq('user_id', existingUsers.id);\n    \n    if (walletError) {\n      console.error('Error updating wallet:', walletError);\n    } else {\n      console.log(`Updated wallet for ${email} with test mode enabled and $100 balance`);\n    }\n    return;\n  }\n\n  const { data: { users: authUsers }, error: listError } = await supabase.auth.admin.listUsers();\n  const existingAuthUser = authUsers?.find(u => u.email === email);\n  \n  let userId: string;\n  \n  if (existingAuthUser) {\n    console.log(`Auth user exists for ${email}, creating profile...`);\n    userId = existingAuthUser.id;\n  } else {\n    const { data: authData, error: authError } = await supabase.auth.admin.createUser({\n      email,\n      password,\n      email_confirm: true,\n      user_metadata: {\n        name,\n      }\n    });\n\n    if (authError) {\n      console.error('Auth error:', authError);\n      return;\n    }\n\n    if (!authData.user) {\n      console.error('No user created');\n      return;\n    }\n    \n    userId = authData.user.id;\n  }\n  const uniqueId = generateUniqueId();\n\n  const { error: profileError } = await supabase\n    .from('users')\n    .insert({\n      id: userId,\n      unique_id: uniqueId,\n      name,\n      email,\n      phone: '+64211234567',\n      date_of_birth: '1990-01-01',\n      bio: 'Apple Review Demo Account',\n    });\n\n  if (profileError) {\n    console.error('Profile error:', profileError);\n    return;\n  }\n\n  const { error: walletError } = await supabase\n    .from('wallets')\n    .insert({\n      user_id: userId,\n      balance: 100,\n      bank_connected: false,\n      stripe_test_mode: true,\n    });\n\n  if (walletError) {\n    console.error('Wallet error:', walletError);\n    return;\n  }\n\n  console.log(`Created demo account for ${email}`);\n  console.log(`  User ID: ${userId}`);\n  console.log(`  Unique ID: ${uniqueId}`);\n  console.log(`  Stripe Test Mode: ENABLED`);\n  console.log(`  Starting Balance: $100`);\n}\n\nasync function main() {\n  console.log('Creating Apple Reviewer Demo Accounts...\\n');\n\n  await createDemoAccount('account1@gmail.com', 'account2213', 'Demo Account One');\n  console.log('');\n  await createDemoAccount('account2@gmail.com', 'account2213', 'Demo Account Two');\n\n  console.log('\\n=== Demo Accounts Ready ===');\n  console.log('These accounts use Stripe TEST mode.');\n  console.log('Reviewers can use test card: 4242 4242 4242 4242');\n  console.log('Expiry: Any future date, CVC: Any 3 digits');\n}\n\nmain().catch(console.error);\n","path":null,"size_bytes":3607,"size_tokens":null},"scripts/add-stripe-test-mode.ts":{"content":"import { createClient } from '@supabase/supabase-js';\nimport 'dotenv/config';\n\nconst supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nif (!supabaseUrl || !supabaseServiceKey) {\n  console.error('Missing Supabase credentials');\n  process.exit(1);\n}\n\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\n\nasync function addColumn() {\n  // Try to add the column using Supabase RPC or direct query\n  // First, let's check if the column exists by selecting from wallets\n  const { data, error } = await supabase\n    .from('wallets')\n    .select('*')\n    .limit(1);\n\n  console.log('Current wallet structure:');\n  if (data && data.length > 0) {\n    console.log('Columns:', Object.keys(data[0]));\n  } else if (error) {\n    console.log('Error:', error);\n  } else {\n    console.log('No data found');\n  }\n}\n\naddColumn();\n","path":null,"size_bytes":917,"size_tokens":null},"scripts/fix-demo-wallets.ts":{"content":"import { createClient } from '@supabase/supabase-js';\nimport 'dotenv/config';\n\nconst supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nconst supabase = createClient(supabaseUrl!, supabaseServiceKey!);\n\nasync function createWallets() {\n  const userIds = [\n    { id: '405b7c92-0f06-4694-a02c-3ae228ba6c16', email: 'account1@gmail.com' },\n    { id: 'e0e7bef3-6ae8-4c7a-b430-4d4a7c04e758', email: 'account2@gmail.com' }\n  ];\n\n  for (const user of userIds) {\n    console.log(`Creating wallet for ${user.email}...`);\n    \n    const { error } = await supabase\n      .from('wallets')\n      .insert({\n        user_id: user.id,\n        balance: 100,\n        bank_connected: false,\n        stripe_test_mode: true\n      });\n\n    if (error) {\n      console.error(`Error creating wallet for ${user.email}:`, error);\n    } else {\n      console.log(`Wallet created for ${user.email} with $100 balance and test mode enabled`);\n    }\n  }\n\n  // Make them friends with each other\n  console.log('\\nMaking demo accounts friends...');\n  \n  const { error: friendError } = await supabase\n    .from('friends')\n    .insert({\n      user_id: '405b7c92-0f06-4694-a02c-3ae228ba6c16',\n      friend_id: 'e0e7bef3-6ae8-4c7a-b430-4d4a7c04e758',\n      status: 'accepted'\n    });\n\n  if (friendError && !friendError.message.includes('duplicate')) {\n    console.error('Error creating friendship:', friendError);\n  } else {\n    console.log('Demo accounts are now friends!');\n  }\n  \n  // Create reverse friendship\n  const { error: reverseError } = await supabase\n    .from('friends')\n    .insert({\n      user_id: 'e0e7bef3-6ae8-4c7a-b430-4d4a7c04e758',\n      friend_id: '405b7c92-0f06-4694-a02c-3ae228ba6c16',\n      status: 'accepted'\n    });\n\n  if (reverseError && !reverseError.message.includes('duplicate')) {\n    console.error('Error creating reverse friendship:', reverseError);\n  }\n\n  console.log('\\nDone! Demo accounts are ready for Apple review.');\n}\n\ncreateWallets();\n","path":null,"size_bytes":2033,"size_tokens":null},"APP_STORE_REVIEW_NOTES.md":{"content":"# Spline - App Store Review Notes\n\n## Demo Account Credentials\n\n### Account 1 (Primary)\n- **Email:** account1@gmail.com\n- **Password:** account2213\n- **Unique ID:** 7742941558\n- **Name:** Demo Account One\n\n### Account 2 (For testing friend features)\n- **Email:** account2@gmail.com\n- **Password:** account2213\n- **Unique ID:** 4716306667\n- **Name:** Demo Account Two\n\nBoth accounts have:\n- $100 starting balance for testing payments\n- Test mode enabled (uses Stripe test environment)\n- No real money is processed\n- Already added as friends for easy testing\n\n---\n\n## Testing Payment Features\n\n### Adding a Payment Card\nThese demo accounts use **Stripe Test Mode**. Use these test card numbers:\n\n| Card Type | Number | Expiry | CVC |\n|-----------|--------|--------|-----|\n| Visa (Success) | 4242 4242 4242 4242 | Any future date | Any 3 digits |\n| Visa (Decline) | 4000 0000 0000 0002 | Any future date | Any 3 digits |\n| Mastercard | 5555 5555 5555 4444 | Any future date | Any 3 digits |\n\n**Steps to add a card:**\n1. Log in with a demo account\n2. Go to Profile tab\n3. Tap \"Wallet\"\n4. Tap \"Add Payment Card\"\n5. Enter test card number: `4242 4242 4242 4242`\n6. Enter any future expiry date (e.g., 12/28)\n7. Enter any 3-digit CVC (e.g., 123)\n8. Complete the setup\n\n---\n\n## App Features to Test\n\n### 1. Bill Splitting\n- Create a new split from the Home tab\n- Select friends to split with\n- Enter amount and description\n- Friends receive notification to pay\n\n### 2. Wallet & Payments\n- View wallet balance\n- Add/remove payment cards (test cards only)\n- Pay split requests\n- Request withdrawals\n\n### 3. Friends Management\n- Add friends using their unique ID\n- Accept/decline friend requests\n- View friend list\n\n### 4. Withdrawals\n- Request withdrawal to linked bank account\n- Fast transfer (3.5% fee) or Normal transfer (free)\n- Note: Withdrawals are manually processed\n\n---\n\n## Important Notes\n\n1. **Test Mode Architecture:** Demo accounts are configured with `stripe_test_mode = true` in their wallet settings. This flag is read server-side to determine which Stripe environment to use. Test mode users interact with Stripe's test environment exclusively. No real charges will occur.\n\n2. **NZ Currency:** All amounts are in New Zealand Dollars (NZD).\n\n3. **Bank Withdrawals:** The withdrawal feature sends a request to our team for manual processing. For testing, you can observe the request is created successfully.\n\n4. **Push Notifications:** Push notifications work on physical devices through Expo Go. The web version shows in-app notifications only.\n\n5. **Security:** All Stripe payment operations require server-side authentication. The test mode flag is controlled server-side only and cannot be manipulated by clients.\n\n---\n\n## Support\n\n- **Website:** https://splinepay.replit.app\n- **Privacy Policy:** https://splinepay.replit.app/privacy\n- **Terms of Service:** https://splinepay.replit.app/terms\n","path":null,"size_bytes":2903,"size_tokens":null},"scripts/check-demo-users.ts":{"content":"import { createClient } from '@supabase/supabase-js';\nimport 'dotenv/config';\n\nconst supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\nconst supabase = createClient(supabaseUrl!, supabaseServiceKey!);\n\nasync function check() {\n  // Check auth users\n  const { data: { users }, error } = await supabase.auth.admin.listUsers();\n  \n  const demoUsers = users?.filter(u => \n    u.email === 'account1@gmail.com' || u.email === 'account2@gmail.com'\n  );\n  \n  console.log('Demo users in auth:');\n  demoUsers?.forEach(u => {\n    console.log(`  ${u.email} - ID: ${u.id}`);\n  });\n\n  // Check profile users\n  console.log('\\nDemo users in users table:');\n  const { data: profiles } = await supabase\n    .from('users')\n    .select('id, email, unique_id, name')\n    .in('email', ['account1@gmail.com', 'account2@gmail.com']);\n  \n  console.log(profiles);\n\n  // Check wallets\n  if (profiles && profiles.length > 0) {\n    console.log('\\nWallets:');\n    const { data: wallets } = await supabase\n      .from('wallets')\n      .select('user_id, balance, stripe_test_mode')\n      .in('user_id', profiles.map(p => p.id));\n    \n    console.log(wallets);\n  }\n}\n\ncheck();\n","path":null,"size_bytes":1241,"size_tokens":null},"components/LoadingOverlay.tsx":{"content":"import React, { useEffect } from 'react';\nimport { View, StyleSheet, Modal, Platform } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withRepeat,\n  withTiming,\n  withDelay,\n  withSequence,\n  interpolate,\n  Easing,\n} from 'react-native-reanimated';\nimport { BlurView } from 'expo-blur';\nimport { ThemedText } from './ThemedText';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\n\ninterface LoadingOverlayProps {\n  visible: boolean;\n  message?: string;\n  fullScreen?: boolean;\n}\n\nfunction PulsingDot({ delay, color }: { delay: number; color: string }) {\n  const scale = useSharedValue(0.6);\n  const opacity = useSharedValue(0.4);\n\n  useEffect(() => {\n    scale.value = withDelay(\n      delay,\n      withRepeat(\n        withSequence(\n          withTiming(1, { duration: 400, easing: Easing.bezier(0.4, 0, 0.2, 1) }),\n          withTiming(0.6, { duration: 400, easing: Easing.bezier(0.4, 0, 0.2, 1) })\n        ),\n        -1,\n        false\n      )\n    );\n    opacity.value = withDelay(\n      delay,\n      withRepeat(\n        withSequence(\n          withTiming(1, { duration: 400, easing: Easing.bezier(0.4, 0, 0.2, 1) }),\n          withTiming(0.4, { duration: 400, easing: Easing.bezier(0.4, 0, 0.2, 1) })\n        ),\n        -1,\n        false\n      )\n    );\n  }, []);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n    opacity: opacity.value,\n  }));\n\n  return (\n    <Animated.View\n      style={[\n        styles.dot,\n        { backgroundColor: color },\n        animatedStyle,\n      ]}\n    />\n  );\n}\n\nfunction SpinningRing({ color }: { color: string }) {\n  const rotation = useSharedValue(0);\n  const scale = useSharedValue(0.9);\n\n  useEffect(() => {\n    rotation.value = withRepeat(\n      withTiming(360, { duration: 1200, easing: Easing.linear }),\n      -1,\n      false\n    );\n    scale.value = withRepeat(\n      withSequence(\n        withTiming(1, { duration: 600, easing: Easing.bezier(0.4, 0, 0.2, 1) }),\n        withTiming(0.9, { duration: 600, easing: Easing.bezier(0.4, 0, 0.2, 1) })\n      ),\n      -1,\n      false\n    );\n  }, []);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [\n      { rotate: `${rotation.value}deg` },\n      { scale: scale.value },\n    ],\n  }));\n\n  return (\n    <Animated.View style={[styles.ringContainer, animatedStyle]}>\n      <View style={[styles.ring, { borderColor: color, borderTopColor: 'transparent' }]} />\n    </Animated.View>\n  );\n}\n\nfunction LoadingContent({ message, theme }: { message?: string; theme: any }) {\n  const fadeIn = useSharedValue(0);\n\n  useEffect(() => {\n    fadeIn.value = withTiming(1, { duration: 300 });\n  }, []);\n\n  const containerStyle = useAnimatedStyle(() => ({\n    opacity: fadeIn.value,\n    transform: [{ scale: interpolate(fadeIn.value, [0, 1], [0.9, 1]) }],\n  }));\n\n  return (\n    <Animated.View style={[styles.contentContainer, containerStyle]}>\n      <View style={[styles.loaderCard, { backgroundColor: theme.surface }]}>\n        <View style={styles.dotsContainer}>\n          <PulsingDot delay={0} color={theme.primary} />\n          <PulsingDot delay={150} color={theme.primary} />\n          <PulsingDot delay={300} color={theme.primary} />\n        </View>\n        {message ? (\n          <ThemedText style={[Typography.body, styles.message, { color: theme.text }]}>\n            {message}\n          </ThemedText>\n        ) : null}\n      </View>\n    </Animated.View>\n  );\n}\n\nexport function LoadingOverlay({ visible, message, fullScreen = false }: LoadingOverlayProps) {\n  const { theme, isDark } = useTheme();\n\n  if (!visible) return null;\n\n  const content = (\n    <View style={styles.overlay}>\n      {Platform.OS === 'ios' ? (\n        <BlurView\n          intensity={30}\n          tint={isDark ? 'dark' : 'light'}\n          style={StyleSheet.absoluteFill}\n        />\n      ) : (\n        <View style={[StyleSheet.absoluteFill, styles.androidOverlay, { backgroundColor: isDark ? 'rgba(0,0,0,0.6)' : 'rgba(255,255,255,0.85)' }]} />\n      )}\n      <LoadingContent message={message} theme={theme} />\n    </View>\n  );\n\n  if (fullScreen) {\n    return (\n      <Modal\n        visible={visible}\n        transparent\n        animationType=\"fade\"\n        statusBarTranslucent\n      >\n        {content}\n      </Modal>\n    );\n  }\n\n  return content;\n}\n\nexport function LoadingSpinner({ size = 'medium', color }: { size?: 'small' | 'medium' | 'large'; color?: string }) {\n  const { theme } = useTheme();\n  const spinnerColor = color || theme.primary;\n  \n  const sizeMap = {\n    small: 24,\n    medium: 40,\n    large: 56,\n  };\n\n  const spinnerSize = sizeMap[size];\n\n  return (\n    <View style={[styles.spinnerContainer, { width: spinnerSize, height: spinnerSize }]}>\n      <SpinningRing color={spinnerColor} />\n    </View>\n  );\n}\n\nexport function LoadingDots({ color }: { color?: string }) {\n  const { theme } = useTheme();\n  const dotColor = color || theme.primary;\n\n  return (\n    <View style={styles.inlineDotsContainer}>\n      <PulsingDot delay={0} color={dotColor} />\n      <PulsingDot delay={150} color={dotColor} />\n      <PulsingDot delay={300} color={dotColor} />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1000,\n  },\n  androidOverlay: {\n    opacity: 0.95,\n  },\n  contentContainer: {\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  loaderCard: {\n    paddingHorizontal: Spacing['2xl'],\n    paddingVertical: Spacing.xl,\n    borderRadius: BorderRadius.md,\n    alignItems: 'center',\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.15,\n    shadowRadius: 12,\n    elevation: 8,\n    minWidth: 140,\n  },\n  dotsContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    gap: Spacing.md,\n  },\n  inlineDotsContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    gap: Spacing.sm,\n  },\n  dot: {\n    width: 12,\n    height: 12,\n    borderRadius: 6,\n  },\n  message: {\n    marginTop: Spacing.lg,\n    textAlign: 'center',\n  },\n  ringContainer: {\n    width: '100%',\n    height: '100%',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  ring: {\n    width: '100%',\n    height: '100%',\n    borderRadius: 100,\n    borderWidth: 3,\n  },\n  spinnerContainer: {\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":6505,"size_tokens":null},"components/ProfileStatsCard.tsx":{"content":"import React, { useEffect, useState } from 'react';\nimport { View, StyleSheet, Pressable, Modal } from 'react-native';\nimport { Feather } from '@expo/vector-icons';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n  withTiming,\n  interpolate,\n} from 'react-native-reanimated';\nimport { ThemedText } from './ThemedText';\nimport { ThemedView } from './ThemedView';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useLevelUp } from '@/contexts/LevelUpContext';\nimport { GamificationService, GamificationProfile, LEVEL_INFO } from '@/services/gamification.service';\nimport { VoucherClaimModal } from './VoucherClaimModal';\n\ninterface ProfileStatsCardProps {\n  userId: string;\n  compact?: boolean;\n  showBadges?: boolean;\n  onPress?: () => void;\n}\n\nconst TIER_COLORS = {\n  bronze: '#CD7F32',\n  silver: '#C0C0C0',\n  gold: '#FFD700',\n  platinum: '#E5E4E2',\n};\n\nconst STAT_HELP_INFO = {\n  streak: {\n    title: 'Day Streak',\n    description: 'Your CURRENT run of consecutive days using Spline. This counter resets back to zero if you miss a day of activity (creating or paying splits).',\n    howToEarn: 'Use Spline every day to keep your streak alive. You earn 20 bonus XP at 7 days and 100 XP at 30 days!',\n    example: 'If you used Spline Mon-Wed-Thu-Fri, your streak is 3 (Thu missed reset it, Fri started fresh).',\n  },\n  splitsCreated: {\n    title: 'Splits Created',\n    description: 'The number of split events you have organized. Each time you initiate a new bill split with friends, this count increases by one.',\n    howToEarn: 'Start a split anytime you share expenses - dinner, groceries, trips, rent. Earn 25-40 XP per split!',\n    example: 'Dinner with 3 friends = 1 split. Movie night tomorrow = 2 splits total.',\n  },\n  paidOnTime: {\n    title: 'Paid On Time',\n    description: 'How many times you paid your share within 24 hours of receiving a split request. A key trust indicator visible to friends.',\n    howToEarn: 'Pay quickly when friends add you to splits. Paying within 1 hour earns 35 XP (vs 20 XP for slower)!',\n    example: 'Friend splits lunch at 12pm, you pay by 1pm = Paid On Time. Pay next week = not counted.',\n  },\n  longestStreak: {\n    title: 'Longest Streak',\n    description: 'Your ALL-TIME BEST streak record. Unlike Day Streak, this number never resets - it is your personal best achievement on Spline.',\n    howToEarn: 'Keep your Day Streak going to beat this record! Unlock special badges at 7 days and 30 days.',\n    example: 'If your Day Streak once hit 15 but is now 3, your Longest Streak stays 15 forever.',\n  },\n  splitVolume: {\n    title: 'Total Split Volume',\n    description: 'The total DOLLAR AMOUNT of all splits you have been part of (as creator or participant). This is about money moved, not count of splits.',\n    howToEarn: 'Participate in more splits or splits with larger amounts. A $200 dinner contributes more than a $10 coffee!',\n    example: '$50 dinner + $30 groceries + $120 trip = $200 Total Volume. Splits Created would be 3.',\n  },\n  splitsAsLeader: {\n    title: 'Splits Completed as Leader',\n    description: 'How many splits YOU created where everyone paid 100%. Shows your effectiveness at organizing and collecting payments.',\n    howToEarn: 'Create splits and encourage friends to pay. You earn 50 bonus XP each time a split you created is fully paid!',\n    example: 'You split dinner with 4 friends, all 4 pay = +1 completed. If 1 friend never pays = not counted.',\n  },\n};\n\nexport function ProfileStatsCard({ userId, compact = false, showBadges = true, onPress }: ProfileStatsCardProps) {\n  const { theme: colors, isDark } = useTheme();\n  const { xpRefreshTrigger } = useLevelUp();\n  const [profile, setProfile] = useState<GamificationProfile | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [expanded, setExpanded] = useState(false);\n  const [helpModal, setHelpModal] = useState<{ visible: boolean; stat: keyof typeof STAT_HELP_INFO | null }>({\n    visible: false,\n    stat: null,\n  });\n  const [voucherModal, setVoucherModal] = useState(false);\n\n  const progressWidth = useSharedValue(0);\n  const expandHeight = useSharedValue(0);\n\n  useEffect(() => {\n    loadProfile();\n  }, [userId, xpRefreshTrigger]);\n\n  useEffect(() => {\n    if (profile) {\n      progressWidth.value = withSpring(Math.min(profile.xp_progress_percent, 100) / 100, {\n        damping: 15,\n        stiffness: 100,\n      });\n    }\n  }, [profile?.xp_progress_percent]);\n\n  useEffect(() => {\n    expandHeight.value = withTiming(expanded ? 1 : 0, { duration: 300 });\n  }, [expanded]);\n\n  const loadProfile = async () => {\n    try {\n      const data = await GamificationService.getProfile(userId);\n      setProfile(data);\n    } catch (error) {\n      console.error('Failed to load gamification profile:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const progressAnimatedStyle = useAnimatedStyle(() => ({\n    width: `${progressWidth.value * 100}%`,\n  }));\n\n  const expandAnimatedStyle = useAnimatedStyle(() => ({\n    maxHeight: interpolate(expandHeight.value, [0, 1], [0, 400]),\n    opacity: expandHeight.value,\n  }));\n\n  const getLevelInfo = (level: number): { title: string; perk?: string } => {\n    let currentInfo: { title: string; perk?: string } = { title: 'Newcomer' };\n    for (const [lvl, info] of Object.entries(LEVEL_INFO).sort((a, b) => Number(a[0]) - Number(b[0]))) {\n      if (Number(lvl) <= level) {\n        currentInfo = info;\n      }\n    }\n    return currentInfo;\n  };\n\n  const getNextPerkLevel = (level: number): { level: number; perk: string } | null => {\n    for (const [lvl, info] of Object.entries(LEVEL_INFO).sort((a, b) => Number(a[0]) - Number(b[0]))) {\n      if (Number(lvl) > level && info.perk) {\n        return { level: Number(lvl), perk: info.perk };\n      }\n    }\n    return null;\n  };\n\n  if (loading) {\n    return (\n      <ThemedView style={[styles.container, { backgroundColor: colors.surface }]}>\n        <View style={styles.loadingContainer}>\n          <ThemedText style={styles.loadingText}>Loading stats...</ThemedText>\n        </View>\n      </ThemedView>\n    );\n  }\n\n  if (!profile) {\n    return null;\n  }\n\n  const levelInfo = getLevelInfo(profile.current_level);\n  const nextPerk = getNextPerkLevel(profile.current_level);\n\n  if (compact) {\n    return (\n      <Pressable onPress={onPress}>\n        <View style={[styles.compactContainer, { backgroundColor: colors.backgroundSecondary }]}>\n          <View style={styles.compactLevelBadge}>\n            <ThemedText style={[styles.compactLevel, { color: colors.primary }]}>\n              {profile.current_level}\n            </ThemedText>\n          </View>\n          <View style={styles.compactInfo}>\n            <ThemedText style={[styles.compactTitle, { color: colors.text }]}>{levelInfo.title}</ThemedText>\n            <View style={[styles.compactProgressBar, { backgroundColor: colors.border }]}>\n              <Animated.View\n                style={[\n                  styles.compactProgressFill,\n                  { backgroundColor: colors.primary },\n                  progressAnimatedStyle,\n                ]}\n              />\n            </View>\n          </View>\n          <ThemedText style={[styles.compactXP, { color: colors.textSecondary }]}>\n            {profile.total_xp} XP\n          </ThemedText>\n        </View>\n      </Pressable>\n    );\n  }\n\n  return (\n    <ThemedView style={[styles.container, { backgroundColor: colors.surface }]}>\n      <Pressable onPress={() => setExpanded(!expanded)}>\n        <View style={styles.header}>\n          <View style={styles.levelSection}>\n            <View style={[styles.levelCircle, { borderColor: colors.primary }]}>\n              <ThemedText style={[styles.levelNumber, { color: colors.primary }]}>\n                {profile.current_level}\n              </ThemedText>\n            </View>\n            <View style={styles.levelInfo}>\n              <ThemedText style={[styles.title, { color: colors.text }]}>{levelInfo.title}</ThemedText>\n              <ThemedText style={[styles.xpText, { color: colors.textSecondary }]}>\n                {profile.total_xp.toLocaleString()} XP\n              </ThemedText>\n            </View>\n          </View>\n          <Feather\n            name={expanded ? 'chevron-up' : 'chevron-down'}\n            size={20}\n            color={colors.textSecondary}\n          />\n        </View>\n\n        <View style={styles.progressSection}>\n          <View style={[styles.progressBar, { backgroundColor: colors.border }]}>\n            <Animated.View\n              style={[\n                styles.progressFill,\n                { backgroundColor: colors.primary },\n                progressAnimatedStyle,\n              ]}\n            />\n          </View>\n          <ThemedText style={[styles.progressText, { color: colors.textSecondary }]}>\n            {Math.round(profile.xp_progress_percent)}% to Level {profile.current_level + 1}\n          </ThemedText>\n        </View>\n\n        <View style={styles.statsRow}>\n          <View style={styles.statItem}>\n            <ThemedText style={[styles.statValue, { color: colors.text }]}>\n              {profile.current_streak}\n            </ThemedText>\n            <View style={styles.statLabelRow}>\n              <ThemedText style={[styles.statLabel, { color: colors.textSecondary }]}>\n                Day Streak\n              </ThemedText>\n              <HelpIcon onPress={() => setHelpModal({ visible: true, stat: 'streak' })} />\n            </View>\n          </View>\n          <View style={[styles.statDivider, { backgroundColor: colors.border }]} />\n          <View style={styles.statItem}>\n            <ThemedText style={[styles.statValue, { color: colors.text }]}>\n              {profile.splits_created}\n            </ThemedText>\n            <View style={styles.statLabelRow}>\n              <ThemedText style={[styles.statLabel, { color: colors.textSecondary }]}>\n                Splits Created\n              </ThemedText>\n              <HelpIcon onPress={() => setHelpModal({ visible: true, stat: 'splitsCreated' })} />\n            </View>\n          </View>\n          <View style={[styles.statDivider, { backgroundColor: colors.border }]} />\n          <View style={styles.statItem}>\n            <ThemedText style={[styles.statValue, { color: colors.text }]}>\n              {profile.splits_paid_on_time}\n            </ThemedText>\n            <View style={styles.statLabelRow}>\n              <ThemedText style={[styles.statLabel, { color: colors.textSecondary }]}>\n                Paid On Time\n              </ThemedText>\n              <HelpIcon onPress={() => setHelpModal({ visible: true, stat: 'paidOnTime' })} />\n            </View>\n          </View>\n        </View>\n      </Pressable>\n\n      <Animated.View style={[styles.expandedContent, expandAnimatedStyle]}>\n        {nextPerk ? (\n          <View style={[styles.perkPreview, { backgroundColor: colors.backgroundSecondary }]}>\n            <Feather name=\"gift\" size={18} color={colors.primary} />\n            <View style={styles.perkInfo}>\n              <ThemedText style={[styles.perkTitle, { color: colors.text }]}>\n                Level {nextPerk.level} Perk\n              </ThemedText>\n              <ThemedText style={[styles.perkDescription, { color: colors.textSecondary }]}>\n                {nextPerk.perk}\n              </ThemedText>\n            </View>\n          </View>\n        ) : null}\n\n        {levelInfo.perk ? (\n          <View style={[styles.currentPerk, { backgroundColor: colors.success + '15' }]}>\n            <Feather name=\"check-circle\" size={16} color={colors.success} />\n            <View style={styles.currentPerkContent}>\n              <ThemedText style={[styles.currentPerkText, { color: colors.success }]}>\n                Unlocked: {levelInfo.perk}\n              </ThemedText>\n              {profile.current_level >= 10 && levelInfo.perk.includes('Voucher') ? (\n                <Pressable \n                  style={[styles.claimButton, { backgroundColor: colors.primary }]}\n                  onPress={() => setVoucherModal(true)}\n                >\n                  <Feather name=\"gift\" size={14} color=\"#fff\" />\n                  <ThemedText style={styles.claimButtonText}>Claim</ThemedText>\n                </Pressable>\n              ) : null}\n            </View>\n          </View>\n        ) : null}\n\n        <View style={styles.detailedStats}>\n          <View style={styles.detailedStatRow}>\n            <View style={styles.detailedStatLabelRow}>\n              <ThemedText style={[styles.detailedStatLabel, { color: colors.textSecondary }]}>\n                Longest Streak\n              </ThemedText>\n              <HelpIcon onPress={() => setHelpModal({ visible: true, stat: 'longestStreak' })} />\n            </View>\n            <ThemedText style={[styles.detailedStatValue, { color: colors.text }]}>\n              {profile.longest_streak} days\n            </ThemedText>\n          </View>\n          <View style={styles.detailedStatRow}>\n            <View style={styles.detailedStatLabelRow}>\n              <ThemedText style={[styles.detailedStatLabel, { color: colors.textSecondary }]}>\n                Total Split Volume\n              </ThemedText>\n              <HelpIcon onPress={() => setHelpModal({ visible: true, stat: 'splitVolume' })} />\n            </View>\n            <ThemedText style={[styles.detailedStatValue, { color: colors.text }]}>\n              ${profile.total_amount_split.toLocaleString()}\n            </ThemedText>\n          </View>\n          <View style={styles.detailedStatRow}>\n            <View style={styles.detailedStatLabelRow}>\n              <ThemedText style={[styles.detailedStatLabel, { color: colors.textSecondary }]}>\n                Splits Completed as Leader\n              </ThemedText>\n              <HelpIcon onPress={() => setHelpModal({ visible: true, stat: 'splitsAsLeader' })} />\n            </View>\n            <ThemedText style={[styles.detailedStatValue, { color: colors.text }]}>\n              {profile.splits_completed_as_creator}\n            </ThemedText>\n          </View>\n        </View>\n\n        {showBadges && profile.badges.length > 0 ? (\n          <View style={styles.badgesSection}>\n            <ThemedText style={[styles.badgesTitle, { color: colors.text }]}>\n              Badges ({profile.badges.length})\n            </ThemedText>\n            <View style={styles.badgesGrid}>\n              {profile.badges.slice(0, 6).map((badge) => (\n                <View\n                  key={badge.badge_id}\n                  style={[\n                    styles.badgeItem,\n                    { backgroundColor: TIER_COLORS[badge.badge_tier] + '20' },\n                  ]}\n                >\n                  <Feather\n                    name={badge.badge_icon as any}\n                    size={20}\n                    color={TIER_COLORS[badge.badge_tier]}\n                  />\n                  <ThemedText\n                    style={[styles.badgeName, { color: colors.text }]}\n                    numberOfLines={1}\n                  >\n                    {badge.badge_name}\n                  </ThemedText>\n                </View>\n              ))}\n            </View>\n          </View>\n        ) : null}\n\n        {profile.recent_xp.length > 0 ? (\n          <View style={styles.recentXPSection}>\n            <ThemedText style={[styles.recentXPTitle, { color: colors.text }]}>\n              Recent Activity\n            </ThemedText>\n            {profile.recent_xp.slice(0, 3).map((item, index) => (\n              <View key={index} style={styles.recentXPItem}>\n                <View style={[styles.xpBadge, { backgroundColor: colors.primary + '20' }]}>\n                  <ThemedText style={[styles.xpBadgeText, { color: colors.primary }]}>\n                    +{item.xp_amount}\n                  </ThemedText>\n                </View>\n                <ThemedText\n                  style={[styles.recentXPDescription, { color: colors.textSecondary }]}\n                  numberOfLines={1}\n                >\n                  {item.description}\n                </ThemedText>\n              </View>\n            ))}\n          </View>\n        ) : null}\n      </Animated.View>\n\n      {helpModal.stat ? (\n        <StatHelpModal\n          visible={helpModal.visible}\n          onClose={() => setHelpModal({ visible: false, stat: null })}\n          title={STAT_HELP_INFO[helpModal.stat].title}\n          description={STAT_HELP_INFO[helpModal.stat].description}\n          howToEarn={STAT_HELP_INFO[helpModal.stat].howToEarn}\n          example={STAT_HELP_INFO[helpModal.stat].example}\n        />\n      ) : null}\n\n      <VoucherClaimModal\n        visible={voucherModal}\n        onClose={() => setVoucherModal(false)}\n        userId={userId}\n        voucherType=\"dinner_voucher\"\n        voucherValue=\"$50 Dinner Voucher\"\n        levelRequired={10}\n      />\n    </ThemedView>\n  );\n}\n\nexport function LevelBadge({ level, size = 'small', showTitle = false, variant = 'default' }: { \n  level: number; \n  size?: 'small' | 'medium'; \n  showTitle?: boolean;\n  variant?: 'default' | 'compact' | 'pill';\n}) {\n  const { theme: colors } = useTheme();\n  const badgeColor = GamificationService.getLevelColor(level);\n  const title = GamificationService.getTitleForLevel(level);\n\n  const sizeStyles = size === 'small' ? styles.levelBadgeSmall : styles.levelBadgeMedium;\n  const textStyle = size === 'small' ? styles.levelBadgeTextSmall : styles.levelBadgeTextMedium;\n\n  // Pill variant - elegant minimal display for participant lists\n  if (variant === 'pill') {\n    return (\n      <View style={[styles.levelBadgePill, { backgroundColor: badgeColor + '20' }]}>\n        <View style={[styles.levelBadgePillDot, { backgroundColor: badgeColor }]} />\n        <ThemedText style={[styles.levelBadgePillText, { color: badgeColor }]}>\n          Lv.{level}\n        </ThemedText>\n      </View>\n    );\n  }\n\n  // Compact variant - just shows the level circle with title below it\n  if (variant === 'compact') {\n    return (\n      <View style={styles.levelBadgeCompact}>\n        <View style={[styles.levelBadgeCompactCircle, { backgroundColor: badgeColor + '25', borderColor: badgeColor }]}>\n          <ThemedText style={[styles.levelBadgeCompactNumber, { color: badgeColor }]}>{level}</ThemedText>\n        </View>\n        <ThemedText style={[styles.levelBadgeCompactTitle, { color: badgeColor }]} numberOfLines={1}>\n          {title}\n        </ThemedText>\n      </View>\n    );\n  }\n\n  if (showTitle) {\n    return (\n      <View style={styles.levelBadgeWithTitle}>\n        <View style={[sizeStyles, { backgroundColor: badgeColor + '30', borderColor: badgeColor }]}>\n          <ThemedText style={[textStyle, { color: badgeColor }]}>{level}</ThemedText>\n        </View>\n        <ThemedText style={[styles.levelTitleText, { color: badgeColor }]}>{title}</ThemedText>\n      </View>\n    );\n  }\n\n  return (\n    <View style={[sizeStyles, { backgroundColor: badgeColor + '30', borderColor: badgeColor }]}>\n      <ThemedText style={[textStyle, { color: badgeColor }]}>{level}</ThemedText>\n    </View>\n  );\n}\n\ninterface StatHelpModalProps {\n  visible: boolean;\n  onClose: () => void;\n  title: string;\n  description: string;\n  howToEarn?: string;\n  example?: string;\n}\n\nexport function StatHelpModal({ visible, onClose, title, description, howToEarn, example }: StatHelpModalProps) {\n  const { theme: colors } = useTheme();\n\n  return (\n    <Modal\n      visible={visible}\n      transparent\n      animationType=\"fade\"\n      onRequestClose={onClose}\n    >\n      <Pressable style={styles.helpModalOverlay} onPress={onClose}>\n        <Pressable style={[styles.helpModalContent, { backgroundColor: colors.surface }]} onPress={() => {}}>\n          <View style={styles.helpModalHeader}>\n            <ThemedText style={[styles.helpModalTitle, { color: colors.text }]}>{title}</ThemedText>\n            <Pressable onPress={onClose} style={styles.helpCloseBtn}>\n              <Feather name=\"x\" size={22} color={colors.textSecondary} />\n            </Pressable>\n          </View>\n          <ThemedText style={[styles.helpModalDescription, { color: colors.textSecondary }]}>\n            {description}\n          </ThemedText>\n          {example ? (\n            <View style={[styles.helpExampleSection, { backgroundColor: colors.backgroundSecondary }]}>\n              <Feather name=\"info\" size={14} color={colors.textSecondary} />\n              <ThemedText style={[styles.helpExampleText, { color: colors.textSecondary }]}>\n                {example}\n              </ThemedText>\n            </View>\n          ) : null}\n          {howToEarn ? (\n            <View style={[styles.helpEarnSection, { backgroundColor: colors.primary + '15' }]}>\n              <Feather name=\"zap\" size={16} color={colors.primary} />\n              <ThemedText style={[styles.helpEarnText, { color: colors.primary }]}>\n                {howToEarn}\n              </ThemedText>\n            </View>\n          ) : null}\n        </Pressable>\n      </Pressable>\n    </Modal>\n  );\n}\n\ninterface HelpIconProps {\n  onPress: () => void;\n  size?: 'small' | 'medium';\n}\n\nexport function HelpIcon({ onPress, size = 'small' }: HelpIconProps) {\n  const { theme: colors } = useTheme();\n  const iconSize = size === 'small' ? 12 : 14;\n  const containerSize = size === 'small' ? 16 : 20;\n  \n  return (\n    <Pressable \n      onPress={onPress} \n      style={[\n        styles.helpIconBtn, \n        { \n          width: containerSize, \n          height: containerSize,\n          borderRadius: containerSize / 2,\n          backgroundColor: colors.textSecondary + '15',\n        }\n      ]} \n      hitSlop={{ top: 8, bottom: 8, left: 8, right: 8 }}\n    >\n      <ThemedText style={[styles.helpIconText, { color: colors.textSecondary, fontSize: iconSize - 2 }]}>?</ThemedText>\n    </Pressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    borderRadius: BorderRadius.md,\n    padding: Spacing.lg,\n    marginBottom: Spacing.md,\n  },\n  loadingContainer: {\n    alignItems: 'center',\n    padding: Spacing.lg,\n  },\n  loadingText: {\n    ...Typography.caption,\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: Spacing.md,\n  },\n  levelSection: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: Spacing.md,\n  },\n  levelCircle: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    borderWidth: 3,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  levelNumber: {\n    ...Typography.h1,\n    fontWeight: '700',\n  },\n  levelInfo: {\n    gap: 2,\n  },\n  title: {\n    ...Typography.h2,\n  },\n  xpText: {\n    ...Typography.caption,\n  },\n  progressSection: {\n    marginBottom: Spacing.lg,\n  },\n  progressBar: {\n    height: 8,\n    borderRadius: 4,\n    overflow: 'hidden',\n    marginBottom: Spacing.xs,\n  },\n  progressFill: {\n    height: '100%',\n    borderRadius: 4,\n  },\n  progressText: {\n    ...Typography.small,\n  },\n  statsRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-around',\n    alignItems: 'center',\n  },\n  statItem: {\n    alignItems: 'center',\n    flex: 1,\n  },\n  statValue: {\n    ...Typography.h2,\n    fontWeight: '700',\n  },\n  statLabel: {\n    fontSize: 11,\n    textAlign: 'center',\n  },\n  statLabelRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    marginTop: 2,\n  },\n  statDivider: {\n    width: 1,\n    height: 30,\n  },\n  expandedContent: {\n    overflow: 'hidden',\n  },\n  perkPreview: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: Spacing.md,\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    marginTop: Spacing.lg,\n  },\n  perkInfo: {\n    flex: 1,\n  },\n  perkTitle: {\n    ...Typography.caption,\n    fontWeight: '600',\n  },\n  perkDescription: {\n    ...Typography.small,\n  },\n  currentPerk: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    gap: Spacing.sm,\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    marginTop: Spacing.md,\n  },\n  currentPerkContent: {\n    flex: 1,\n    gap: Spacing.sm,\n  },\n  currentPerkText: {\n    ...Typography.caption,\n    fontWeight: '500',\n  },\n  claimButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    gap: 4,\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.xs,\n    borderRadius: BorderRadius.sm,\n    alignSelf: 'flex-start',\n  },\n  claimButtonText: {\n    fontSize: 12,\n    fontWeight: '600',\n    color: '#fff',\n  },\n  detailedStats: {\n    marginTop: Spacing.lg,\n    gap: Spacing.sm,\n  },\n  detailedStatRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n  },\n  detailedStatLabelRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: 4,\n  },\n  detailedStatLabel: {\n    ...Typography.caption,\n  },\n  detailedStatValue: {\n    ...Typography.caption,\n    fontWeight: '600',\n  },\n  badgesSection: {\n    marginTop: Spacing.lg,\n  },\n  badgesTitle: {\n    ...Typography.caption,\n    fontWeight: '600',\n    marginBottom: Spacing.sm,\n  },\n  badgesGrid: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: Spacing.sm,\n  },\n  badgeItem: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: Spacing.xs,\n    paddingHorizontal: Spacing.sm,\n    paddingVertical: Spacing.xs,\n    borderRadius: BorderRadius.xs,\n  },\n  badgeName: {\n    ...Typography.small,\n    fontWeight: '500',\n  },\n  recentXPSection: {\n    marginTop: Spacing.lg,\n  },\n  recentXPTitle: {\n    ...Typography.caption,\n    fontWeight: '600',\n    marginBottom: Spacing.sm,\n  },\n  recentXPItem: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: Spacing.sm,\n    marginBottom: Spacing.xs,\n  },\n  xpBadge: {\n    paddingHorizontal: Spacing.sm,\n    paddingVertical: 2,\n    borderRadius: BorderRadius.xs,\n  },\n  xpBadgeText: {\n    ...Typography.small,\n    fontWeight: '600',\n  },\n  recentXPDescription: {\n    ...Typography.small,\n    flex: 1,\n  },\n  compactContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: Spacing.sm,\n    padding: Spacing.sm,\n    borderRadius: BorderRadius.sm,\n  },\n  compactLevelBadge: {\n    width: 28,\n    height: 28,\n    borderRadius: 14,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  compactLevel: {\n    ...Typography.caption,\n    fontWeight: '700',\n  },\n  compactInfo: {\n    flex: 1,\n    gap: 2,\n  },\n  compactTitle: {\n    ...Typography.small,\n    fontWeight: '600',\n  },\n  compactProgressBar: {\n    height: 4,\n    borderRadius: 2,\n    overflow: 'hidden',\n  },\n  compactProgressFill: {\n    height: '100%',\n    borderRadius: 2,\n  },\n  compactXP: {\n    ...Typography.small,\n  },\n  levelBadgeSmall: {\n    width: 20,\n    height: 20,\n    borderRadius: 10,\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderWidth: 1.5,\n  },\n  levelBadgeMedium: {\n    width: 28,\n    height: 28,\n    borderRadius: 14,\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderWidth: 2,\n  },\n  levelBadgeTextSmall: {\n    fontSize: 10,\n    fontWeight: '700',\n  },\n  levelBadgeTextMedium: {\n    fontSize: 12,\n    fontWeight: '700',\n  },\n  levelBadgeWithTitle: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: Spacing.xs,\n  },\n  levelTitleText: {\n    fontSize: 11,\n    fontWeight: '600',\n  },\n  levelBadgePill: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: 8,\n    paddingVertical: 3,\n    borderRadius: 12,\n    gap: 4,\n  },\n  levelBadgePillDot: {\n    width: 6,\n    height: 6,\n    borderRadius: 3,\n  },\n  levelBadgePillText: {\n    fontSize: 10,\n    fontWeight: '700',\n    letterSpacing: 0.3,\n  },\n  levelBadgeCompact: {\n    alignItems: 'center',\n    gap: 2,\n  },\n  levelBadgeCompactCircle: {\n    width: 24,\n    height: 24,\n    borderRadius: 12,\n    borderWidth: 1.5,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  levelBadgeCompactNumber: {\n    fontSize: 11,\n    fontWeight: '700',\n  },\n  levelBadgeCompactTitle: {\n    fontSize: 9,\n    fontWeight: '600',\n    maxWidth: 60,\n    textAlign: 'center',\n  },\n  helpModalOverlay: {\n    flex: 1,\n    backgroundColor: 'rgba(0,0,0,0.5)',\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: Spacing.xl,\n  },\n  helpModalContent: {\n    width: '100%',\n    maxWidth: 340,\n    padding: Spacing.xl,\n    borderRadius: BorderRadius.md,\n  },\n  helpModalHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: Spacing.md,\n  },\n  helpModalTitle: {\n    fontSize: 18,\n    fontWeight: '700',\n    flex: 1,\n  },\n  helpModalDescription: {\n    fontSize: 15,\n    lineHeight: 22,\n    marginBottom: Spacing.md,\n  },\n  helpCloseBtn: {\n    padding: Spacing.xs,\n    marginLeft: Spacing.sm,\n  },\n  helpExampleSection: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    marginBottom: Spacing.md,\n    gap: Spacing.sm,\n  },\n  helpExampleText: {\n    fontSize: 13,\n    lineHeight: 18,\n    flex: 1,\n    fontStyle: 'italic',\n  },\n  helpEarnSection: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.sm,\n  },\n  helpEarnText: {\n    fontSize: 14,\n    lineHeight: 20,\n    flex: 1,\n    fontWeight: '500',\n  },\n  helpIconBtn: {\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginLeft: 4,\n  },\n  helpIconText: {\n    fontWeight: '600',\n  },\n});\n","path":null,"size_bytes":29319,"size_tokens":null},"services/gamification.service.ts":{"content":"import { supabase } from './supabase';\n\nexport interface GamificationProfile {\n  total_xp: number;\n  current_level: number;\n  xp_to_next_level: number;\n  xp_progress_percent: number;\n  current_streak: number;\n  longest_streak: number;\n  title: string;\n  splits_created: number;\n  splits_paid_on_time: number;\n  splits_completed_as_creator: number;\n  total_amount_split: number;\n  friends_referred: number;\n  badges: Badge[];\n  recent_xp: XPHistoryItem[];\n}\n\nexport interface Badge {\n  badge_id: string;\n  badge_name: string;\n  badge_description: string;\n  badge_icon: string;\n  badge_tier: 'bronze' | 'silver' | 'gold' | 'platinum';\n  earned_at: string;\n}\n\nexport interface XPHistoryItem {\n  xp_amount: number;\n  action_type: string;\n  description: string;\n  created_at: string;\n}\n\nexport interface XPAwardResult {\n  success: boolean;\n  xp_awarded: number;\n  new_total_xp: number;\n  new_level: number;\n  xp_to_next_level: number;\n  leveled_up: boolean;\n  old_level: number;\n  new_title: string;\n}\n\n// XP Values for different actions\nexport const XP_VALUES = {\n  // Split Creation (creator reward)\n  SPLIT_CREATED: 25,              // Base XP for creating a split\n  SPLIT_CREATED_LARGE: 40,        // Bonus for splits over $100\n  SPLIT_CREATED_GROUP: 15,        // Per additional participant beyond 2\n  \n  // Payment Actions\n  SPLIT_PAID: 20,                 // Base XP for paying your share\n  SPLIT_PAID_FAST: 35,            // Bonus for paying within 1 hour\n  SPLIT_PAID_SAME_DAY: 28,        // Bonus for paying same day\n  \n  // Completion Bonuses\n  SPLIT_COMPLETED_CREATOR: 50,    // Creator bonus when 100% complete\n  SPLIT_COMPLETED_PARTICIPANT: 15, // Participant bonus when split completes\n  \n  // Streak Bonuses (calculated dynamically)\n  STREAK_WEEKLY: 20,              // 7-day streak bonus\n  STREAK_MONTHLY: 100,            // 30-day streak bonus\n  \n  // Special Achievements\n  FIRST_SPLIT_CREATED: 50,        // First time creating a split\n  FIRST_SPLIT_PAID: 30,           // First time paying a split\n  REFERRAL_BONUS: 75,             // When a referred friend joins\n  \n  // Milestone bonuses\n  SPLITS_10_CREATED: 100,\n  SPLITS_25_CREATED: 250,\n  SPLITS_50_CREATED: 500,\n  SPLITS_100_CREATED: 1000,\n};\n\n// Level titles and their perks\n// Perks are manually approved by admin to prevent abuse\nexport const LEVEL_INFO: Record<number, { title: string; perk?: string }> = {\n  1: { title: 'Member' },\n  3: { title: 'Verified' },\n  5: { title: 'Silver' },\n  7: { title: 'Gold' },\n  10: { title: 'Platinum', perk: '$50 Dinner Voucher (claim in app)' },\n  15: { title: 'Premier', perk: 'Extended withdrawal limits' },\n  20: { title: 'Select', perk: '10% discount on fast withdrawals' },\n  25: { title: 'Private', perk: 'VIP restaurant partner discounts' },\n  30: { title: 'Elite', perk: 'Hotel partner benefits' },\n  40: { title: 'Prestige', perk: 'Airport lounge access (coming soon)' },\n  50: { title: 'Chairman', perk: 'Premium concierge service' },\n};\n\n// Anti-abuse constants for XP system\nexport const ANTI_ABUSE_LIMITS = {\n  // Minimum split amount to earn XP\n  MIN_SPLIT_AMOUNT_FOR_XP: 5.00,\n  \n  // Maximum XP that can be earned from splits with the same friend per week\n  MAX_XP_PER_FRIEND_PER_WEEK: 200,\n  \n  // Maximum number of splits that count for XP with same friend per day\n  MAX_SPLITS_PER_FRIEND_PER_DAY: 3,\n  \n  // Cooldown between splits with identical participants (minutes)\n  IDENTICAL_PARTICIPANT_COOLDOWN_MINUTES: 30,\n  \n  // Daily XP cap from splits (prevents farming)\n  DAILY_SPLIT_XP_CAP: 500,\n  \n  // Minimum time between creating splits (seconds)\n  MIN_TIME_BETWEEN_SPLITS_SECONDS: 60,\n  \n  // Suspicious activity threshold - too many quick payments\n  SUSPICIOUS_QUICK_PAYMENT_COUNT: 10,\n  SUSPICIOUS_QUICK_PAYMENT_WINDOW_HOURS: 1,\n};\n\n// Badge definitions\nexport const BADGE_DEFINITIONS = {\n  // Starter badges\n  first_split: {\n    id: 'first_split',\n    name: 'First Steps',\n    description: 'Created your first split',\n    icon: 'star',\n    tier: 'bronze' as const,\n  },\n  first_payment: {\n    id: 'first_payment',\n    name: 'Team Player',\n    description: 'Paid your first split share',\n    icon: 'check-circle',\n    tier: 'bronze' as const,\n  },\n  \n  // Creator badges\n  split_starter: {\n    id: 'split_starter',\n    name: 'Split Starter',\n    description: 'Created 10 splits',\n    icon: 'layers',\n    tier: 'bronze' as const,\n  },\n  split_organizer: {\n    id: 'split_organizer',\n    name: 'Event Organizer',\n    description: 'Created 25 splits',\n    icon: 'calendar',\n    tier: 'silver' as const,\n  },\n  split_master: {\n    id: 'split_master',\n    name: 'Split Master',\n    description: 'Created 50 splits',\n    icon: 'award',\n    tier: 'gold' as const,\n  },\n  split_legend: {\n    id: 'split_legend',\n    name: 'Legendary Organizer',\n    description: 'Created 100 splits',\n    icon: 'zap',\n    tier: 'platinum' as const,\n  },\n  \n  // Payer badges\n  reliable_payer: {\n    id: 'reliable_payer',\n    name: 'Reliable',\n    description: 'Paid 10 splits on time',\n    icon: 'thumbs-up',\n    tier: 'bronze' as const,\n  },\n  trusted_payer: {\n    id: 'trusted_payer',\n    name: 'Trusted Friend',\n    description: 'Paid 25 splits on time',\n    icon: 'shield',\n    tier: 'silver' as const,\n  },\n  perfect_record: {\n    id: 'perfect_record',\n    name: 'Perfect Record',\n    description: 'Paid 50 splits on time',\n    icon: 'check-square',\n    tier: 'gold' as const,\n  },\n  \n  // Speed badges\n  lightning_payer: {\n    id: 'lightning_payer',\n    name: 'Lightning Fast',\n    description: 'Paid 5 splits within 1 hour',\n    icon: 'zap',\n    tier: 'silver' as const,\n  },\n  \n  // Completion badges\n  completion_champion: {\n    id: 'completion_champion',\n    name: 'Completion Champion',\n    description: 'Led 10 splits to 100% completion',\n    icon: 'target',\n    tier: 'silver' as const,\n  },\n  full_house: {\n    id: 'full_house',\n    name: 'Full House',\n    description: 'Led 25 splits to 100% completion',\n    icon: 'users',\n    tier: 'gold' as const,\n  },\n  \n  // Streak badges\n  week_warrior: {\n    id: 'week_warrior',\n    name: 'Week Warrior',\n    description: 'Maintained a 7-day activity streak',\n    icon: 'trending-up',\n    tier: 'bronze' as const,\n  },\n  month_master: {\n    id: 'month_master',\n    name: 'Monthly Master',\n    description: 'Maintained a 30-day activity streak',\n    icon: 'calendar',\n    tier: 'gold' as const,\n  },\n  \n  // Social badges\n  social_butterfly: {\n    id: 'social_butterfly',\n    name: 'Social Butterfly',\n    description: 'Split bills with 10+ different friends',\n    icon: 'users',\n    tier: 'silver' as const,\n  },\n  community_builder: {\n    id: 'community_builder',\n    name: 'Community Builder',\n    description: 'Referred 3 friends to Spline',\n    icon: 'gift',\n    tier: 'gold' as const,\n  },\n};\n\n// Level thresholds for calculating level from XP\nconst LEVEL_THRESHOLDS = [0, 100, 300, 600, 1000, 1500, 2100, 2800, 3600, 4500, 5500, 6600, 7800, 9100, 10500, 12000, 13600, 15300, 17100, 19000, 21000, 23100, 25300, 27600, 30000, 32500, 35100, 37800, 40600, 43500, 46500, 49600, 52800, 56100, 59500, 63000, 66600, 70300, 74100, 78000, 82000, 86100, 90300, 94600, 99000, 103500, 108100, 112800, 117600, 122500];\n\nfunction calculateLevel(totalXP: number): number {\n  for (let i = LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {\n    if (totalXP >= LEVEL_THRESHOLDS[i]) {\n      return i + 1;\n    }\n  }\n  return 1;\n}\n\nfunction calculateXPToNextLevel(totalXP: number, currentLevel: number): number {\n  if (currentLevel >= LEVEL_THRESHOLDS.length) return 0;\n  return LEVEL_THRESHOLDS[currentLevel] - totalXP;\n}\n\nfunction getTitleForLevel(level: number): string {\n  if (level >= 50) return 'Chairman';\n  if (level >= 40) return 'Prestige';\n  if (level >= 30) return 'Elite';\n  if (level >= 25) return 'Private';\n  if (level >= 20) return 'Select';\n  if (level >= 15) return 'Premier';\n  if (level >= 10) return 'Platinum';\n  if (level >= 7) return 'Gold';\n  if (level >= 5) return 'Silver';\n  if (level >= 3) return 'Verified';\n  return 'Member';\n}\n\nexport class GamificationService {\n  /**\n   * Initialize gamification profile for a new user\n   * Uses direct table insert as fallback if RPC function doesn't exist\n   */\n  static async initializeUser(userId: string): Promise<void> {\n    try {\n      // First try RPC\n      const { error: rpcError } = await supabase.rpc('initialize_user_gamification', {\n        p_user_id: userId\n      });\n      \n      if (rpcError) {\n        // Fallback: Direct table insert\n        console.log('RPC not available, using direct insert for gamification init');\n        const { error: insertError } = await supabase\n          .from('user_gamification')\n          .upsert({\n            user_id: userId,\n            total_xp: 0,\n            current_level: 1,\n            splits_paid: 0,\n            splits_created: 0,\n            current_streak: 0,\n            longest_streak: 0,\n            friends_referred: 0,\n            total_completed_splits: 0,\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n          }, { onConflict: 'user_id' });\n        \n        if (insertError && !insertError.message.includes('duplicate')) {\n          console.error('Failed to initialize gamification (direct):', insertError);\n        }\n      }\n    } catch (error) {\n      console.error('Failed to initialize gamification:', error);\n    }\n  }\n\n  /**\n   * Get user's gamification profile\n   * Returns a default profile if gamification tables don't exist\n   */\n  static async getProfile(userId: string): Promise<GamificationProfile | null> {\n    try {\n      // First try RPC\n      const { data: rpcData, error: rpcError } = await supabase.rpc('get_user_gamification', {\n        p_user_id: userId\n      });\n\n      if (!rpcError && rpcData) {\n        return rpcData as GamificationProfile;\n      }\n\n      // RPC failed - try direct table query\n      const { data: profile, error: profileError } = await supabase\n        .from('user_gamification')\n        .select('*')\n        .eq('user_id', userId)\n        .maybeSingle();\n\n      if (!profileError && profile) {\n        return this.buildProfileFromData(userId, profile);\n      }\n\n      // If the table doesn't exist or profile not found, return a sensible default\n      // This ensures the UI always has something to display\n      console.log('Gamification data not available, returning default profile');\n      return this.getDefaultProfile();\n    } catch (error) {\n      console.error('Error getting gamification profile:', error);\n      return this.getDefaultProfile();\n    }\n  }\n  \n  /**\n   * Get a default profile for users without gamification data\n   */\n  static getDefaultProfile(): GamificationProfile {\n    return {\n      total_xp: 0,\n      current_level: 1,\n      xp_to_next_level: 100,\n      xp_progress_percent: 0,\n      current_streak: 0,\n      longest_streak: 0,\n      title: 'Member',\n      splits_created: 0,\n      splits_paid_on_time: 0,\n      splits_completed_as_creator: 0,\n      total_amount_split: 0,\n      friends_referred: 0,\n      badges: [],\n      recent_xp: []\n    };\n  }\n\n  /**\n   * Build a GamificationProfile from raw database data\n   */\n  private static async buildProfileFromData(userId: string, data: any): Promise<GamificationProfile> {\n    const totalXP = data.total_xp || 0;\n    const currentLevel = data.current_level || calculateLevel(totalXP);\n    const xpToNextLevel = calculateXPToNextLevel(totalXP, currentLevel);\n    const currentLevelThreshold = currentLevel > 0 ? LEVEL_THRESHOLDS[currentLevel - 1] : 0;\n    const nextLevelThreshold = currentLevel < LEVEL_THRESHOLDS.length ? LEVEL_THRESHOLDS[currentLevel] : LEVEL_THRESHOLDS[LEVEL_THRESHOLDS.length - 1];\n    const xpProgress = nextLevelThreshold > currentLevelThreshold \n      ? ((totalXP - currentLevelThreshold) / (nextLevelThreshold - currentLevelThreshold)) * 100\n      : 100;\n\n    // Fetch badges\n    const { data: badges } = await supabase\n      .from('user_badges')\n      .select('badge_id, earned_at')\n      .eq('user_id', userId);\n\n    // Fetch recent XP history\n    const { data: recentXP } = await supabase\n      .from('xp_history')\n      .select('xp_amount, action_type, description, created_at')\n      .eq('user_id', userId)\n      .order('created_at', { ascending: false })\n      .limit(10);\n\n    const formattedBadges: Badge[] = (badges || []).map(b => {\n      const badgeDef = BADGE_DEFINITIONS[b.badge_id as keyof typeof BADGE_DEFINITIONS];\n      return {\n        badge_id: b.badge_id,\n        badge_name: badgeDef?.name || b.badge_id,\n        badge_description: badgeDef?.description || '',\n        badge_icon: badgeDef?.icon || 'award',\n        badge_tier: badgeDef?.tier || 'bronze',\n        earned_at: b.earned_at\n      };\n    });\n\n    return {\n      total_xp: totalXP,\n      current_level: currentLevel,\n      xp_to_next_level: xpToNextLevel,\n      xp_progress_percent: Math.min(100, Math.max(0, xpProgress)),\n      current_streak: data.current_streak || 0,\n      longest_streak: data.longest_streak || 0,\n      title: getTitleForLevel(currentLevel),\n      splits_created: data.splits_created || 0,\n      splits_paid_on_time: data.splits_paid || 0,\n      splits_completed_as_creator: data.total_completed_splits || 0,\n      total_amount_split: 0, // Not tracked directly\n      friends_referred: data.friends_referred || 0,\n      badges: formattedBadges,\n      recent_xp: (recentXP || []).map(x => ({\n        xp_amount: x.xp_amount,\n        action_type: x.action_type,\n        description: x.description,\n        created_at: x.created_at\n      }))\n    };\n  }\n\n  /**\n   * Award XP to a user\n   * Returns null if gamification system is not available (non-blocking)\n   */\n  static async awardXP(\n    userId: string,\n    xpAmount: number,\n    actionType: string,\n    description: string,\n    splitEventId?: string\n  ): Promise<XPAwardResult | null> {\n    try {\n      const { data, error } = await supabase.rpc('award_xp', {\n        p_user_id: userId,\n        p_xp_amount: xpAmount,\n        p_action_type: actionType,\n        p_description: description,\n        p_split_event_id: splitEventId || null\n      });\n\n      if (error) {\n        // Log but don't throw - gamification is non-blocking\n        console.log('Gamification: XP award skipped (RPC not available):', actionType, xpAmount);\n        return null;\n      }\n\n      // Update streak as well (non-blocking)\n      this.updateStreak(userId).catch(() => {});\n\n      return data as XPAwardResult;\n    } catch (error) {\n      console.log('Gamification: XP award skipped (error):', actionType);\n      return null;\n    }\n  }\n\n  /**\n   * Update user's activity streak\n   * Non-blocking - returns null if gamification not available\n   */\n  static async updateStreak(userId: string): Promise<{ new_streak: number; streak_bonus_xp: number } | null> {\n    try {\n      const { data, error } = await supabase.rpc('update_user_streak', {\n        p_user_id: userId\n      });\n\n      if (error) {\n        console.log('Gamification: Streak update skipped (RPC not available)');\n        return null;\n      }\n\n      // If there's a streak bonus, award it (non-blocking)\n      if (data?.streak_bonus_xp > 0) {\n        this.awardXP(\n          userId,\n          data.streak_bonus_xp,\n          'streak_bonus',\n          `${data.new_streak}-day streak bonus!`\n        ).catch(() => {});\n      }\n\n      return data;\n    } catch (error) {\n      console.log('Gamification: Streak update skipped (error)');\n      return null;\n    }\n  }\n\n  /**\n   * Update a specific stat\n   * Non-blocking - logs and continues if gamification not available\n   */\n  static async updateStat(\n    userId: string,\n    statType: 'splits_created' | 'splits_paid_on_time' | 'splits_completed_as_creator' | 'total_amount_split' | 'friends_referred',\n    amount: number = 1\n  ): Promise<void> {\n    try {\n      const { error } = await supabase.rpc('update_gamification_stats', {\n        p_user_id: userId,\n        p_stat_type: statType,\n        p_amount: amount\n      });\n      \n      if (error) {\n        console.log('Gamification: Stat update skipped (RPC not available):', statType);\n      }\n    } catch (error) {\n      console.log('Gamification: Stat update skipped (error):', statType);\n    }\n  }\n\n  /**\n   * Award a badge to user\n   * Non-blocking - returns false if gamification not available\n   */\n  static async awardBadge(\n    userId: string,\n    badgeId: keyof typeof BADGE_DEFINITIONS\n  ): Promise<boolean> {\n    const badge = BADGE_DEFINITIONS[badgeId];\n    if (!badge) return false;\n\n    try {\n      const { data, error } = await supabase.rpc('award_badge', {\n        p_user_id: userId,\n        p_badge_id: badge.id,\n        p_badge_name: badge.name,\n        p_badge_description: badge.description,\n        p_badge_icon: badge.icon,\n        p_badge_tier: badge.tier\n      });\n\n      if (error) {\n        console.log('Gamification: Badge award skipped (RPC not available):', badgeId);\n        return false;\n      }\n\n      return data?.success || false;\n    } catch (error) {\n      console.log('Gamification: Badge award skipped (error):', badgeId);\n      return false;\n    }\n  }\n\n  /**\n   * Check and award badges based on stats\n   */\n  static async checkAndAwardBadges(userId: string): Promise<string[]> {\n    const profile = await this.getProfile(userId);\n    if (!profile) return [];\n\n    const awardedBadges: string[] = [];\n    const existingBadgeIds = new Set(profile.badges.map(b => b.badge_id));\n\n    // Check creator milestones\n    if (profile.splits_created >= 1 && !existingBadgeIds.has('first_split')) {\n      if (await this.awardBadge(userId, 'first_split')) {\n        awardedBadges.push('first_split');\n      }\n    }\n    if (profile.splits_created >= 10 && !existingBadgeIds.has('split_starter')) {\n      if (await this.awardBadge(userId, 'split_starter')) {\n        awardedBadges.push('split_starter');\n      }\n    }\n    if (profile.splits_created >= 25 && !existingBadgeIds.has('split_organizer')) {\n      if (await this.awardBadge(userId, 'split_organizer')) {\n        awardedBadges.push('split_organizer');\n      }\n    }\n    if (profile.splits_created >= 50 && !existingBadgeIds.has('split_master')) {\n      if (await this.awardBadge(userId, 'split_master')) {\n        awardedBadges.push('split_master');\n      }\n    }\n    if (profile.splits_created >= 100 && !existingBadgeIds.has('split_legend')) {\n      if (await this.awardBadge(userId, 'split_legend')) {\n        awardedBadges.push('split_legend');\n      }\n    }\n\n    // Check payer milestones\n    if (profile.splits_paid_on_time >= 1 && !existingBadgeIds.has('first_payment')) {\n      if (await this.awardBadge(userId, 'first_payment')) {\n        awardedBadges.push('first_payment');\n      }\n    }\n    if (profile.splits_paid_on_time >= 10 && !existingBadgeIds.has('reliable_payer')) {\n      if (await this.awardBadge(userId, 'reliable_payer')) {\n        awardedBadges.push('reliable_payer');\n      }\n    }\n    if (profile.splits_paid_on_time >= 25 && !existingBadgeIds.has('trusted_payer')) {\n      if (await this.awardBadge(userId, 'trusted_payer')) {\n        awardedBadges.push('trusted_payer');\n      }\n    }\n    if (profile.splits_paid_on_time >= 50 && !existingBadgeIds.has('perfect_record')) {\n      if (await this.awardBadge(userId, 'perfect_record')) {\n        awardedBadges.push('perfect_record');\n      }\n    }\n\n    // Check completion milestones\n    if (profile.splits_completed_as_creator >= 10 && !existingBadgeIds.has('completion_champion')) {\n      if (await this.awardBadge(userId, 'completion_champion')) {\n        awardedBadges.push('completion_champion');\n      }\n    }\n    if (profile.splits_completed_as_creator >= 25 && !existingBadgeIds.has('full_house')) {\n      if (await this.awardBadge(userId, 'full_house')) {\n        awardedBadges.push('full_house');\n      }\n    }\n\n    // Check streak milestones\n    if (profile.longest_streak >= 7 && !existingBadgeIds.has('week_warrior')) {\n      if (await this.awardBadge(userId, 'week_warrior')) {\n        awardedBadges.push('week_warrior');\n      }\n    }\n    if (profile.longest_streak >= 30 && !existingBadgeIds.has('month_master')) {\n      if (await this.awardBadge(userId, 'month_master')) {\n        awardedBadges.push('month_master');\n      }\n    }\n\n    // Check referral milestones\n    if (profile.friends_referred >= 3 && !existingBadgeIds.has('community_builder')) {\n      if (await this.awardBadge(userId, 'community_builder')) {\n        awardedBadges.push('community_builder');\n      }\n    }\n\n    return awardedBadges;\n  }\n\n  /**\n   * Handle split creation - award XP to creator\n   * Includes anti-abuse validation\n   */\n  static async onSplitCreated(\n    creatorId: string,\n    splitEventId: string,\n    totalAmount: number,\n    participantCount: number\n  ): Promise<XPAwardResult | null> {\n    // Anti-abuse: Validate XP eligibility\n    const validation = await this.validateXPEligibility(creatorId, totalAmount, 'split_created');\n    \n    // Always update stats even if XP not awarded\n    await this.updateStat(creatorId, 'splits_created');\n    await this.updateStat(creatorId, 'total_amount_split', totalAmount);\n    \n    if (!validation.eligible) {\n      console.log(`[Gamification] XP skipped for split creation: ${validation.reason}`);\n      // Still check badges based on stats\n      await this.checkAndAwardBadges(creatorId);\n      return null;\n    }\n\n    // Get current profile to check if first split\n    const profile = await this.getProfile(creatorId);\n    const isFirstSplit = !profile || profile.splits_created === 0;\n\n    // Calculate XP\n    let xp = XP_VALUES.SPLIT_CREATED;\n    let description = 'Created a new split';\n\n    // Bonus for large splits\n    if (totalAmount >= 100) {\n      xp += XP_VALUES.SPLIT_CREATED_LARGE - XP_VALUES.SPLIT_CREATED;\n      description = 'Created a large split ($100+)';\n    }\n\n    // Bonus for group splits (more than 2 people)\n    if (participantCount > 2) {\n      xp += XP_VALUES.SPLIT_CREATED_GROUP * (participantCount - 2);\n      description = `Created a group split with ${participantCount} people`;\n    }\n\n    // First split bonus\n    if (isFirstSplit) {\n      xp += XP_VALUES.FIRST_SPLIT_CREATED;\n      description = 'Created your first split!';\n    }\n\n    // Apply multiplier if any\n    if (validation.xpMultiplier && validation.xpMultiplier !== 1.0) {\n      xp = Math.round(xp * validation.xpMultiplier);\n    }\n\n    // Award XP\n    const result = await this.awardXP(creatorId, xp, 'split_created', description, splitEventId);\n\n    // Check for new badges\n    await this.checkAndAwardBadges(creatorId);\n\n    return result;\n  }\n\n  /**\n   * Handle split payment - award XP to payer\n   * Includes anti-abuse validation\n   */\n  static async onSplitPaid(\n    payerId: string,\n    splitEventId: string,\n    amount: number,\n    splitCreatedAt: Date\n  ): Promise<XPAwardResult | null> {\n    // Anti-abuse: Validate XP eligibility\n    const validation = await this.validateXPEligibility(payerId, amount, 'split_paid');\n    \n    // Always update stats even if XP not awarded\n    await this.updateStat(payerId, 'splits_paid_on_time');\n    \n    if (!validation.eligible) {\n      console.log(`[Gamification] XP skipped for split payment: ${validation.reason}`);\n      // Still check badges based on stats\n      await this.checkAndAwardBadges(payerId);\n      return null;\n    }\n\n    const profile = await this.getProfile(payerId);\n    const isFirstPayment = !profile || profile.splits_paid_on_time === 0;\n\n    // Calculate time since split was created\n    const now = new Date();\n    const hoursSinceCreation = (now.getTime() - splitCreatedAt.getTime()) / (1000 * 60 * 60);\n\n    let xp = XP_VALUES.SPLIT_PAID;\n    let description = 'Paid your share';\n\n    // Speed bonuses\n    if (hoursSinceCreation <= 1) {\n      xp = XP_VALUES.SPLIT_PAID_FAST;\n      description = 'Paid within 1 hour - Lightning fast!';\n    } else if (hoursSinceCreation <= 24) {\n      xp = XP_VALUES.SPLIT_PAID_SAME_DAY;\n      description = 'Paid same day - Quick response!';\n    }\n\n    // First payment bonus\n    if (isFirstPayment) {\n      xp += XP_VALUES.FIRST_SPLIT_PAID;\n      description = 'Paid your first split share!';\n    }\n\n    // Apply multiplier if any\n    if (validation.xpMultiplier && validation.xpMultiplier !== 1.0) {\n      xp = Math.round(xp * validation.xpMultiplier);\n    }\n\n    // Award XP\n    const result = await this.awardXP(payerId, xp, 'split_paid', description, splitEventId);\n\n    // Check for new badges\n    await this.checkAndAwardBadges(payerId);\n\n    return result;\n  }\n\n  /**\n   * Handle split completion (100%) - award bonus to creator and all participants\n   */\n  static async onSplitCompleted(\n    creatorId: string,\n    splitEventId: string,\n    participantIds: string[]\n  ): Promise<void> {\n    // Award creator bonus\n    await this.updateStat(creatorId, 'splits_completed_as_creator');\n    await this.awardXP(\n      creatorId,\n      XP_VALUES.SPLIT_COMPLETED_CREATOR,\n      'split_completed',\n      'Split reached 100% completion! Leadership bonus.',\n      splitEventId\n    );\n\n    // Award participant bonuses (excluding creator)\n    for (const participantId of participantIds) {\n      if (participantId !== creatorId) {\n        await this.awardXP(\n          participantId,\n          XP_VALUES.SPLIT_COMPLETED_PARTICIPANT,\n          'split_completed',\n          'Contributed to a completed split!',\n          splitEventId\n        );\n      }\n    }\n\n    // Check badges for creator\n    await this.checkAndAwardBadges(creatorId);\n  }\n\n  /**\n   * Get level info including title and perks\n   */\n  static getLevelInfo(level: number): { title: string; perk?: string; nextPerkLevel?: number } {\n    // Find the highest level info that applies\n    let currentInfo = { title: 'Member' };\n    let nextPerkLevel: number | undefined;\n\n    for (const [lvl, info] of Object.entries(LEVEL_INFO).sort((a, b) => Number(a[0]) - Number(b[0]))) {\n      const levelNum = Number(lvl);\n      if (levelNum <= level) {\n        currentInfo = info;\n      } else if (info.perk && !nextPerkLevel) {\n        nextPerkLevel = levelNum;\n      }\n    }\n\n    return { ...currentInfo, nextPerkLevel };\n  }\n\n  /**\n   * Calculate XP needed for a specific level\n   */\n  static getXPForLevel(level: number): number {\n    // Exponential scaling formula\n    let totalXP = 0;\n    let levelXP = 100;\n    for (let i = 1; i < level; i++) {\n      totalXP += levelXP;\n      levelXP += (i + 1) * 75;\n    }\n    return totalXP;\n  }\n\n  /**\n   * Get simple level badge color based on level\n   */\n  static getLevelColor(level: number): string {\n    if (level >= 50) return '#FFD700'; // Gold\n    if (level >= 30) return '#C0C0C0'; // Silver\n    if (level >= 20) return '#CD7F32'; // Bronze\n    if (level >= 10) return '#9370DB'; // Purple\n    if (level >= 5) return '#4169E1';  // Royal Blue\n    return '#808080'; // Gray\n  }\n\n  /**\n   * Get title for a given level (public static method)\n   */\n  static getTitleForLevel(level: number): string {\n    return getTitleForLevel(level);\n  }\n\n  // ========== BALANCE MOMENTUM FEATURE ==========\n\n  /**\n   * Get user's current Balance Momentum status\n   * Returns tier, average balance, and streak info\n   */\n  static async getBalanceMomentum(userId: string): Promise<{\n    tier: 'none' | 'bronze' | 'silver' | 'gold';\n    avgBalance7d: number;\n    streakDays: number;\n    nextTierThreshold?: number;\n    xpPerDay: number;\n  }> {\n    try {\n      const { data, error } = await supabase\n        .from('user_gamification')\n        .select('balance_momentum_tier, avg_balance_7d, balance_streak_days')\n        .eq('user_id', userId)\n        .maybeSingle();\n\n      if (error || !data) {\n        return {\n          tier: 'none',\n          avgBalance7d: 0,\n          streakDays: 0,\n          nextTierThreshold: 50,\n          xpPerDay: 0\n        };\n      }\n\n      const tier = (data.balance_momentum_tier || 'none') as 'none' | 'bronze' | 'silver' | 'gold';\n      const avgBalance = Number(data.avg_balance_7d) || 0;\n      \n      // Calculate next tier threshold\n      let nextTierThreshold: number | undefined;\n      if (avgBalance < 50) nextTierThreshold = 50;\n      else if (avgBalance < 200) nextTierThreshold = 200;\n      else if (avgBalance < 500) nextTierThreshold = 500;\n\n      // XP per day based on tier\n      const xpPerDay = tier === 'gold' ? 50 : tier === 'silver' ? 25 : tier === 'bronze' ? 10 : 0;\n\n      return {\n        tier,\n        avgBalance7d: avgBalance,\n        streakDays: data.balance_streak_days || 0,\n        nextTierThreshold,\n        xpPerDay\n      };\n    } catch (error) {\n      console.log('Balance Momentum: Could not fetch status');\n      return {\n        tier: 'none',\n        avgBalance7d: 0,\n        streakDays: 0,\n        nextTierThreshold: 50,\n        xpPerDay: 0\n      };\n    }\n  }\n\n  /**\n   * Get Balance Momentum tier info for display\n   */\n  static getMomentumTierInfo(tier: string): {\n    name: string;\n    color: string;\n    icon: string;\n    minBalance: number;\n    xpPerDay: number;\n  } {\n    switch (tier) {\n      case 'gold':\n        return { name: 'Gold', color: '#FFD700', icon: 'award', minBalance: 500, xpPerDay: 50 };\n      case 'silver':\n        return { name: 'Silver', color: '#C0C0C0', icon: 'star', minBalance: 200, xpPerDay: 25 };\n      case 'bronze':\n        return { name: 'Bronze', color: '#CD7F32', icon: 'zap', minBalance: 50, xpPerDay: 10 };\n      default:\n        return { name: 'None', color: '#808080', icon: 'circle', minBalance: 0, xpPerDay: 0 };\n    }\n  }\n\n  // ========== ANTI-ABUSE PROTECTION ==========\n\n  /**\n   * Check if split amount meets minimum threshold for XP\n   * Prevents micro-split farming\n   */\n  static isAmountEligibleForXP(amount: number): boolean {\n    return amount >= ANTI_ABUSE_LIMITS.MIN_SPLIT_AMOUNT_FOR_XP;\n  }\n\n  /**\n   * Get today's XP earned from splits for a user\n   * Used to enforce daily XP cap\n   */\n  static async getDailyXPFromSplits(userId: string): Promise<number> {\n    try {\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n\n      const { data, error } = await supabase\n        .from('xp_history')\n        .select('xp_amount')\n        .eq('user_id', userId)\n        .in('action_type', ['split_created', 'split_paid', 'split_completed'])\n        .gte('created_at', today.toISOString());\n\n      if (error || !data) return 0;\n      return data.reduce((sum, item) => sum + (item.xp_amount || 0), 0);\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Check if user has hit daily XP cap\n   */\n  static async hasHitDailyXPCap(userId: string): Promise<boolean> {\n    const dailyXP = await this.getDailyXPFromSplits(userId);\n    return dailyXP >= ANTI_ABUSE_LIMITS.DAILY_SPLIT_XP_CAP;\n  }\n\n  /**\n   * Get count of splits created/paid with a specific friend today\n   */\n  static async getSplitsWithFriendToday(userId: string, friendId: string): Promise<number> {\n    try {\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n\n      // Check XP history for today's splits involving this friend pair\n      const { count, error } = await supabase\n        .from('xp_history')\n        .select('*', { count: 'exact', head: true })\n        .eq('user_id', userId)\n        .in('action_type', ['split_created', 'split_paid'])\n        .gte('created_at', today.toISOString())\n        .ilike('description', `%${friendId.substring(0, 8)}%`);\n\n      if (error) return 0;\n      return count || 0;\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Validate XP eligibility with anti-abuse checks\n   * Returns { eligible: boolean, reason?: string }\n   */\n  static async validateXPEligibility(\n    userId: string,\n    amount: number,\n    actionType: 'split_created' | 'split_paid'\n  ): Promise<{ eligible: boolean; reason?: string; xpMultiplier?: number }> {\n    // Check minimum amount\n    if (!this.isAmountEligibleForXP(amount)) {\n      return { \n        eligible: false, \n        reason: `Minimum $${ANTI_ABUSE_LIMITS.MIN_SPLIT_AMOUNT_FOR_XP} required for XP` \n      };\n    }\n\n    // Check daily XP cap\n    if (await this.hasHitDailyXPCap(userId)) {\n      return { \n        eligible: false, \n        reason: 'Daily XP limit reached. Keep splitting tomorrow!' \n      };\n    }\n\n    return { eligible: true, xpMultiplier: 1.0 };\n  }\n\n  /**\n   * Log suspicious activity for admin review\n   */\n  static async logSuspiciousActivity(\n    userId: string,\n    activityType: string,\n    details: string\n  ): Promise<void> {\n    try {\n      await supabase.from('admin_audit_log').insert({\n        action_type: 'suspicious_xp_activity',\n        admin_user_id: null,\n        target_user_id: userId,\n        details: JSON.stringify({ activityType, details, timestamp: new Date().toISOString() })\n      });\n      console.log(`[Anti-Abuse] Logged suspicious activity for user ${userId}: ${activityType}`);\n    } catch {\n      console.log('[Anti-Abuse] Failed to log suspicious activity');\n    }\n  }\n\n  /**\n   * Check for perk eligibility (vouchers, rewards)\n   * Perks require manual admin approval to prevent abuse\n   */\n  static async checkPerkEligibility(userId: string, level: number): Promise<{\n    eligible: boolean;\n    perk?: string;\n    requiresApproval: boolean;\n  }> {\n    const levelInfo = LEVEL_INFO[level];\n    if (!levelInfo?.perk) {\n      return { eligible: false, requiresApproval: false };\n    }\n\n    // Voucher perks require admin approval\n    const isVoucherPerk = levelInfo.perk.includes('Voucher') || levelInfo.perk.includes('$');\n    \n    return {\n      eligible: true,\n      perk: levelInfo.perk,\n      requiresApproval: isVoucherPerk\n    };\n  }\n}\n","path":null,"size_bytes":33457,"size_tokens":null},"components/LevelUpModal.tsx":{"content":"import React, { useEffect } from 'react';\nimport { View, StyleSheet, Modal, Pressable, Dimensions } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withSpring,\n  withSequence,\n  withDelay,\n  withTiming,\n  runOnJS,\n  Easing,\n  interpolate,\n} from 'react-native-reanimated';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from './ThemedText';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { GamificationService, LEVEL_INFO } from '@/services/gamification.service';\nimport * as Haptics from 'expo-haptics';\nimport { Platform } from 'react-native';\n\ninterface LevelUpModalProps {\n  visible: boolean;\n  newLevel: number;\n  oldLevel: number;\n  newTitle: string;\n  totalXp: number;\n  onDismiss: () => void;\n}\n\nconst { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');\n\nconst CONFETTI_COLORS = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];\n\ninterface ConfettiPiece {\n  x: number;\n  delay: number;\n  color: string;\n  rotation: number;\n  size: number;\n}\n\nfunction ConfettiParticle({ piece }: { piece: ConfettiPiece }) {\n  const progress = useSharedValue(0);\n\n  useEffect(() => {\n    progress.value = withDelay(\n      piece.delay,\n      withTiming(1, { duration: 2500, easing: Easing.out(Easing.quad) })\n    );\n  }, []);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: [\n        { translateX: piece.x },\n        { translateY: interpolate(progress.value, [0, 1], [-20, SCREEN_HEIGHT * 0.8]) },\n        { rotate: `${interpolate(progress.value, [0, 1], [0, piece.rotation])}deg` },\n        { scale: interpolate(progress.value, [0, 0.2, 1], [0, 1, 0.5]) },\n      ],\n      opacity: interpolate(progress.value, [0, 0.1, 0.8, 1], [0, 1, 1, 0]),\n    };\n  });\n\n  return (\n    <Animated.View\n      style={[\n        styles.confetti,\n        { backgroundColor: piece.color, width: piece.size, height: piece.size * 1.5 },\n        animatedStyle,\n      ]}\n    />\n  );\n}\n\nexport function LevelUpModal({ visible, newLevel, oldLevel, newTitle, totalXp, onDismiss }: LevelUpModalProps) {\n  const { theme: colors } = useTheme();\n  const scale = useSharedValue(0);\n  const starScale = useSharedValue(0);\n  const badgeRotation = useSharedValue(0);\n  const glowOpacity = useSharedValue(0);\n  const buttonScale = useSharedValue(0);\n\n  const levelColor = GamificationService.getLevelColor(newLevel);\n  const levelInfo = LEVEL_INFO[newLevel] || { title: newTitle };\n  const hasPerk = levelInfo.perk;\n\n  const confettiPieces: ConfettiPiece[] = Array.from({ length: 30 }, (_, i) => ({\n    x: Math.random() * SCREEN_WIDTH - SCREEN_WIDTH / 2,\n    delay: Math.random() * 500,\n    color: CONFETTI_COLORS[i % CONFETTI_COLORS.length],\n    rotation: 360 * (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 2 + 1),\n    size: 8 + Math.random() * 8,\n  }));\n\n  useEffect(() => {\n    if (visible) {\n      if (Platform.OS !== 'web') {\n        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      }\n\n      scale.value = withSpring(1, { damping: 8, stiffness: 100 });\n      \n      starScale.value = withDelay(\n        300,\n        withSequence(\n          withSpring(1.3, { damping: 5 }),\n          withSpring(1, { damping: 8 })\n        )\n      );\n\n      badgeRotation.value = withDelay(\n        200,\n        withSequence(\n          withTiming(-10, { duration: 100 }),\n          withTiming(10, { duration: 100 }),\n          withTiming(-5, { duration: 100 }),\n          withTiming(5, { duration: 100 }),\n          withTiming(0, { duration: 100 })\n        )\n      );\n\n      glowOpacity.value = withDelay(\n        400,\n        withSequence(\n          withTiming(0.8, { duration: 300 }),\n          withTiming(0.3, { duration: 500 }),\n          withTiming(0.6, { duration: 400 })\n        )\n      );\n\n      buttonScale.value = withDelay(800, withSpring(1, { damping: 10 }));\n    } else {\n      scale.value = 0;\n      starScale.value = 0;\n      badgeRotation.value = 0;\n      glowOpacity.value = 0;\n      buttonScale.value = 0;\n    }\n  }, [visible]);\n\n  const containerStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n    opacity: scale.value,\n  }));\n\n  const starStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: starScale.value }],\n  }));\n\n  const badgeStyle = useAnimatedStyle(() => ({\n    transform: [{ rotate: `${badgeRotation.value}deg` }],\n  }));\n\n  const glowStyle = useAnimatedStyle(() => ({\n    opacity: glowOpacity.value,\n  }));\n\n  const buttonAnimStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: buttonScale.value }],\n    opacity: buttonScale.value,\n  }));\n\n  const handleDismiss = () => {\n    if (Platform.OS !== 'web') {\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    }\n    onDismiss();\n  };\n\n  return (\n    <Modal visible={visible} transparent animationType=\"fade\" statusBarTranslucent>\n      <View style={[styles.overlay, { backgroundColor: 'rgba(0,0,0,0.85)' }]}>\n        {visible ? confettiPieces.map((piece, index) => (\n          <ConfettiParticle key={index} piece={piece} />\n        )) : null}\n\n        <Animated.View style={[styles.content, containerStyle]}>\n          <Animated.View style={[styles.glow, { backgroundColor: levelColor }, glowStyle]} />\n          \n          <Animated.View style={[styles.starContainer, starStyle]}>\n            <View style={[styles.levelBadge, { backgroundColor: levelColor }]}>\n              <Animated.View style={badgeStyle}>\n                <Feather name=\"star\" size={48} color=\"#FFFFFF\" />\n              </Animated.View>\n            </View>\n          </Animated.View>\n\n          <ThemedText style={styles.levelUpText}>LEVEL UP!</ThemedText>\n\n          <View style={styles.levelRow}>\n            <ThemedText style={[styles.oldLevel, { color: colors.textSecondary }]}>\n              Lv.{oldLevel}\n            </ThemedText>\n            <Feather name=\"arrow-right\" size={24} color={levelColor} style={{ marginHorizontal: Spacing.md }} />\n            <ThemedText style={[styles.newLevel, { color: levelColor }]}>\n              Lv.{newLevel}\n            </ThemedText>\n          </View>\n\n          <ThemedText style={[styles.title, { color: colors.text }]}>\n            {newTitle}\n          </ThemedText>\n\n          <ThemedText style={[styles.xpText, { color: colors.textSecondary }]}>\n            Total XP: {totalXp.toLocaleString()}\n          </ThemedText>\n\n          {hasPerk ? (\n            <View style={[styles.perkContainer, { backgroundColor: `${levelColor}20`, borderColor: levelColor }]}>\n              <Feather name=\"gift\" size={20} color={levelColor} />\n              <View style={styles.perkTextContainer}>\n                <ThemedText style={[styles.perkLabel, { color: levelColor }]}>\n                  New Perk Unlocked!\n                </ThemedText>\n                <ThemedText style={[styles.perkText, { color: colors.text }]}>\n                  {levelInfo.perk}\n                </ThemedText>\n              </View>\n            </View>\n          ) : null}\n\n          <Animated.View style={buttonAnimStyle}>\n            <Pressable\n              style={({ pressed }) => [\n                styles.button,\n                { backgroundColor: levelColor, opacity: pressed ? 0.8 : 1 },\n              ]}\n              onPress={handleDismiss}\n            >\n              <ThemedText style={styles.buttonText}>Awesome!</ThemedText>\n            </Pressable>\n          </Animated.View>\n        </Animated.View>\n      </View>\n    </Modal>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: Spacing.xl,\n  },\n  content: {\n    backgroundColor: '#1A1A2E',\n    borderRadius: BorderRadius.lg,\n    padding: Spacing['2xl'],\n    alignItems: 'center',\n    width: '100%',\n    maxWidth: 340,\n    position: 'relative',\n    overflow: 'hidden',\n  },\n  glow: {\n    position: 'absolute',\n    top: -50,\n    left: -50,\n    right: -50,\n    height: 150,\n    borderRadius: 100,\n  },\n  starContainer: {\n    marginBottom: Spacing.lg,\n  },\n  levelBadge: {\n    width: 100,\n    height: 100,\n    borderRadius: 50,\n    justifyContent: 'center',\n    alignItems: 'center',\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 4 },\n    shadowOpacity: 0.3,\n    shadowRadius: 8,\n    elevation: 8,\n  },\n  levelUpText: {\n    fontSize: 32,\n    fontWeight: '900',\n    color: '#FFD700',\n    letterSpacing: 4,\n    marginBottom: Spacing.md,\n    textShadowColor: 'rgba(255, 215, 0, 0.5)',\n    textShadowOffset: { width: 0, height: 2 },\n    textShadowRadius: 10,\n  },\n  levelRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginBottom: Spacing.md,\n  },\n  oldLevel: {\n    fontSize: 24,\n    fontWeight: '700',\n  },\n  newLevel: {\n    fontSize: 32,\n    fontWeight: '900',\n  },\n  title: {\n    fontSize: 22,\n    fontWeight: '700',\n    marginBottom: Spacing.sm,\n    textAlign: 'center',\n  },\n  xpText: {\n    fontSize: 14,\n    marginBottom: Spacing.lg,\n  },\n  perkContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    marginBottom: Spacing.xl,\n    width: '100%',\n  },\n  perkTextContainer: {\n    marginLeft: Spacing.md,\n    flex: 1,\n  },\n  perkLabel: {\n    fontSize: 12,\n    fontWeight: '700',\n    textTransform: 'uppercase',\n    letterSpacing: 1,\n  },\n  perkText: {\n    fontSize: 14,\n    fontWeight: '500',\n    marginTop: 2,\n  },\n  button: {\n    paddingHorizontal: Spacing['2xl'],\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    minWidth: 160,\n    alignItems: 'center',\n  },\n  buttonText: {\n    color: '#FFFFFF',\n    fontSize: 18,\n    fontWeight: '700',\n  },\n  confetti: {\n    position: 'absolute',\n    top: 0,\n    borderRadius: 2,\n  },\n});\n","path":null,"size_bytes":9828,"size_tokens":null},"contexts/LevelUpContext.tsx":{"content":"import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';\nimport { LevelUpModal } from '@/components/LevelUpModal';\nimport { XPAwardResult } from '@/services/gamification.service';\n\ninterface LevelUpState {\n  visible: boolean;\n  newLevel: number;\n  oldLevel: number;\n  newTitle: string;\n  totalXp: number;\n}\n\ninterface LevelUpContextValue {\n  showLevelUp: (result: XPAwardResult) => void;\n  checkLevelUp: (result: XPAwardResult) => void;\n  xpRefreshTrigger: number;\n  triggerXPRefresh: () => void;\n}\n\nconst LevelUpContext = createContext<LevelUpContextValue | null>(null);\n\nexport function LevelUpProvider({ children }: { children: ReactNode }) {\n  const [state, setState] = useState<LevelUpState>({\n    visible: false,\n    newLevel: 1,\n    oldLevel: 1,\n    newTitle: 'Member',\n    totalXp: 0,\n  });\n  const [xpRefreshTrigger, setXpRefreshTrigger] = useState(0);\n\n  const triggerXPRefresh = useCallback(() => {\n    setXpRefreshTrigger(prev => prev + 1);\n  }, []);\n\n  const showLevelUp = useCallback((result: XPAwardResult) => {\n    setState({\n      visible: true,\n      newLevel: result.new_level,\n      oldLevel: result.old_level,\n      newTitle: result.new_title,\n      totalXp: result.new_total_xp,\n    });\n    triggerXPRefresh();\n  }, [triggerXPRefresh]);\n\n  const checkLevelUp = useCallback((result: XPAwardResult) => {\n    if (result.leveled_up) {\n      showLevelUp(result);\n    } else if (result.xp_awarded > 0) {\n      triggerXPRefresh();\n    }\n  }, [showLevelUp, triggerXPRefresh]);\n\n  const handleDismiss = useCallback(() => {\n    setState(prev => ({ ...prev, visible: false }));\n  }, []);\n\n  return (\n    <LevelUpContext.Provider value={{ showLevelUp, checkLevelUp, xpRefreshTrigger, triggerXPRefresh }}>\n      {children}\n      <LevelUpModal\n        visible={state.visible}\n        newLevel={state.newLevel}\n        oldLevel={state.oldLevel}\n        newTitle={state.newTitle}\n        totalXp={state.totalXp}\n        onDismiss={handleDismiss}\n      />\n    </LevelUpContext.Provider>\n  );\n}\n\nexport function useLevelUp() {\n  const context = useContext(LevelUpContext);\n  if (!context) {\n    throw new Error('useLevelUp must be used within a LevelUpProvider');\n  }\n  return context;\n}\n","path":null,"size_bytes":2227,"size_tokens":null},"server/routes/gamification.routes.ts":{"content":"import express from 'express';\nimport { createClient } from '@supabase/supabase-js';\nimport { sendVoucherClaimNotification, sendSuspiciousActivityNotification } from '../services/email.service';\n\nconst router = express.Router();\n\nconst supabaseUrl = 'https://vhicohutiocnfjwsofhy.supabase.co';\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n\ninterface AuthenticatedRequest extends express.Request {\n  user?: { id: string; email: string };\n}\n\nasync function verifyUserToken(token: string): Promise<{ id: string; email: string } | null> {\n  try {\n    const supabase = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n    \n    const { data, error } = await supabase.auth.getUser(token);\n    \n    if (error || !data.user) {\n      return null;\n    }\n    \n    return { id: data.user.id, email: data.user.email || '' };\n  } catch (err) {\n    console.error('Token verification error:', err);\n    return null;\n  }\n}\n\nconst userAuthMiddleware = async (req: AuthenticatedRequest, res: express.Response, next: express.NextFunction) => {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader?.startsWith('Bearer ')) {\n    return res.status(401).json({ error: 'No authorization token provided' });\n  }\n  \n  const token = authHeader.split(' ')[1];\n  const user = await verifyUserToken(token);\n  \n  if (!user) {\n    return res.status(401).json({ error: 'Invalid or expired token' });\n  }\n  \n  req.user = user;\n  next();\n};\n\nconst VOUCHER_REQUIREMENTS: Record<string, { requiredLevel: number; value: string }> = {\n  dinner_voucher: { requiredLevel: 10, value: '$50 Dinner Voucher' },\n};\n\nrouter.post('/claim-voucher', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const userId = req.user!.id;\n    const { voucherType } = req.body;\n\n    if (!voucherType) {\n      return res.status(400).json({ error: 'Missing voucher type' });\n    }\n\n    const voucherConfig = VOUCHER_REQUIREMENTS[voucherType];\n    if (!voucherConfig) {\n      return res.status(400).json({ error: 'Invalid voucher type' });\n    }\n\n    const supabase = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    const { data: userData, error: userError } = await supabase\n      .from('users')\n      .select('first_name, last_name, email, phone')\n      .eq('id', userId)\n      .single();\n\n    if (userError || !userData) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n\n    const { data: gamProfile, error: gamError } = await supabase\n      .from('user_gamification')\n      .select('level')\n      .eq('user_id', userId)\n      .single();\n\n    if (gamError || !gamProfile) {\n      return res.status(404).json({ error: 'Gamification profile not found' });\n    }\n\n    if (gamProfile.level < voucherConfig.requiredLevel) {\n      return res.status(403).json({ error: `Level ${voucherConfig.requiredLevel} required to claim this voucher` });\n    }\n\n    const { data: existingClaim, error: claimCheckError } = await supabase\n      .from('voucher_claims')\n      .select('id')\n      .eq('user_id', userId)\n      .eq('voucher_type', voucherType)\n      .maybeSingle();\n\n    if (existingClaim) {\n      return res.status(400).json({ error: 'You have already claimed this voucher' });\n    }\n\n    const claimedAt = new Date().toLocaleString('en-NZ', { timeZone: 'Pacific/Auckland' });\n\n    const { error: insertError } = await supabase\n      .from('voucher_claims')\n      .insert({\n        user_id: userId,\n        voucher_type: voucherType,\n        voucher_value: voucherConfig.value,\n        level_required: voucherConfig.requiredLevel,\n        status: 'pending'\n      });\n\n    if (insertError) {\n      if (insertError.code === '42P01') {\n        console.log('voucher_claims table does not exist yet, skipping insert');\n      } else {\n        console.error('Error inserting voucher claim:', insertError);\n      }\n    }\n\n    await sendVoucherClaimNotification({\n      userId,\n      userName: `${userData.first_name} ${userData.last_name}`,\n      userEmail: userData.email,\n      userPhone: userData.phone || 'Not provided',\n      level: gamProfile.level,\n      voucherType,\n      voucherValue: voucherConfig.value,\n      claimedAt\n    });\n\n    res.json({ \n      success: true, \n      message: 'Voucher claimed successfully. Our team will be in touch soon!' \n    });\n\n  } catch (error: any) {\n    console.error('Voucher claim error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nrouter.post('/report-suspicious', userAuthMiddleware, async (req: AuthenticatedRequest, res) => {\n  try {\n    const { userId, activityType, details } = req.body;\n\n    const supabase = createClient(supabaseUrl, supabaseServiceKey || '', {\n      db: { schema: 'public' },\n      auth: { autoRefreshToken: false, persistSession: false }\n    });\n\n    const { data: userData, error: userError } = await supabase\n      .from('users')\n      .select('first_name, last_name, email')\n      .eq('id', userId)\n      .maybeSingle();\n\n    const timestamp = new Date().toLocaleString('en-NZ', { timeZone: 'Pacific/Auckland' });\n\n    await sendSuspiciousActivityNotification({\n      userId,\n      userName: userData ? `${userData.first_name} ${userData.last_name}` : 'Unknown',\n      userEmail: userData?.email || 'Unknown',\n      activityType,\n      details,\n      timestamp\n    });\n\n    res.json({ success: true });\n\n  } catch (error: any) {\n    console.error('Suspicious activity report error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\nexport default router;\n","path":null,"size_bytes":5708,"size_tokens":null},"components/FriendProfileModal.tsx":{"content":"import React, { useEffect, useState } from 'react';\nimport { View, StyleSheet, Modal, Pressable, Image, ActivityIndicator, Platform, Dimensions, Alert, TextInput, ScrollView, KeyboardAvoidingView } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n  Easing,\n} from 'react-native-reanimated';\nimport { Feather } from '@expo/vector-icons';\nimport * as Clipboard from 'expo-clipboard';\nimport * as Haptics from 'expo-haptics';\nimport { ThemedText } from './ThemedText';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\nimport { GamificationService, GamificationProfile, LEVEL_INFO } from '@/services/gamification.service';\nimport { FriendsService } from '@/services/friends.service';\nimport { LevelBadge } from './ProfileStatsCard';\n\ninterface FriendProfileModalProps {\n  visible: boolean;\n  onClose: () => void;\n  friend: {\n    id: string;\n    name: string;\n    unique_id?: string;\n    profile_picture_url?: string;\n  } | null;\n  userId?: string;\n  onBlock?: () => void;\n}\n\nconst TIER_COLORS = {\n  bronze: '#CD7F32',\n  silver: '#C0C0C0',\n  gold: '#FFD700',\n  platinum: '#E5E4E2',\n};\n\nconst REPORT_REASONS = [\n  { id: 'spam', label: 'Spam or scam' },\n  { id: 'harassment', label: 'Harassment or bullying' },\n  { id: 'inappropriate', label: 'Inappropriate content' },\n  { id: 'fraud', label: 'Fraud or financial abuse' },\n  { id: 'other', label: 'Other' },\n];\n\nconst { width: SCREEN_WIDTH } = Dimensions.get('window');\nconst MODAL_WIDTH = Math.min(SCREEN_WIDTH - 48, 380);\n\nexport function FriendProfileModal({ visible, onClose, friend, userId, onBlock }: FriendProfileModalProps) {\n  const { theme: colors, isDark } = useTheme();\n  const [profile, setProfile] = useState<GamificationProfile | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [copied, setCopied] = useState(false);\n  const [showingReportView, setShowingReportView] = useState(false);\n  const [selectedReason, setSelectedReason] = useState<string | null>(null);\n  const [customReason, setCustomReason] = useState('');\n  const [submitting, setSubmitting] = useState(false);\n\n  const scale = useSharedValue(0.85);\n  const opacity = useSharedValue(0);\n\n  useEffect(() => {\n    if (visible && friend?.id) {\n      loadFriendProfile();\n      scale.value = withTiming(1, { \n        duration: 250, \n        easing: Easing.out(Easing.cubic) \n      });\n      opacity.value = withTiming(1, { duration: 200 });\n    } else {\n      scale.value = withTiming(0.85, { duration: 150 });\n      opacity.value = withTiming(0, { duration: 150 });\n      setProfile(null);\n      setSelectedReason(null);\n      setCustomReason('');\n      setShowingReportView(false);\n    }\n  }, [visible, friend?.id]);\n\n  const loadFriendProfile = async () => {\n    if (!friend?.id) return;\n    \n    setLoading(true);\n    try {\n      const data = await GamificationService.getProfile(friend.id);\n      setProfile(data);\n    } catch (error) {\n      console.error('Failed to load friend profile:', error);\n      setProfile(GamificationService.getDefaultProfile());\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleCopyId = async () => {\n    if (!friend?.unique_id) return;\n    \n    if (Platform.OS !== 'web') {\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    }\n    \n    await Clipboard.setStringAsync(friend.unique_id);\n    setCopied(true);\n    setTimeout(() => setCopied(false), 2000);\n  };\n\n  const handleBlock = () => {\n    if (!userId || !friend) return;\n    \n    const friendName = friend.name;\n    const friendId = friend.id;\n    \n    Alert.alert(\n      'Block User',\n      `Are you sure you want to block ${friendName}? They won't be able to send you friend requests or include you in splits.`,\n      [\n        { text: 'Cancel', style: 'cancel' },\n        {\n          text: 'Block',\n          style: 'destructive',\n          onPress: async () => {\n            try {\n              setSubmitting(true);\n              await FriendsService.blockUser(userId, friendId);\n              setSubmitting(false);\n              \n              if (Platform.OS !== 'web') {\n                Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n              }\n              \n              onClose();\n              onBlock?.();\n              \n              setTimeout(() => {\n                Alert.alert('User Blocked', `${friendName} has been blocked`);\n              }, 100);\n            } catch (error: any) {\n              setSubmitting(false);\n              Alert.alert('Error', error.message || 'Failed to block user');\n            }\n          },\n        },\n      ]\n    );\n  };\n\n  const handleReportPress = () => {\n    console.log('[FriendProfileModal] Report button pressed');\n    if (Platform.OS !== 'web') {\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n    }\n    // Switch to report view within the same modal\n    setShowingReportView(true);\n  };\n  \n  const handleBackToProfile = () => {\n    setShowingReportView(false);\n    setSelectedReason(null);\n    setCustomReason('');\n  };\n\n  const handleSubmitReport = async () => {\n    console.log('[FriendProfileModal] handleSubmitReport called', { userId, friendId: friend?.id, selectedReason });\n    if (!userId || !friend || !selectedReason) {\n      console.log('[FriendProfileModal] Missing required fields:', { userId: !!userId, friend: !!friend, selectedReason });\n      return;\n    }\n    \n    const friendId = friend.id;\n    const friendName = friend.name;\n    \n    let reason = selectedReason === 'other' \n      ? (customReason.trim() || 'Other reason not specified')\n      : REPORT_REASONS.find(r => r.id === selectedReason)?.label || selectedReason;\n    \n    if (reason.length < 10) {\n      reason = `${reason} - User reported`;\n    }\n    \n    console.log('[FriendProfileModal] Submitting report:', { userId, friendId, reason });\n    \n    try {\n      setSubmitting(true);\n      await FriendsService.reportUser(userId, friendId, reason);\n      console.log('[FriendProfileModal] Report submitted successfully');\n      if (Platform.OS !== 'web') {\n        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      }\n      setShowingReportView(false);\n      setSelectedReason(null);\n      setCustomReason('');\n      Alert.alert(\n        'Report Submitted',\n        'Thank you for your report. Our team will review it shortly.',\n        [{ text: 'OK', onPress: onClose }]\n      );\n    } catch (error: any) {\n      console.error('[FriendProfileModal] Report submission error:', error);\n      Alert.alert('Error', error.message || 'Failed to submit report');\n    } finally {\n      setSubmitting(false);\n    }\n  };\n\n  const containerStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n    opacity: opacity.value,\n  }));\n\n  const overlayStyle = useAnimatedStyle(() => ({\n    opacity: opacity.value,\n  }));\n\n  if (!friend) return null;\n\n  const levelColor = profile ? GamificationService.getLevelColor(profile.current_level) : colors.primary;\n  const levelInfo = profile ? LEVEL_INFO[profile.current_level] || LEVEL_INFO[1] : LEVEL_INFO[1];\n\n  return (\n    <>\n      <Modal visible={visible} transparent animationType=\"none\" statusBarTranslucent onRequestClose={onClose}>\n        <KeyboardAvoidingView \n          style={{ flex: 1 }} \n          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}\n          keyboardVerticalOffset={0}\n        >\n          <Pressable style={styles.overlay} onPress={onClose}>\n            <Animated.View style={[styles.overlayBg, overlayStyle]} />\n            \n            <Animated.View style={containerStyle}>\n              <Pressable \n                style={[styles.content, { backgroundColor: colors.surface, width: MODAL_WIDTH }]} \n                onPress={() => {}}\n              >\n                {showingReportView ? (\n                  <ScrollView \n                    showsVerticalScrollIndicator={false}\n                    keyboardShouldPersistTaps=\"handled\"\n                    contentContainerStyle={styles.reportScrollContent}\n                  >\n                    <Pressable \n                      style={[styles.closeButton, { backgroundColor: colors.backgroundSecondary }]} \n                      onPress={handleBackToProfile}\n                    >\n                      <Feather name=\"arrow-left\" size={20} color={colors.textSecondary} />\n                    </Pressable>\n\n                    <View style={styles.reportHeader}>\n                      <ThemedText style={[styles.reportTitle, { color: colors.text }]}>\n                        Report {friend.name}\n                      </ThemedText>\n                    </View>\n\n                    <ThemedText style={[styles.reportSubtitle, { color: colors.textSecondary }]}>\n                      Why are you reporting this user?\n                    </ThemedText>\n\n                    <View style={styles.reasonsList}>\n                      {REPORT_REASONS.map((reason) => (\n                        <Pressable\n                          key={reason.id}\n                          style={[\n                            styles.reasonItem,\n                            { \n                              backgroundColor: selectedReason === reason.id ? colors.primary + '15' : colors.backgroundSecondary,\n                              borderColor: selectedReason === reason.id ? colors.primary : colors.border,\n                            }\n                          ]}\n                          onPress={() => setSelectedReason(reason.id)}\n                        >\n                          <View style={[\n                            styles.radioButton,\n                            { borderColor: selectedReason === reason.id ? colors.primary : colors.textSecondary }\n                          ]}>\n                            {selectedReason === reason.id ? (\n                              <View style={[styles.radioButtonInner, { backgroundColor: colors.primary }]} />\n                            ) : null}\n                          </View>\n                          <ThemedText style={[styles.reasonText, { color: colors.text }]}>\n                            {reason.label}\n                          </ThemedText>\n                        </Pressable>\n                      ))}\n                    </View>\n\n                    {selectedReason === 'other' ? (\n                      <TextInput\n                        style={[\n                          styles.customReasonInput,\n                          { \n                            backgroundColor: colors.backgroundSecondary, \n                            color: colors.text,\n                            borderColor: colors.border,\n                          }\n                        ]}\n                        placeholder=\"Please describe the issue...\"\n                        placeholderTextColor={colors.textSecondary}\n                        value={customReason}\n                        onChangeText={setCustomReason}\n                        multiline\n                        numberOfLines={3}\n                        textAlignVertical=\"top\"\n                      />\n                    ) : null}\n\n                    <Pressable\n                      style={({ pressed }) => [\n                        styles.submitButton,\n                        { \n                          backgroundColor: selectedReason ? colors.primary : colors.backgroundSecondary,\n                          opacity: pressed && selectedReason ? 0.7 : 1 \n                        }\n                      ]}\n                      onPress={handleSubmitReport}\n                      disabled={!selectedReason || submitting}\n                    >\n                      {submitting ? (\n                        <ActivityIndicator size=\"small\" color=\"#FFFFFF\" />\n                      ) : (\n                        <ThemedText style={[\n                          styles.submitButtonText, \n                          { color: selectedReason ? '#FFFFFF' : colors.textSecondary }\n                        ]}>\n                          Submit Report\n                        </ThemedText>\n                      )}\n                    </Pressable>\n                  </ScrollView>\n              ) : (\n                <>\n                  <Pressable style={[styles.closeButton, { backgroundColor: colors.backgroundSecondary }]} onPress={onClose}>\n                    <Feather name=\"x\" size={20} color={colors.textSecondary} />\n                  </Pressable>\n\n                  <View style={styles.profileHeader}>\n                    <View style={[styles.avatarContainer, { borderColor: levelColor }]}>\n                      {friend.profile_picture_url ? (\n                        <Image source={{ uri: friend.profile_picture_url }} style={styles.avatar} />\n                      ) : (\n                    <View style={[styles.avatarPlaceholder, { backgroundColor: levelColor + '20' }]}>\n                      <ThemedText style={[styles.avatarInitial, { color: levelColor }]}>\n                        {friend.name?.charAt(0)?.toUpperCase() || '?'}\n                      </ThemedText>\n                    </View>\n                  )}\n                </View>\n\n                <ThemedText style={[styles.name, { color: colors.text }]} numberOfLines={2}>\n                  {friend.name}\n                </ThemedText>\n                \n                {loading ? (\n                  <View style={styles.loadingContainer}>\n                    <ActivityIndicator size=\"small\" color={colors.primary} />\n                    <ThemedText style={[styles.loadingText, { color: colors.textSecondary }]}>\n                      Loading profile...\n                    </ThemedText>\n                  </View>\n                ) : profile ? (\n                  <>\n                    <View style={styles.levelContainer}>\n                      <LevelBadge level={profile.current_level} size=\"medium\" showTitle />\n                      <ThemedText style={[styles.levelSubtext, { color: colors.textSecondary }]}>\n                        {profile.total_xp.toLocaleString()} XP earned\n                      </ThemedText>\n                    </View>\n                  </>\n                ) : null}\n              </View>\n\n              {!loading && profile ? (\n                <>\n                  <View style={[styles.statsContainer, { backgroundColor: colors.backgroundSecondary }]}>\n                    <View style={styles.statItem}>\n                      <View style={[styles.statIconContainer, { backgroundColor: colors.primary + '15' }]}>\n                        <Feather name=\"layers\" size={18} color={colors.primary} />\n                      </View>\n                      <View style={styles.statTextContainer}>\n                        <ThemedText style={[styles.statValue, { color: colors.text }]}>\n                          {profile.splits_created}\n                        </ThemedText>\n                        <ThemedText style={[styles.statLabel, { color: colors.textSecondary }]}>\n                          Splits Created\n                        </ThemedText>\n                      </View>\n                    </View>\n\n                    <View style={[styles.statDivider, { backgroundColor: colors.border }]} />\n\n                    <View style={styles.statItem}>\n                      <View style={[styles.statIconContainer, { backgroundColor: colors.success + '15' }]}>\n                        <Feather name=\"check-circle\" size={18} color={colors.success} />\n                      </View>\n                      <View style={styles.statTextContainer}>\n                        <ThemedText style={[styles.statValue, { color: colors.text }]}>\n                          {profile.splits_paid_on_time || 0}\n                        </ThemedText>\n                        <ThemedText style={[styles.statLabel, { color: colors.textSecondary }]}>\n                          Splits Paid\n                        </ThemedText>\n                      </View>\n                    </View>\n\n                    <View style={[styles.statDivider, { backgroundColor: colors.border }]} />\n\n                    <View style={styles.statItem}>\n                      <View style={[styles.statIconContainer, { backgroundColor: colors.warning + '15' }]}>\n                        <Feather name=\"zap\" size={18} color={colors.warning} />\n                      </View>\n                      <View style={styles.statTextContainer}>\n                        <ThemedText style={[styles.statValue, { color: colors.text }]}>\n                          {profile.current_streak}\n                        </ThemedText>\n                        <ThemedText style={[styles.statLabel, { color: colors.textSecondary }]}>\n                          Day Streak\n                        </ThemedText>\n                      </View>\n                    </View>\n                  </View>\n\n                  {profile.badges.length > 0 ? (\n                    <View style={styles.badgesSection}>\n                      <ThemedText style={[styles.sectionTitle, { color: colors.textSecondary }]}>\n                        Badges Earned\n                      </ThemedText>\n                      <View style={styles.badgesRow}>\n                        {profile.badges.slice(0, 4).map((badge) => (\n                          <View\n                            key={badge.badge_id}\n                            style={[\n                              styles.badgeItem,\n                              { backgroundColor: TIER_COLORS[badge.badge_tier] + '20' },\n                            ]}\n                          >\n                            <Feather\n                              name={badge.badge_icon as any}\n                              size={20}\n                              color={TIER_COLORS[badge.badge_tier]}\n                            />\n                            <ThemedText \n                              style={[styles.badgeName, { color: TIER_COLORS[badge.badge_tier] }]}\n                              numberOfLines={1}\n                            >\n                              {badge.badge_id.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase()).split(' ').slice(0, 2).join(' ')}\n                            </ThemedText>\n                          </View>\n                        ))}\n                      </View>\n                    </View>\n                  ) : null}\n                </>\n              ) : null}\n\n              {friend.unique_id ? (\n                <Pressable \n                  style={[styles.idSection, { backgroundColor: colors.backgroundSecondary, borderColor: colors.border }]}\n                  onPress={handleCopyId}\n                >\n                  <View style={styles.idContent}>\n                    <ThemedText style={[styles.idLabel, { color: colors.textSecondary }]}>\n                      Spline ID\n                    </ThemedText>\n                    <ThemedText style={[styles.idValue, { color: colors.text }]}>\n                      {friend.unique_id}\n                    </ThemedText>\n                  </View>\n                  <View style={[styles.copyButton, { backgroundColor: copied ? colors.success + '20' : colors.primary + '15' }]}>\n                    <Feather \n                      name={copied ? 'check' : 'copy'} \n                      size={18} \n                      color={copied ? colors.success : colors.primary} \n                    />\n                  </View>\n                </Pressable>\n              ) : null}\n\n                  {userId ? (\n                    <View style={styles.actionButtons}>\n                      <Pressable\n                        style={({ pressed }) => [\n                          styles.actionButton,\n                          { backgroundColor: colors.backgroundSecondary, opacity: pressed ? 0.7 : 1 }\n                        ]}\n                        onPress={handleReportPress}\n                        disabled={submitting}\n                      >\n                        <Feather name=\"flag\" size={18} color={colors.warning} />\n                        <ThemedText style={[styles.actionButtonText, { color: colors.warning }]}>\n                          Report\n                        </ThemedText>\n                      </Pressable>\n                      \n                      <Pressable\n                        style={({ pressed }) => [\n                          styles.actionButton,\n                          { backgroundColor: colors.danger + '15', opacity: pressed ? 0.7 : 1 }\n                        ]}\n                        onPress={handleBlock}\n                        disabled={submitting}\n                      >\n                        <Feather name=\"slash\" size={18} color={colors.danger} />\n                        <ThemedText style={[styles.actionButtonText, { color: colors.danger }]}>\n                          Block\n                        </ThemedText>\n                      </Pressable>\n                    </View>\n                  ) : null}\n                </>\n              )}\n            </Pressable>\n          </Animated.View>\n          </Pressable>\n        </KeyboardAvoidingView>\n      </Modal>\n    </>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: Spacing.lg,\n  },\n  overlayBg: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: 'rgba(0, 0, 0, 0.65)',\n  },\n  content: {\n    borderRadius: BorderRadius.xl,\n    paddingTop: Spacing.xl + Spacing.md,\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n    position: 'relative',\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 10 },\n    shadowOpacity: 0.25,\n    shadowRadius: 20,\n    elevation: 10,\n  },\n  closeButton: {\n    position: 'absolute',\n    top: Spacing.md,\n    right: Spacing.md,\n    zIndex: 1,\n    width: 36,\n    height: 36,\n    borderRadius: 18,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  reportScrollContent: {\n    paddingTop: Spacing.xl,\n  },\n  profileHeader: {\n    alignItems: 'center',\n    marginBottom: Spacing.lg,\n  },\n  avatarContainer: {\n    width: 100,\n    height: 100,\n    borderRadius: 50,\n    borderWidth: 3,\n    overflow: 'hidden',\n    marginBottom: Spacing.lg,\n  },\n  avatar: {\n    width: '100%',\n    height: '100%',\n  },\n  avatarPlaceholder: {\n    width: '100%',\n    height: '100%',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  avatarInitial: {\n    fontSize: 40,\n    fontWeight: '700',\n  },\n  name: {\n    fontSize: 24,\n    fontWeight: '700',\n    marginBottom: Spacing.sm,\n    textAlign: 'center',\n    lineHeight: 30,\n  },\n  loadingContainer: {\n    alignItems: 'center',\n    paddingVertical: Spacing.lg,\n  },\n  loadingText: {\n    fontSize: 14,\n    marginTop: Spacing.sm,\n  },\n  levelContainer: {\n    alignItems: 'center',\n    marginTop: Spacing.xs,\n  },\n  levelSubtext: {\n    fontSize: 13,\n    marginTop: Spacing.sm,\n  },\n  statsContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    borderRadius: BorderRadius.lg,\n    paddingVertical: Spacing.lg,\n    paddingHorizontal: Spacing.md,\n    marginBottom: Spacing.lg,\n  },\n  statItem: {\n    flex: 1,\n    alignItems: 'center',\n  },\n  statIconContainer: {\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginBottom: Spacing.sm,\n  },\n  statTextContainer: {\n    alignItems: 'center',\n  },\n  statValue: {\n    fontSize: 20,\n    fontWeight: '700',\n    lineHeight: 24,\n  },\n  statLabel: {\n    fontSize: 12,\n    marginTop: 4,\n    textAlign: 'center',\n    lineHeight: 16,\n  },\n  statDivider: {\n    width: 1,\n    height: 50,\n    marginHorizontal: Spacing.xs,\n  },\n  badgesSection: {\n    marginBottom: Spacing.lg,\n  },\n  sectionTitle: {\n    fontSize: 13,\n    fontWeight: '600',\n    marginBottom: Spacing.md,\n    textTransform: 'uppercase',\n    letterSpacing: 1,\n  },\n  badgesRow: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: Spacing.sm,\n  },\n  badgeItem: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingVertical: Spacing.sm,\n    paddingHorizontal: Spacing.md,\n    borderRadius: BorderRadius.md,\n    gap: Spacing.xs,\n  },\n  badgeName: {\n    fontSize: 12,\n    fontWeight: '600',\n  },\n  idSection: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    borderRadius: BorderRadius.lg,\n    padding: Spacing.lg,\n    borderWidth: 1,\n  },\n  idContent: {\n    flex: 1,\n  },\n  idLabel: {\n    fontSize: 12,\n    fontWeight: '600',\n    textTransform: 'uppercase',\n    letterSpacing: 1,\n    marginBottom: 4,\n  },\n  idValue: {\n    fontSize: 18,\n    fontWeight: '700',\n    letterSpacing: 2,\n  },\n  copyButton: {\n    width: 44,\n    height: 44,\n    borderRadius: 22,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginLeft: Spacing.md,\n  },\n  actionButtons: {\n    flexDirection: 'row',\n    gap: Spacing.md,\n    marginTop: Spacing.lg,\n  },\n  actionButton: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.md,\n    gap: Spacing.sm,\n  },\n  actionButtonText: {\n    fontSize: 14,\n    fontWeight: '600',\n  },\n  reportContent: {\n    borderRadius: BorderRadius.xl,\n    padding: Spacing.xl,\n    position: 'relative',\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 10 },\n    shadowOpacity: 0.25,\n    shadowRadius: 20,\n    elevation: 10,\n    maxHeight: '80%',\n  },\n  reportHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    marginBottom: Spacing.md,\n  },\n  reportTitle: {\n    fontSize: 20,\n    fontWeight: '700',\n  },\n  reportSubtitle: {\n    fontSize: 14,\n    marginBottom: Spacing.lg,\n  },\n  reasonsList: {\n    gap: Spacing.sm,\n    marginBottom: Spacing.lg,\n  },\n  reasonItem: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    borderWidth: 1,\n    gap: Spacing.md,\n  },\n  radioButton: {\n    width: 22,\n    height: 22,\n    borderRadius: 11,\n    borderWidth: 2,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  radioButtonInner: {\n    width: 12,\n    height: 12,\n    borderRadius: 6,\n  },\n  reasonText: {\n    fontSize: 15,\n    flex: 1,\n  },\n  customReasonInput: {\n    borderWidth: 1,\n    borderRadius: BorderRadius.md,\n    padding: Spacing.lg,\n    fontSize: 15,\n    minHeight: 100,\n    marginBottom: Spacing.lg,\n  },\n  submitButton: {\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    alignItems: 'center',\n    justifyContent: 'center',\n    minHeight: 50,\n  },\n  submitButtonText: {\n    fontSize: 16,\n    fontWeight: '600',\n  },\n});\n","path":null,"size_bytes":26629,"size_tokens":null},"components/VoucherClaimModal.tsx":{"content":"import React, { useState } from 'react';\nimport { View, StyleSheet, Pressable, Modal, ActivityIndicator, Alert } from 'react-native';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from './ThemedText';\nimport { Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { useTheme } from '@/hooks/useTheme';\nimport { supabase } from '@/services/supabase';\n\ninterface VoucherClaimModalProps {\n  visible: boolean;\n  onClose: () => void;\n  userId: string;\n  voucherType: string;\n  voucherValue: string;\n  levelRequired: number;\n}\n\nexport function VoucherClaimModal({\n  visible,\n  onClose,\n  userId,\n  voucherType,\n  voucherValue,\n  levelRequired,\n}: VoucherClaimModalProps) {\n  const { theme: colors } = useTheme();\n  const [loading, setLoading] = useState(false);\n  const [claimed, setClaimed] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const handleClaimVoucher = async () => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const { data: { session } } = await supabase.auth.getSession();\n      \n      if (!session?.access_token) {\n        setError('Please log in to claim your voucher');\n        setLoading(false);\n        return;\n      }\n\n      const backendUrl = process.env.EXPO_PUBLIC_BACKEND_URL || 'https://splinepay.replit.app';\n      const response = await fetch(`${backendUrl}/api/gamification/claim-voucher`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session.access_token}`,\n        },\n        body: JSON.stringify({\n          voucherType,\n        }),\n      });\n\n      const result = await response.json();\n\n      if (!response.ok) {\n        setError(result.error || 'Failed to claim voucher');\n        setLoading(false);\n        return;\n      }\n\n      setClaimed(true);\n      setLoading(false);\n    } catch (err: any) {\n      console.error('Voucher claim error:', err);\n      setError('Something went wrong. Please try again.');\n      setLoading(false);\n    }\n  };\n\n  const handleClose = () => {\n    setClaimed(false);\n    setError(null);\n    onClose();\n  };\n\n  return (\n    <Modal\n      visible={visible}\n      transparent\n      animationType=\"fade\"\n      onRequestClose={handleClose}\n    >\n      <Pressable style={styles.overlay} onPress={handleClose}>\n        <Pressable style={[styles.content, { backgroundColor: colors.surface }]} onPress={() => {}}>\n          <View style={styles.header}>\n            <View style={[styles.iconContainer, { backgroundColor: colors.primary + '15' }]}>\n              <Feather name=\"gift\" size={28} color={colors.primary} />\n            </View>\n            <Pressable onPress={handleClose} style={styles.closeBtn}>\n              <Feather name=\"x\" size={22} color={colors.textSecondary} />\n            </Pressable>\n          </View>\n\n          {claimed ? (\n            <View style={styles.claimedContainer}>\n              <View style={[styles.successIcon, { backgroundColor: colors.success + '20' }]}>\n                <Feather name=\"check-circle\" size={32} color={colors.success} />\n              </View>\n              <ThemedText style={[styles.title, { color: colors.text }]}>\n                Voucher Claimed!\n              </ThemedText>\n              <ThemedText style={[styles.description, { color: colors.textSecondary }]}>\n                Our team will be in touch within 1-2 business days to arrange your {voucherValue} dining experience.\n              </ThemedText>\n              <ThemedText style={[styles.note, { color: colors.textSecondary }]}>\n                Please check your email for further instructions.\n              </ThemedText>\n              <Pressable\n                style={[styles.doneButton, { backgroundColor: colors.primary }]}\n                onPress={handleClose}\n              >\n                <ThemedText style={[styles.buttonText, { color: '#fff' }]}>Done</ThemedText>\n              </Pressable>\n            </View>\n          ) : (\n            <>\n              <ThemedText style={[styles.title, { color: colors.text }]}>\n                Claim Your {voucherValue}\n              </ThemedText>\n              <ThemedText style={[styles.subtitle, { color: colors.primary }]}>\n                Level {levelRequired} Perk\n              </ThemedText>\n              \n              <ThemedText style={[styles.description, { color: colors.textSecondary }]}>\n                Congratulations on reaching Level {levelRequired}! You've unlocked a {voucherValue} as a reward for your loyalty.\n              </ThemedText>\n\n              <View style={[styles.infoBox, { backgroundColor: colors.backgroundSecondary }]}>\n                <Feather name=\"info\" size={16} color={colors.textSecondary} />\n                <ThemedText style={[styles.infoText, { color: colors.textSecondary }]}>\n                  After claiming, our team will contact you to discuss your dining preferences and any dietary requirements.\n                </ThemedText>\n              </View>\n\n              {error ? (\n                <View style={[styles.errorBox, { backgroundColor: colors.danger + '15' }]}>\n                  <Feather name=\"alert-circle\" size={16} color={colors.danger} />\n                  <ThemedText style={[styles.errorText, { color: colors.danger }]}>\n                    {error}\n                  </ThemedText>\n                </View>\n              ) : null}\n\n              <View style={styles.buttonContainer}>\n                <Pressable\n                  style={[styles.cancelButton, { borderColor: colors.border }]}\n                  onPress={handleClose}\n                  disabled={loading}\n                >\n                  <ThemedText style={[styles.cancelButtonText, { color: colors.textSecondary }]}>\n                    Maybe Later\n                  </ThemedText>\n                </Pressable>\n                <Pressable\n                  style={[\n                    styles.claimButton, \n                    { backgroundColor: loading ? colors.textSecondary : colors.primary }\n                  ]}\n                  onPress={handleClaimVoucher}\n                  disabled={loading}\n                >\n                  {loading ? (\n                    <ActivityIndicator size=\"small\" color=\"#fff\" />\n                  ) : (\n                    <>\n                      <Feather name=\"gift\" size={18} color=\"#fff\" />\n                      <ThemedText style={[styles.buttonText, { color: '#fff' }]}>\n                        Claim Voucher\n                      </ThemedText>\n                    </>\n                  )}\n                </Pressable>\n              </View>\n            </>\n          )}\n        </Pressable>\n      </Pressable>\n    </Modal>\n  );\n}\n\nconst styles = StyleSheet.create({\n  overlay: {\n    flex: 1,\n    backgroundColor: 'rgba(0,0,0,0.5)',\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: Spacing.xl,\n  },\n  content: {\n    width: '100%',\n    maxWidth: 360,\n    padding: Spacing.xl,\n    borderRadius: BorderRadius.lg,\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'flex-start',\n    marginBottom: Spacing.lg,\n  },\n  iconContainer: {\n    width: 56,\n    height: 56,\n    borderRadius: 28,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  closeBtn: {\n    padding: Spacing.xs,\n  },\n  title: {\n    fontSize: 22,\n    fontWeight: '700',\n    marginBottom: Spacing.xs,\n  },\n  subtitle: {\n    fontSize: 14,\n    fontWeight: '600',\n    marginBottom: Spacing.md,\n  },\n  description: {\n    fontSize: 15,\n    lineHeight: 22,\n    marginBottom: Spacing.lg,\n  },\n  infoBox: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.sm,\n    marginBottom: Spacing.lg,\n  },\n  infoText: {\n    fontSize: 13,\n    lineHeight: 19,\n    flex: 1,\n  },\n  errorBox: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    padding: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.sm,\n    marginBottom: Spacing.lg,\n  },\n  errorText: {\n    fontSize: 13,\n    flex: 1,\n  },\n  buttonContainer: {\n    flexDirection: 'row',\n    gap: Spacing.md,\n  },\n  cancelButton: {\n    flex: 1,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n    alignItems: 'center',\n  },\n  cancelButtonText: {\n    fontSize: 15,\n    fontWeight: '500',\n  },\n  claimButton: {\n    flex: 1.5,\n    flexDirection: 'row',\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    alignItems: 'center',\n    justifyContent: 'center',\n    gap: Spacing.xs,\n  },\n  buttonText: {\n    fontSize: 15,\n    fontWeight: '600',\n  },\n  claimedContainer: {\n    alignItems: 'center',\n  },\n  successIcon: {\n    width: 64,\n    height: 64,\n    borderRadius: 32,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginBottom: Spacing.lg,\n  },\n  note: {\n    fontSize: 13,\n    fontStyle: 'italic',\n    marginBottom: Spacing.xl,\n    textAlign: 'center',\n  },\n  doneButton: {\n    width: '100%',\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.sm,\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":9092,"size_tokens":null},"screens/SocialSignupCompleteScreen.tsx":{"content":"import React, { useEffect } from 'react';\nimport { View, StyleSheet, Pressable } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport Animated, {\n  useSharedValue,\n  useAnimatedStyle,\n  withTiming,\n  withSpring,\n  withSequence,\n  withDelay,\n  interpolate,\n} from 'react-native-reanimated';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { useAuth } from '@/hooks/useAuth';\n\ntype Props = NativeStackScreenProps<any, 'SocialSignupComplete'>;\n\nexport default function SocialSignupCompleteScreen({ route }: Props) {\n  const { theme } = useTheme();\n  const insets = useSafeAreaInsets();\n  const { refreshUser } = useAuth();\n  const params = route.params as { \n    userId: string;\n    fullName?: string;\n    provider: 'apple' | 'google';\n  };\n\n  const checkmarkScale = useSharedValue(0);\n  const contentOpacity = useSharedValue(0);\n  const buttonOpacity = useSharedValue(0);\n\n  useEffect(() => {\n    checkmarkScale.value = withSequence(\n      withDelay(300, withSpring(1.2, { damping: 8, stiffness: 100 })),\n      withSpring(1, { damping: 12, stiffness: 200 })\n    );\n    \n    contentOpacity.value = withDelay(600, withTiming(1, { duration: 500 }));\n    buttonOpacity.value = withDelay(900, withTiming(1, { duration: 500 }));\n  }, []);\n\n  const checkmarkStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: checkmarkScale.value }],\n    opacity: interpolate(checkmarkScale.value, [0, 0.5, 1], [0, 1, 1]),\n  }));\n\n  const contentStyle = useAnimatedStyle(() => ({\n    opacity: contentOpacity.value,\n    transform: [{ translateY: interpolate(contentOpacity.value, [0, 1], [20, 0]) }],\n  }));\n\n  const buttonStyle = useAnimatedStyle(() => ({\n    opacity: buttonOpacity.value,\n  }));\n\n  const handleGetStarted = async () => {\n    await refreshUser();\n  };\n\n  const getWelcomeMessage = () => {\n    if (params.fullName) {\n      const firstName = params.fullName.split(' ')[0];\n      return `Welcome to Spline, ${firstName}!`;\n    }\n    return 'Welcome to Spline!';\n  };\n\n  const getProviderMessage = () => {\n    const provider = params.provider === 'apple' ? 'Apple' : 'Google';\n    return `You signed up with ${provider} and verified your phone number.`;\n  };\n\n  return (\n    <View style={[styles.container, { backgroundColor: theme.backgroundRoot }]}>\n      <View style={[styles.content, { paddingTop: insets.top + Spacing['2xl'] }]}>\n        <Animated.View style={[styles.checkmarkContainer, checkmarkStyle]}>\n          <View style={[styles.checkmarkCircle, { backgroundColor: Colors.light.success }]}>\n            <Feather name=\"check\" size={48} color=\"#FFFFFF\" />\n          </View>\n        </Animated.View>\n\n        <Animated.View style={[styles.textContainer, contentStyle]}>\n          <ThemedText style={[Typography.hero, { color: theme.text, textAlign: 'center', marginBottom: Spacing.md }]}>\n            {getWelcomeMessage()}\n          </ThemedText>\n          \n          <ThemedText style={[Typography.body, { color: theme.textSecondary, textAlign: 'center' }]}>\n            {getProviderMessage()}\n          </ThemedText>\n          \n          <ThemedText style={[Typography.body, { color: theme.textSecondary, textAlign: 'center', marginTop: Spacing.md }]}>\n            Your account is all set up and ready to go.\n          </ThemedText>\n        </Animated.View>\n      </View>\n\n      <Animated.View style={[styles.footer, { paddingBottom: insets.bottom + Spacing['2xl'] }, buttonStyle]}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { backgroundColor: theme.primary, opacity: pressed ? 0.8 : 1 }\n          ]}\n          onPress={handleGetStarted}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            Get Started\n          </ThemedText>\n        </Pressable>\n      </Animated.View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  checkmarkContainer: {\n    marginBottom: Spacing['2xl'],\n  },\n  checkmarkCircle: {\n    width: 100,\n    height: 100,\n    borderRadius: 50,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  textContainer: {\n    alignItems: 'center',\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":4760,"size_tokens":null},"screens/SocialSignupPhoneScreen.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, ActivityIndicator } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { TwilioService } from '@/services/twilio.service';\n\ntype Props = NativeStackScreenProps<any, 'SocialSignupPhone'>;\n\nexport default function SocialSignupPhoneScreen({ navigation, route }: Props) {\n  console.log('[SocialSignupPhoneScreen] Component function called - SCREEN IS RENDERING');\n  const { theme } = useTheme();\n  const { clearSignupOverlay } = useAuth();\n  const [phone, setPhone] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n  const params = route.params as { \n    userId: string;\n    email?: string;\n    fullName?: string;\n    provider: 'apple' | 'google';\n  };\n\n  // Clear the loading overlay once this screen mounts (navigation is complete)\n  useEffect(() => {\n    console.log('[SocialSignupPhoneScreen] Screen mounted, clearing overlay');\n    clearSignupOverlay();\n  }, []);\n\n  if (!params?.userId) {\n    return (\n      <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n        <ThemedView style={styles.content}>\n          <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.md }]}>\n            Something went wrong\n          </ThemedText>\n          <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n            We could not complete your sign-in. Please try again.\n          </ThemedText>\n        </ThemedView>\n      </ScreenKeyboardAwareScrollView>\n    );\n  }\n\n  const formatPhoneDisplay = (value: string) => {\n    const digits = value.replace(/\\D/g, '');\n    return digits;\n  };\n\n  const handlePhoneChange = (text: string) => {\n    const formatted = formatPhoneDisplay(text);\n    setPhone(formatted);\n    if (error) setError('');\n  };\n\n  const getFullPhoneNumber = () => {\n    const cleaned = phone.replace(/\\D/g, '');\n    if (cleaned.startsWith('0')) {\n      return '+64' + cleaned.substring(1);\n    }\n    return '+64' + cleaned;\n  };\n\n  const isValidPhone = () => {\n    const cleaned = phone.replace(/\\D/g, '');\n    return cleaned.length >= 8 && cleaned.length <= 11;\n  };\n\n  const handleContinue = async () => {\n    if (!isValidPhone()) {\n      setError('Please enter a valid phone number');\n      return;\n    }\n\n    const fullPhone = getFullPhoneNumber();\n    setLoading(true);\n    setError('');\n\n    try {\n      const result = await TwilioService.sendOTP(fullPhone);\n\n      if (result.success) {\n        navigation.navigate('SocialSignupPhoneOTP', { \n          ...params, \n          phone: fullPhone \n        });\n      } else {\n        setError(result.error || 'Failed to send verification code');\n      }\n    } catch (err: any) {\n      setError(err.message || 'Failed to send verification code');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const getWelcomeText = () => {\n    if (params.fullName) {\n      const firstName = params.fullName.split(' ')[0];\n      return `Welcome, ${firstName}!`;\n    }\n    return 'Almost there!';\n  };\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Phone Verification\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.md }]}>\n          {getWelcomeText()}\n        </ThemedText>\n\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing.xl }]}>\n          To complete your account, we need to verify your phone number via SMS\n        </ThemedText>\n\n        <View style={styles.phoneInputContainer}>\n          <View style={[styles.prefixContainer, { \n            backgroundColor: theme.surface, \n            borderColor: error ? Colors.light.danger : theme.border \n          }]}>\n            <ThemedText style={[Typography.body, { color: theme.text, fontWeight: '600' }]}>\n              +64\n            </ThemedText>\n          </View>\n          <TextInput\n            style={[styles.phoneInput, { \n              backgroundColor: theme.surface, \n              color: theme.text, \n              borderColor: error ? Colors.light.danger : theme.border \n            }]}\n            placeholder=\"21 123 4567\"\n            placeholderTextColor={theme.textSecondary}\n            value={phone}\n            onChangeText={handlePhoneChange}\n            keyboardType=\"phone-pad\"\n            autoFocus\n            maxLength={11}\n          />\n        </View>\n\n        {error ? (\n          <ThemedText style={[Typography.caption, { color: Colors.light.danger, marginTop: Spacing.sm }]}>\n            {error}\n          </ThemedText>\n        ) : null}\n\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginTop: Spacing.md }]}>\n          Standard SMS rates may apply\n        </ThemedText>\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed || loading ? 0.7 : (isValidPhone() ? 1 : 0.4)\n            }\n          ]}\n          onPress={handleContinue}\n          disabled={!isValidPhone() || loading}\n        >\n          {loading ? (\n            <ActivityIndicator color={Colors.light.buttonText} />\n          ) : (\n            <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n              Send Verification Code\n            </ThemedText>\n          )}\n        </Pressable>\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  phoneInputContainer: {\n    flexDirection: 'row',\n    gap: Spacing.sm,\n  },\n  prefixContainer: {\n    height: Spacing.inputHeight,\n    paddingHorizontal: Spacing.lg,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  phoneInput: {\n    flex: 1,\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    fontSize: 16,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":7011,"size_tokens":null},"services/socialAuth.service.ts":{"content":"import { Platform } from 'react-native';\nimport * as AppleAuthentication from 'expo-apple-authentication';\nimport * as WebBrowser from 'expo-web-browser';\nimport * as AuthSession from 'expo-auth-session';\nimport { supabase } from './supabase';\n\nWebBrowser.maybeCompleteAuthSession();\n\nexport interface SocialAuthResult {\n  success: boolean;\n  userId?: string;\n  email?: string;\n  fullName?: string;\n  needsPhoneVerification?: boolean;\n  needsDOB?: boolean;\n  needsProfileCompletion?: boolean;\n  needsName?: boolean;\n  existingPhone?: string;\n  error?: string;\n}\n\n// Generate a 6-7 digit unique ID\nconst generateUniqueId = (): string => {\n  // Generate 6 or 7 digit number (100000 to 9999999)\n  const min = 100000;\n  const max = 9999999;\n  return Math.floor(min + Math.random() * (max - min + 1)).toString();\n};\n\nexport const SocialAuthService = {\n  async signInWithApple(): Promise<SocialAuthResult> {\n    try {\n      if (Platform.OS !== 'ios') {\n        return { success: false, error: 'Apple Sign-In is only available on iOS' };\n      }\n\n      const isAvailable = await AppleAuthentication.isAvailableAsync();\n      if (!isAvailable) {\n        return { success: false, error: 'Apple Sign-In is not available on this device' };\n      }\n\n      console.log('[Apple Sign-In] Starting sign-in...');\n      const credential = await AppleAuthentication.signInAsync({\n        requestedScopes: [\n          AppleAuthentication.AppleAuthenticationScope.FULL_NAME,\n          AppleAuthentication.AppleAuthenticationScope.EMAIL,\n        ],\n      });\n\n      if (!credential.identityToken) {\n        return { success: false, error: 'No identity token received from Apple' };\n      }\n\n      console.log('[Apple Sign-In] Got credentials, authenticating with Supabase...');\n      const { data, error } = await supabase.auth.signInWithIdToken({\n        provider: 'apple',\n        token: credential.identityToken,\n      });\n\n      if (error) {\n        console.error('Supabase Apple auth error:', error);\n        return { success: false, error: error.message };\n      }\n\n      if (!data.user) {\n        return { success: false, error: 'No user returned from authentication' };\n      }\n\n      // Apple only provides name on first sign-in, so we capture it here\n      const fullName = credential.fullName\n        ? `${credential.fullName.givenName || ''} ${credential.fullName.familyName || ''}`.trim()\n        : undefined;\n\n      console.log('[Apple Sign-In] User authenticated:', data.user.id, 'Name:', fullName);\n      const result = await this.handleSocialAuthUser(data.user.id, data.user.email, fullName);\n      console.log('[Apple Sign-In] Result:', result);\n      return result;\n    } catch (error: any) {\n      if (error.code === 'ERR_REQUEST_CANCELED') {\n        return { success: false, error: 'Sign-in was cancelled' };\n      }\n      console.error('Apple Sign-In error:', error);\n      return { success: false, error: error.message || 'Apple Sign-In failed' };\n    }\n  },\n\n  async signInWithGoogle(): Promise<SocialAuthResult> {\n    try {\n      // For native iOS/Android, use the deep link scheme\n      // For web, use the standard redirect URI\n      const redirectUrl = Platform.OS === 'web' \n        ? AuthSession.makeRedirectUri({ scheme: 'splitpaymentapp', path: 'auth/callback' })\n        : 'splitpaymentapp://auth/callback';\n      \n      console.log('[Google Sign-In] Starting with redirect URL:', redirectUrl, 'Platform:', Platform.OS);\n      \n      // Start Supabase OAuth flow - let Supabase handle PKCE/state\n      const { data: oauthData, error: oauthError } = await supabase.auth.signInWithOAuth({\n        provider: 'google',\n        options: {\n          redirectTo: redirectUrl,\n          skipBrowserRedirect: true,\n          queryParams: {\n            prompt: 'select_account',\n          },\n        },\n      });\n\n      if (oauthError || !oauthData?.url) {\n        console.error('[Google Sign-In] OAuth init error:', oauthError);\n        return { success: false, error: oauthError?.message || 'Failed to start Google Sign-In' };\n      }\n\n      console.log('[Google Sign-In] Opening auth session...');\n      console.log('[Google Sign-In] OAuth URL:', oauthData.url);\n      \n      // Open the browser for OAuth - use showInRecents for better handling\n      const result = await WebBrowser.openAuthSessionAsync(\n        oauthData.url, \n        redirectUrl,\n        { showInRecents: true }\n      );\n\n      console.log('[Google Sign-In] Auth session result type:', result.type);\n\n      if (result.type !== 'success') {\n        if (result.type === 'cancel' || result.type === 'dismiss') {\n          return { success: false, error: 'Google Sign-In was cancelled' };\n        }\n        return { success: false, error: 'Google Sign-In failed. Please try again.' };\n      }\n\n      const url = result.url;\n      console.log('[Google Sign-In] Callback URL received:', url);\n      \n      // Parse both hash fragment and query params\n      // Supabase can return tokens in hash (implicit) or code in query (PKCE)\n      const urlObj = new URL(url);\n      const hashString = url.includes('#') ? url.split('#')[1] : '';\n      const hashParams = new URLSearchParams(hashString);\n      const queryParams = urlObj.searchParams;\n      \n      // Check for error in redirect\n      const errorCode = hashParams.get('error') || queryParams.get('error');\n      const errorDescription = hashParams.get('error_description') || queryParams.get('error_description');\n      \n      if (errorCode) {\n        console.error('[Google Sign-In] OAuth error:', errorCode, errorDescription);\n        return { success: false, error: errorDescription || errorCode };\n      }\n      \n      // Try to get tokens from hash fragment first (implicit flow)\n      const accessToken = hashParams.get('access_token');\n      const refreshToken = hashParams.get('refresh_token');\n      \n      if (accessToken && refreshToken) {\n        console.log('[Google Sign-In] Got tokens from hash fragment, setting session...');\n        const { data: sessionData, error: sessionError } = await supabase.auth.setSession({\n          access_token: accessToken,\n          refresh_token: refreshToken,\n        });\n\n        if (sessionError) {\n          console.error('[Google Sign-In] Session error:', sessionError);\n          return { success: false, error: sessionError.message };\n        }\n\n        if (!sessionData?.user) {\n          return { success: false, error: 'No user returned from authentication' };\n        }\n\n        console.log('[Google Sign-In] User authenticated via tokens:', sessionData.user.id);\n        return await this.handleSocialAuthUser(\n          sessionData.user.id,\n          sessionData.user.email,\n          sessionData.user.user_metadata?.full_name || sessionData.user.user_metadata?.name\n        );\n      }\n      \n      // Try PKCE flow - check for authorization code\n      const code = queryParams.get('code');\n      \n      if (code) {\n        console.log('[Google Sign-In] Got authorization code, exchanging for session...');\n        const { data: sessionData, error: exchangeError } = await supabase.auth.exchangeCodeForSession(code);\n        \n        if (exchangeError) {\n          console.error('[Google Sign-In] Code exchange error:', exchangeError);\n          return { success: false, error: exchangeError.message };\n        }\n        \n        if (!sessionData?.user) {\n          return { success: false, error: 'No user returned from authentication' };\n        }\n        \n        console.log('[Google Sign-In] User authenticated via code exchange:', sessionData.user.id);\n        return await this.handleSocialAuthUser(\n          sessionData.user.id,\n          sessionData.user.email,\n          sessionData.user.user_metadata?.full_name || sessionData.user.user_metadata?.name\n        );\n      }\n      \n      // Fallback: Check current session (in case tokens were set automatically)\n      console.log('[Google Sign-In] No tokens/code in URL, checking current session...');\n      const { data: { session }, error: getSessionError } = await supabase.auth.getSession();\n      \n      if (getSessionError) {\n        console.error('[Google Sign-In] Get session error:', getSessionError);\n        return { success: false, error: getSessionError.message };\n      }\n      \n      if (session?.user) {\n        console.log('[Google Sign-In] User authenticated from existing session:', session.user.id);\n        return await this.handleSocialAuthUser(\n          session.user.id,\n          session.user.email,\n          session.user.user_metadata?.full_name || session.user.user_metadata?.name\n        );\n      }\n\n      // If we got here, something went wrong\n      console.error('[Google Sign-In] No session found after auth. URL was:', url);\n      console.error('[Google Sign-In] Hash params:', Object.fromEntries(hashParams.entries()));\n      console.error('[Google Sign-In] Query params:', Object.fromEntries(queryParams.entries()));\n      return { success: false, error: 'Authentication completed but no session was created. Please try again.' };\n    } catch (error: any) {\n      console.error('[Google Sign-In] Error:', error);\n      return { success: false, error: error.message || 'Google Sign-In failed' };\n    }\n  },\n\n  async handleSocialAuthUser(\n    userId: string,\n    email?: string | null,\n    fullName?: string | null\n  ): Promise<SocialAuthResult> {\n    try {\n      console.log('[Social Auth] Handling user:', userId, 'email:', email, 'name:', fullName);\n      \n      const { data: existingUser, error: fetchError } = await supabase\n        .from('users')\n        .select('*')\n        .eq('id', userId)\n        .single();\n\n      if (fetchError && fetchError.code !== 'PGRST116') {\n        console.error('Error fetching user:', fetchError);\n        return { success: false, error: 'Failed to check user profile' };\n      }\n\n      if (existingUser) {\n        console.log('[Social Auth] Existing user found:', existingUser);\n        \n        // Check for missing required fields\n        const needsPhone = !existingUser.phone;\n        const needsDOB = !existingUser.date_of_birth;\n        const needsName = !existingUser.name || existingUser.name === 'User';\n        \n        // If we have a name from OAuth but user profile has generic name, update it\n        if (fullName && needsName) {\n          console.log('[Social Auth] Updating user name to:', fullName);\n          await supabase.from('users').update({ name: fullName }).eq('id', userId);\n        }\n        \n        // Check if wallet exists, create if not\n        const { data: wallet, error: walletError } = await supabase\n          .from('wallets')\n          .select('id')\n          .eq('user_id', userId)\n          .single();\n        \n        if (!wallet && (!walletError || walletError.code === 'PGRST116')) {\n          console.log('[Social Auth] Creating wallet for existing user...');\n          await this.createWalletForUser(userId);\n        }\n        \n        return {\n          success: true,\n          userId,\n          email: email || undefined,\n          fullName: existingUser.name || fullName || undefined,\n          needsPhoneVerification: needsPhone,\n          needsDOB: needsDOB,\n          needsProfileCompletion: needsName,\n          needsName: needsName,\n          existingPhone: existingUser.phone,\n        };\n      }\n\n      // New user - create profile and wallet\n      console.log('[Social Auth] Creating new user profile...');\n      \n      // Generate a unique 6-7 digit ID for the user\n      let uniqueId = generateUniqueId();\n      \n      // Check for collision and regenerate if needed (up to 5 attempts)\n      for (let attempt = 0; attempt < 5; attempt++) {\n        const { data: existingId } = await supabase\n          .from('users')\n          .select('id')\n          .eq('unique_id', uniqueId)\n          .single();\n        \n        if (!existingId) break;\n        uniqueId = generateUniqueId();\n      }\n      \n      // Use RPC to create profile if available, otherwise direct insert\n      const { data: profileData, error: rpcError } = await supabase\n        .rpc('create_user_profile', {\n          user_id: userId,\n          user_unique_id: uniqueId,\n          user_name: fullName || 'User',\n          user_email: email || '',\n          user_phone: null,\n          user_dob: null,\n          user_bio: null,\n          user_profile_picture: null,\n        });\n      \n      if (rpcError) {\n        console.log('[Social Auth] RPC failed, using direct insert:', rpcError.message);\n        // Fall back to direct insert\n        const { error: insertError } = await supabase.from('users').insert({\n          id: userId,\n          unique_id: uniqueId,\n          name: fullName || 'User',\n          email: email || '',\n          phone: null,\n          date_of_birth: null,\n          profile_picture: null,\n          bio: null,\n        });\n\n        if (insertError) {\n          console.error('Error creating user profile:', insertError);\n          return { success: false, error: 'Failed to create user profile' };\n        }\n      }\n      \n      console.log('[Social Auth] Profile created, creating wallet...');\n      \n      // Create wallet for new user\n      await this.createWalletForUser(userId);\n\n      return {\n        success: true,\n        userId,\n        email: email || undefined,\n        fullName: fullName || undefined,\n        needsPhoneVerification: true,\n        needsDOB: true,\n        needsProfileCompletion: !fullName,\n        needsName: !fullName,\n      };\n    } catch (error: any) {\n      console.error('Error handling social auth user:', error);\n      return { success: false, error: error.message || 'Failed to process authentication' };\n    }\n  },\n\n  async createWalletForUser(userId: string): Promise<void> {\n    try {\n      // Try RPC first\n      const { error: rpcError } = await supabase.rpc('create_user_wallet', {\n        p_user_id: userId,\n      });\n      \n      if (rpcError) {\n        console.log('[Social Auth] Wallet RPC failed, using direct insert:', rpcError.message);\n        // Fall back to direct insert\n        const { error: insertError } = await supabase.from('wallets').insert({\n          user_id: userId,\n          balance: 0,\n          bank_connected: false,\n        });\n        \n        if (insertError && insertError.code !== '23505') { // Ignore duplicate key errors\n          console.error('Failed to create wallet:', insertError);\n        }\n      }\n      console.log('[Social Auth] Wallet created for user:', userId);\n    } catch (error: any) {\n      console.error('Error creating wallet:', error);\n    }\n  },\n\n  async isAppleSignInAvailable(): Promise<boolean> {\n    if (Platform.OS !== 'ios') return false;\n    try {\n      return await AppleAuthentication.isAvailableAsync();\n    } catch {\n      return false;\n    }\n  },\n};\n","path":null,"size_bytes":14727,"size_tokens":null},"screens/SocialSignupPhoneOTPScreen.tsx":{"content":"import React, { useState, useRef, useEffect } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, Keyboard, Platform } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { TwilioService } from '@/services/twilio.service';\nimport { supabase } from '@/services/supabase';\n\ntype Props = NativeStackScreenProps<any, 'SocialSignupPhoneOTP'>;\n\nexport default function SocialSignupPhoneOTPScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const params = route.params as { \n    userId: string;\n    email?: string;\n    fullName?: string;\n    provider: 'apple' | 'google';\n    phone: string;\n  };\n\n  if (!params?.userId || !params?.phone) {\n    return (\n      <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n        <View style={styles.content}>\n          <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.md }]}>\n            Something went wrong\n          </ThemedText>\n          <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n            We could not complete your verification. Please try again.\n          </ThemedText>\n        </View>\n      </ScreenKeyboardAwareScrollView>\n    );\n  }\n  \n  const [code, setCode] = useState(['', '', '', '', '', '']);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n  const [resendDisabled, setResendDisabled] = useState(true);\n  const [countdown, setCountdown] = useState(60);\n  \n  const inputRefs = useRef<(TextInput | null)[]>([]);\n  const hiddenInputRef = useRef<TextInput | null>(null);\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCountdown((prev) => {\n        if (prev <= 1) {\n          setResendDisabled(false);\n          clearInterval(timer);\n          return 0;\n        }\n        return prev - 1;\n      });\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, []);\n\n  const handleCodeChange = (index: number, value: string) => {\n    if (!/^\\d*$/.test(value)) return;\n    \n    if (value.length > 1) {\n      const digits = value.replace(/\\D/g, '').slice(0, 6).split('');\n      const newCode = ['', '', '', '', '', ''];\n      digits.forEach((digit, i) => {\n        newCode[i] = digit;\n      });\n      setCode(newCode);\n      setError('');\n      \n      if (digits.length === 6) {\n        Keyboard.dismiss();\n        handleVerify(newCode.join(''));\n      } else if (digits.length > 0) {\n        inputRefs.current[digits.length]?.focus();\n      }\n      return;\n    }\n    \n    const newCode = [...code];\n    newCode[index] = value;\n    setCode(newCode);\n    setError('');\n\n    if (value && index < 5) {\n      inputRefs.current[index + 1]?.focus();\n    }\n\n    if (newCode.every(digit => digit !== '') && newCode.join('').length === 6) {\n      Keyboard.dismiss();\n      handleVerify(newCode.join(''));\n    }\n  };\n  \n  const handleHiddenInputChange = (value: string) => {\n    const digits = value.replace(/\\D/g, '').slice(0, 6);\n    if (digits.length > 0) {\n      const newCode = ['', '', '', '', '', ''];\n      digits.split('').forEach((digit, i) => {\n        newCode[i] = digit;\n      });\n      setCode(newCode);\n      setError('');\n      \n      if (digits.length === 6) {\n        Keyboard.dismiss();\n        handleVerify(digits);\n      } else {\n        inputRefs.current[digits.length]?.focus();\n      }\n    }\n  };\n\n  const handleKeyPress = (index: number, key: string) => {\n    if (key === 'Backspace' && !code[index] && index > 0) {\n      inputRefs.current[index - 1]?.focus();\n    }\n  };\n\n  const handleVerify = async (otp?: string) => {\n    const otpCode = otp || code.join('');\n    \n    if (otpCode.length !== 6) {\n      setError('Please enter the complete 6-digit code');\n      return;\n    }\n\n    setLoading(true);\n    setError('');\n\n    try {\n      const result = await TwilioService.verifyOTP(params.phone, otpCode);\n\n      if (result.valid) {\n        const { error: updateError } = await supabase\n          .from('users')\n          .update({ \n            phone: params.phone,\n            updated_at: new Date().toISOString()\n          })\n          .eq('id', params.userId);\n\n        if (updateError) {\n          setError('Failed to update profile. Please try again.');\n          return;\n        }\n\n        navigation.navigate('SocialSignupDOB', { \n          userId: params.userId,\n          fullName: params.fullName,\n          provider: params.provider,\n          phone: params.phone\n        });\n      } else {\n        setError(result.error || 'Invalid verification code. Please try again.');\n        setCode(['', '', '', '', '', '']);\n        inputRefs.current[0]?.focus();\n      }\n    } catch (err: any) {\n      setError(err.message || 'Verification failed. Please try again.');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleResend = async () => {\n    setResendDisabled(true);\n    setCountdown(60);\n    setError('');\n    setCode(['', '', '', '', '', '']);\n\n    try {\n      const result = await TwilioService.sendOTP(params.phone);\n      \n      if (!result.success) {\n        setError(result.error || 'Failed to resend code');\n        setResendDisabled(false);\n        setCountdown(0);\n      }\n    } catch (err: any) {\n      setError(err.message || 'Failed to resend code');\n      setResendDisabled(false);\n      setCountdown(0);\n    }\n\n    const timer = setInterval(() => {\n      setCountdown((prev) => {\n        if (prev <= 1) {\n          setResendDisabled(false);\n          clearInterval(timer);\n          return 0;\n        }\n        return prev - 1;\n      });\n    }, 1000);\n  };\n\n  const maskedPhone = params.phone.replace(/(\\+\\d{2})(\\d+)(\\d{2})$/, '$1 ••••• $3');\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Phone Verification\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.md }]}>\n          Enter verification code\n        </ThemedText>\n\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          We sent a 6-digit code to {maskedPhone}\n        </ThemedText>\n\n        {Platform.OS === 'ios' ? (\n          <TextInput\n            ref={hiddenInputRef}\n            style={styles.hiddenInput}\n            textContentType=\"oneTimeCode\"\n            autoComplete=\"sms-otp\"\n            keyboardType=\"number-pad\"\n            onChangeText={handleHiddenInputChange}\n            autoFocus\n          />\n        ) : null}\n        \n        <View style={styles.codeContainer}>\n          {code.map((digit, index) => (\n            <TextInput\n              key={index}\n              ref={(ref) => { inputRefs.current[index] = ref; }}\n              style={[\n                styles.codeInput,\n                { \n                  backgroundColor: theme.surface, \n                  color: theme.text, \n                  borderColor: error ? Colors.light.danger : (digit ? theme.primary : theme.border),\n                }\n              ]}\n              value={digit}\n              onChangeText={(value) => handleCodeChange(index, value)}\n              onKeyPress={({ nativeEvent }) => handleKeyPress(index, nativeEvent.key)}\n              keyboardType=\"number-pad\"\n              maxLength={6}\n              selectTextOnFocus\n              autoFocus={Platform.OS !== 'ios' && index === 0}\n              textContentType={index === 0 ? 'oneTimeCode' : 'none'}\n              autoComplete={index === 0 ? 'sms-otp' : 'off'}\n            />\n          ))}\n        </View>\n\n        {error ? (\n          <ThemedText style={[Typography.caption, { color: Colors.light.danger, marginTop: Spacing.md, textAlign: 'center' }]}>\n            {error}\n          </ThemedText>\n        ) : null}\n\n        <View style={styles.resendContainer}>\n          {resendDisabled ? (\n            <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n              Resend code in {countdown}s\n            </ThemedText>\n          ) : (\n            <Pressable onPress={handleResend}>\n              <ThemedText style={[Typography.body, { color: theme.primary, fontWeight: '600' }]}>\n                Resend Code\n              </ThemedText>\n            </Pressable>\n          )}\n        </View>\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed || loading ? 0.7 : (code.every(d => d) ? 1 : 0.4)\n            }\n          ]}\n          onPress={() => handleVerify()}\n          disabled={loading || !code.every(d => d)}\n        >\n          <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n            {loading ? 'Verifying...' : 'Verify'}\n          </ThemedText>\n        </Pressable>\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  codeContainer: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    gap: Spacing.sm,\n  },\n  codeInput: {\n    flex: 1,\n    height: 56,\n    borderWidth: 2,\n    borderRadius: BorderRadius.sm,\n    fontSize: 24,\n    fontWeight: '600',\n    textAlign: 'center',\n  },\n  hiddenInput: {\n    position: 'absolute',\n    width: 1,\n    height: 1,\n    opacity: 0,\n  },\n  resendContainer: {\n    alignItems: 'center',\n    marginTop: Spacing.xl,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":10233,"size_tokens":null},"screens/SocialSignupDOBScreen.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { View, StyleSheet, Pressable, Platform, TextInput, ActivityIndicator } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport DateTimePicker from '@react-native-community/datetimepicker';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenScrollView } from '@/components/ScreenScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { supabase } from '@/services/supabase';\n\ntype Props = NativeStackScreenProps<any, 'SocialSignupDOB'>;\n\nexport default function SocialSignupDOBScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const { clearSignupOverlay } = useAuth();\n  const [date, setDate] = useState(new Date(2000, 0, 1));\n  const [dateText, setDateText] = useState('2000-01-01');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n  \n  const params = route.params as { \n    userId: string;\n    fullName?: string;\n    provider: 'apple' | 'google';\n    phone: string;\n  };\n\n  // Clear the loading overlay once this screen mounts (navigation is complete)\n  useEffect(() => {\n    clearSignupOverlay();\n  }, []);\n\n  const isValidAge = () => {\n    const today = new Date();\n    const birthDate = date;\n    let age = today.getFullYear() - birthDate.getFullYear();\n    const monthDiff = today.getMonth() - birthDate.getMonth();\n    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {\n      age--;\n    }\n    return age >= 16;\n  };\n\n  const handleContinue = async () => {\n    if (!isValidAge()) {\n      setError('You must be at least 16 years old to use Spline');\n      return;\n    }\n\n    setLoading(true);\n    setError('');\n\n    try {\n      const { error: updateError } = await supabase\n        .from('users')\n        .update({ \n          date_of_birth: date.toISOString().split('T')[0],\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', params.userId);\n\n      if (updateError) {\n        setError('Failed to save your birthday. Please try again.');\n        return;\n      }\n\n      navigation.navigate('SocialSignupProfilePicture', { \n        userId: params.userId,\n        fullName: params.fullName,\n        provider: params.provider\n      });\n    } catch (err: any) {\n      setError(err.message || 'Something went wrong. Please try again.');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleDateTextChange = (text: string) => {\n    setDateText(text);\n    setError('');\n    const parsedDate = new Date(text);\n    if (!isNaN(parsedDate.getTime())) {\n      setDate(parsedDate);\n    }\n  };\n\n  const getFirstName = () => {\n    if (params.fullName) {\n      return params.fullName.split(' ')[0];\n    }\n    return '';\n  };\n\n  return (\n    <ScreenScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Almost Done\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.md }]}>\n          {getFirstName() ? `${getFirstName()}, when's your birthday?` : \"When's your birthday?\"}\n        </ThemedText>\n\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing.xl }]}>\n          You must be at least 16 years old to use Spline\n        </ThemedText>\n\n        <View style={styles.pickerContainer}>\n          {Platform.OS === 'web' ? (\n            <View style={styles.webInputContainer}>\n              <ThemedText style={[Typography.small, { color: theme.textSecondary, marginBottom: Spacing.sm }]}>\n                Date of Birth (YYYY-MM-DD)\n              </ThemedText>\n              <TextInput\n                style={[\n                  styles.webInput,\n                  {\n                    backgroundColor: theme.surface,\n                    color: theme.text,\n                    borderColor: error ? Colors.light.danger : theme.border,\n                  }\n                ]}\n                value={dateText}\n                onChangeText={handleDateTextChange}\n                placeholder=\"2000-01-01\"\n                placeholderTextColor={theme.textSecondary}\n                autoCapitalize=\"none\"\n              />\n            </View>\n          ) : (\n            <DateTimePicker\n              value={date}\n              mode=\"date\"\n              display={Platform.OS === 'ios' ? 'spinner' : 'default'}\n              onChange={(event, selectedDate) => {\n                if (selectedDate) {\n                  setDate(selectedDate);\n                  setError('');\n                }\n              }}\n              maximumDate={new Date()}\n              minimumDate={new Date(1900, 0, 1)}\n              textColor={theme.text}\n            />\n          )}\n        </View>\n\n        {error ? (\n          <ThemedText style={[Typography.caption, { color: Colors.light.danger, marginTop: Spacing.md, textAlign: 'center' }]}>\n            {error}\n          </ThemedText>\n        ) : null}\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { backgroundColor: theme.primary, opacity: pressed || loading ? 0.7 : 1 }\n          ]}\n          onPress={handleContinue}\n          disabled={loading}\n        >\n          {loading ? (\n            <ActivityIndicator color={Colors.light.buttonText} />\n          ) : (\n            <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n              Continue\n            </ThemedText>\n          )}\n        </Pressable>\n      </View>\n    </ScreenScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  pickerContainer: {\n    alignItems: 'center',\n  },\n  webInputContainer: {\n    width: '100%',\n  },\n  webInput: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.md,\n    fontSize: 16,\n    borderWidth: 1,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":6574,"size_tokens":null},"screens/SocialSignupNameScreen.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, ActivityIndicator } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { supabase } from '@/services/supabase';\n\ntype Props = NativeStackScreenProps<any, 'SocialSignupName'>;\n\nexport default function SocialSignupNameScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const { clearSignupOverlay } = useAuth();\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState('');\n  \n  const params = route.params as { \n    userId: string;\n    email?: string;\n    provider: 'apple' | 'google';\n    needsPhone?: boolean;\n    needsDOB?: boolean;\n    existingPhone?: string;\n  };\n\n  // Clear the loading overlay once this screen mounts (navigation is complete)\n  useEffect(() => {\n    clearSignupOverlay();\n  }, []);\n\n  if (!params?.userId) {\n    return (\n      <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n        <ThemedView style={styles.content}>\n          <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.md }]}>\n            Something went wrong\n          </ThemedText>\n          <ThemedText style={[Typography.body, { color: theme.textSecondary }]}>\n            We could not complete your sign-in. Please try again.\n          </ThemedText>\n        </ThemedView>\n      </ScreenKeyboardAwareScrollView>\n    );\n  }\n\n  const isValidName = () => {\n    return firstName.trim().length >= 1 && lastName.trim().length >= 1;\n  };\n\n  const handleContinue = async () => {\n    if (!isValidName()) {\n      setError('Please enter your first and last name');\n      return;\n    }\n\n    setLoading(true);\n    setError('');\n\n    try {\n      const fullName = `${firstName.trim()} ${lastName.trim()}`;\n      \n      const { error: updateError } = await supabase\n        .from('users')\n        .update({ \n          name: fullName,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', params.userId);\n\n      if (updateError) {\n        setError('Failed to save your name. Please try again.');\n        return;\n      }\n\n      if (params.needsPhone) {\n        navigation.navigate('SocialSignupPhone', { \n          userId: params.userId,\n          email: params.email,\n          fullName: fullName,\n          provider: params.provider,\n        });\n      } else if (params.needsDOB) {\n        navigation.navigate('SocialSignupDOB', { \n          userId: params.userId,\n          fullName: fullName,\n          provider: params.provider,\n          phone: params.existingPhone,\n        });\n      } else {\n        navigation.navigate('SocialSignupComplete', { \n          userId: params.userId,\n          fullName: fullName,\n          provider: params.provider\n        });\n      }\n    } catch (err: any) {\n      setError(err.message || 'Something went wrong. Please try again.');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Complete Your Profile\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.md }]}>\n          What's your name?\n        </ThemedText>\n\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing.xl }]}>\n          This will be displayed to your friends when splitting bills\n        </ThemedText>\n\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: error ? Colors.light.danger : theme.border \n          }]}\n          placeholder=\"First name\"\n          placeholderTextColor={theme.textSecondary}\n          value={firstName}\n          onChangeText={(text) => {\n            setFirstName(text);\n            if (error) setError('');\n          }}\n          autoCapitalize=\"words\"\n          autoFocus\n        />\n\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: error ? Colors.light.danger : theme.border \n          }]}\n          placeholder=\"Last name\"\n          placeholderTextColor={theme.textSecondary}\n          value={lastName}\n          onChangeText={(text) => {\n            setLastName(text);\n            if (error) setError('');\n          }}\n          autoCapitalize=\"words\"\n        />\n\n        {error ? (\n          <ThemedText style={[Typography.caption, { color: Colors.light.danger, marginTop: Spacing.sm }]}>\n            {error}\n          </ThemedText>\n        ) : null}\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed || loading ? 0.7 : (isValidName() ? 1 : 0.4)\n            }\n          ]}\n          onPress={handleContinue}\n          disabled={!isValidName() || loading}\n        >\n          {loading ? (\n            <ActivityIndicator color={Colors.light.buttonText} />\n          ) : (\n            <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n              Continue\n            </ThemedText>\n          )}\n        </Pressable>\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  input: {\n    height: Spacing.inputHeight,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    marginBottom: Spacing.md,\n    fontSize: 16,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":6603,"size_tokens":null},"screens/SocialSignupProfilePictureScreen.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { View, StyleSheet, Pressable, Image, Alert, ActivityIndicator, Platform } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport * as ImagePicker from 'expo-image-picker';\nimport { Feather } from '@expo/vector-icons';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenScrollView } from '@/components/ScreenScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { AuthService } from '@/services/auth.service';\n\ntype Props = NativeStackScreenProps<any, 'SocialSignupProfilePicture'>;\n\nexport default function SocialSignupProfilePictureScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const { clearSignupOverlay } = useAuth();\n  const [profilePicture, setProfilePicture] = useState<string | undefined>();\n  const [loading, setLoading] = useState(false);\n  \n  const params = route.params as { \n    userId: string;\n    fullName?: string;\n    provider: 'apple' | 'google';\n  };\n\n  useEffect(() => {\n    clearSignupOverlay();\n  }, []);\n\n  const pickImage = async () => {\n    const { status: currentStatus } = await ImagePicker.getMediaLibraryPermissionsAsync();\n    \n    if (currentStatus !== 'granted') {\n      Alert.alert(\n        'Photo Library Access',\n        'Spline would like to access your photo library to let you choose a profile picture.',\n        [\n          {\n            text: 'Not Now',\n            style: 'cancel',\n          },\n          {\n            text: 'Allow Access',\n            onPress: async () => {\n              const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();\n              if (status === 'granted') {\n                await launchImagePicker();\n              } else {\n                Alert.alert(\n                  'Permission Required',\n                  'To upload a profile picture, please enable photo library access in your device settings.',\n                  [{ text: 'OK' }]\n                );\n              }\n            },\n          },\n        ]\n      );\n    } else {\n      await launchImagePicker();\n    }\n  };\n\n  const launchImagePicker = async () => {\n    const result = await ImagePicker.launchImageLibraryAsync({\n      mediaTypes: ['images'],\n      allowsEditing: true,\n      aspect: [1, 1],\n      quality: 0.8,\n    });\n\n    if (!result.canceled && result.assets[0]) {\n      setProfilePicture(result.assets[0].uri);\n    }\n  };\n\n  const handleContinue = async () => {\n    setLoading(true);\n    \n    try {\n      let avatarUrl: string | null = null;\n      \n      if (profilePicture) {\n        try {\n          console.log('[SocialSignupProfilePicture] Uploading profile picture using AuthService...');\n          avatarUrl = await AuthService.uploadProfilePicture(params.userId, profilePicture);\n          console.log('[SocialSignupProfilePicture] Profile picture uploaded successfully:', avatarUrl);\n        } catch (uploadError: any) {\n          console.error('[SocialSignupProfilePicture] Upload error:', uploadError);\n          const errorMessage = uploadError.message || 'Failed to upload your profile picture';\n          Alert.alert('Upload Failed', `${errorMessage}. Would you like to try again or skip?`, [\n            {\n              text: 'Try Again',\n              onPress: () => setLoading(false),\n            },\n            {\n              text: 'Skip',\n              onPress: () => {\n                setLoading(false);\n                navigation.navigate('SocialSignupBio', { \n                  userId: params.userId,\n                  fullName: params.fullName,\n                  provider: params.provider,\n                  avatarUrl: null,\n                });\n              },\n            },\n          ]);\n          return;\n        }\n      }\n\n      setLoading(false);\n      navigation.navigate('SocialSignupBio', { \n        userId: params.userId,\n        fullName: params.fullName,\n        provider: params.provider,\n        avatarUrl: avatarUrl,\n      });\n    } catch (error: any) {\n      console.error('[SocialSignupProfilePicture] handleContinue error:', error);\n      Alert.alert('Error', error.message || 'Failed to save profile picture. Please try again.');\n      setLoading(false);\n    }\n  };\n\n  const getFirstName = () => {\n    if (params.fullName) {\n      return params.fullName.split(' ')[0];\n    }\n    return '';\n  };\n\n  return (\n    <ScreenScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          Almost Done\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.xl, textAlign: 'center' }]}>\n          {getFirstName() ? `${getFirstName()}, add a profile picture` : 'Add a profile picture'}\n        </ThemedText>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.avatarContainer,\n            { \n              backgroundColor: theme.backgroundSecondary,\n              borderColor: theme.border,\n              opacity: pressed ? 0.7 : 1\n            }\n          ]}\n          onPress={pickImage}\n          disabled={loading}\n        >\n          {profilePicture ? (\n            <Image source={{ uri: profilePicture }} style={styles.avatar} />\n          ) : (\n            <Feather name=\"camera\" size={40} color={theme.textSecondary} />\n          )}\n        </Pressable>\n\n        <Pressable\n          style={({ pressed }) => [styles.linkButton, { opacity: pressed ? 0.7 : 1 }]}\n          onPress={pickImage}\n          disabled={loading}\n        >\n          <ThemedText style={[Typography.body, { color: theme.primary }]}>\n            {profilePicture ? 'Change photo' : 'Choose from gallery'}\n          </ThemedText>\n        </Pressable>\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { backgroundColor: theme.primary, opacity: pressed || loading ? 0.7 : 1 }\n          ]}\n          onPress={handleContinue}\n          disabled={loading}\n        >\n          {loading ? (\n            <ActivityIndicator color={Colors.light.buttonText} />\n          ) : (\n            <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n              {profilePicture ? 'Continue' : 'Skip for now'}\n            </ThemedText>\n          )}\n        </Pressable>\n      </View>\n    </ScreenScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  avatarContainer: {\n    width: Spacing.avatarXLarge,\n    height: Spacing.avatarXLarge,\n    borderRadius: Spacing.avatarXLarge / 2,\n    borderWidth: 2,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginBottom: Spacing.lg,\n    overflow: 'hidden',\n  },\n  avatar: {\n    width: '100%',\n    height: '100%',\n  },\n  linkButton: {\n    marginTop: Spacing.sm,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":7477,"size_tokens":null},"screens/SocialSignupBioScreen.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { View, TextInput, StyleSheet, Pressable, ActivityIndicator, Alert } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { ThemedText } from '@/components/ThemedText';\nimport { ThemedView } from '@/components/ThemedView';\nimport { ScreenKeyboardAwareScrollView } from '@/components/ScreenKeyboardAwareScrollView';\nimport { useTheme } from '@/hooks/useTheme';\nimport { useAuth } from '@/hooks/useAuth';\nimport { Colors, Spacing, BorderRadius, Typography } from '@/constants/theme';\nimport { supabase } from '@/services/supabase';\n\ntype Props = NativeStackScreenProps<any, 'SocialSignupBio'>;\n\nexport default function SocialSignupBioScreen({ navigation, route }: Props) {\n  const { theme } = useTheme();\n  const { clearSignupOverlay } = useAuth();\n  const [bio, setBio] = useState('');\n  const [loading, setLoading] = useState(false);\n  \n  const params = route.params as { \n    userId: string;\n    fullName?: string;\n    provider: 'apple' | 'google';\n    avatarUrl?: string;\n  };\n\n  const MAX_LENGTH = 200;\n\n  useEffect(() => {\n    clearSignupOverlay();\n  }, []);\n\n  const handleContinue = async () => {\n    setLoading(true);\n\n    try {\n      if (bio.trim()) {\n        const { error: updateError } = await supabase\n          .from('users')\n          .update({ \n            bio: bio.trim(),\n            updated_at: new Date().toISOString()\n          })\n          .eq('id', params.userId);\n\n        if (updateError) {\n          console.error('Error updating bio:', updateError);\n          Alert.alert('Error', 'Failed to save your bio. Please try again.');\n          setLoading(false);\n          return;\n        }\n      }\n\n      navigation.navigate('SocialSignupComplete', { \n        userId: params.userId,\n        fullName: params.fullName,\n        provider: params.provider\n      });\n    } catch (error: any) {\n      Alert.alert('Error', 'Failed to save bio. Please try again.');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const getFirstName = () => {\n    if (params.fullName) {\n      return params.fullName.split(' ')[0];\n    }\n    return '';\n  };\n\n  return (\n    <ScreenKeyboardAwareScrollView contentContainerStyle={styles.container}>\n      <ThemedView style={styles.content}>\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginBottom: Spacing['2xl'] }]}>\n          One More Thing\n        </ThemedText>\n\n        <ThemedText style={[Typography.hero, { color: theme.text, marginBottom: Spacing.md }]}>\n          {getFirstName() ? `${getFirstName()}, tell us about yourself` : 'Tell us about yourself'}\n        </ThemedText>\n\n        <ThemedText style={[Typography.body, { color: theme.textSecondary, marginBottom: Spacing.xl }]}>\n          Add a short bio so your friends know it's you\n        </ThemedText>\n\n        <TextInput\n          style={[styles.input, { \n            backgroundColor: theme.surface, \n            color: theme.text, \n            borderColor: theme.border \n          }]}\n          placeholder=\"Write a short bio...\"\n          placeholderTextColor={theme.textSecondary}\n          value={bio}\n          onChangeText={(text) => text.length <= MAX_LENGTH && setBio(text)}\n          multiline\n          numberOfLines={4}\n          autoFocus\n          textAlignVertical=\"top\"\n        />\n\n        <ThemedText style={[Typography.caption, { color: theme.textSecondary, marginTop: Spacing.sm }]}>\n          {bio.length}/{MAX_LENGTH} characters\n        </ThemedText>\n      </ThemedView>\n\n      <View style={styles.footer}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.button,\n            { \n              backgroundColor: theme.primary, \n              opacity: pressed || loading ? 0.7 : 1\n            }\n          ]}\n          onPress={handleContinue}\n          disabled={loading}\n        >\n          {loading ? (\n            <ActivityIndicator color={Colors.light.buttonText} />\n          ) : (\n            <ThemedText style={[Typography.body, { color: Colors.light.buttonText, fontWeight: '600' }]}>\n              {bio.trim() ? 'Continue' : 'Skip for now'}\n            </ThemedText>\n          )}\n        </Pressable>\n      </View>\n    </ScreenKeyboardAwareScrollView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexGrow: 1,\n  },\n  content: {\n    flex: 1,\n    justifyContent: 'center',\n    paddingHorizontal: Spacing.xl,\n  },\n  input: {\n    height: 120,\n    borderWidth: 1,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    paddingTop: Spacing.lg,\n    fontSize: 16,\n  },\n  footer: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.xs,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n","path":null,"size_bytes":4836,"size_tokens":null},"utils/RootNavigation.ts":{"content":"import { createNavigationContainerRef, CommonActions, StackActions } from '@react-navigation/native';\n\nexport const navigationRef = createNavigationContainerRef();\n\ninterface PendingNav {\n  name: string;\n  params?: object;\n  timestamp: number;\n}\n\nlet pendingNavigation: PendingNav | null = null;\nlet onReadyCallbacks: (() => void)[] = [];\n\nexport function isReady(): boolean {\n  return navigationRef.isReady();\n}\n\nexport function onNavigationReady(callback: () => void) {\n  if (navigationRef.isReady()) {\n    callback();\n  } else {\n    onReadyCallbacks.push(callback);\n  }\n}\n\nexport function notifyReady() {\n  console.log('[RootNavigation] Navigator is ready, processing callbacks');\n  onReadyCallbacks.forEach(cb => {\n    try {\n      cb();\n    } catch (e) {\n      console.error('[RootNavigation] Callback error:', e);\n    }\n  });\n  onReadyCallbacks = [];\n  \n  if (pendingNavigation && Date.now() - pendingNavigation.timestamp < 10000) {\n    console.log('[RootNavigation] Processing pending navigation to:', pendingNavigation.name);\n    setTimeout(() => {\n      if (pendingNavigation) {\n        performNavigation(pendingNavigation.name, pendingNavigation.params);\n        pendingNavigation = null;\n      }\n    }, 500);\n  }\n}\n\nfunction performNavigation(name: string, params?: object) {\n  if (!navigationRef.isReady()) {\n    console.warn('[RootNavigation] Cannot navigate - navigator not ready');\n    return;\n  }\n  \n  console.log('[RootNavigation] Performing navigation to:', name, 'params:', JSON.stringify(params));\n  \n  try {\n    navigationRef.dispatch(\n      CommonActions.navigate({\n        name,\n        params,\n      })\n    );\n  } catch (error) {\n    console.error('[RootNavigation] Navigation dispatch error:', error);\n  }\n}\n\nexport function navigate(name: string, params?: object) {\n  if (navigationRef.isReady()) {\n    performNavigation(name, params);\n  } else {\n    console.log('[RootNavigation] Navigator not ready, queueing navigation to:', name);\n    pendingNavigation = { name, params, timestamp: Date.now() };\n    \n    const retryNavigation = (attempts: number) => {\n      setTimeout(() => {\n        if (navigationRef.isReady() && pendingNavigation) {\n          console.log('[RootNavigation] Retry successful, navigating to:', pendingNavigation.name);\n          performNavigation(pendingNavigation.name, pendingNavigation.params);\n          pendingNavigation = null;\n        } else if (attempts > 0 && pendingNavigation) {\n          retryNavigation(attempts - 1);\n        } else if (pendingNavigation) {\n          console.warn('[RootNavigation] Navigator never became ready after retries');\n        }\n      }, 200);\n    };\n    retryNavigation(25);\n  }\n}\n\nexport function goBack() {\n  if (navigationRef.isReady()) {\n    navigationRef.goBack();\n  }\n}\n\nexport function reset(name: string, params?: object) {\n  if (navigationRef.isReady()) {\n    navigationRef.dispatch(\n      CommonActions.reset({\n        index: 0,\n        routes: [{ name, params }],\n      })\n    );\n  }\n}\n\nexport function hasPendingNavigation(): boolean {\n  return pendingNavigation !== null;\n}\n\nexport function clearPendingNavigation() {\n  pendingNavigation = null;\n}\n","path":null,"size_bytes":3149,"size_tokens":null}},"version":2}